# Korean translation for translation.ko package
# doc/manual/R-lang.texi
#
# Copyright (C) 2008-2015 Chel Hee Lee, and R Translation Teams
#
# This file is distributed under the same license as the R distribution.
# Chel Hee Lee <chl948@mail.usask.ca>, 2008-2015.
#
# Note that every single contributor listed on the Acknowledgement 
# assigns his or her contribution to Chel Hee Lee.
#
# Note also that your name may not be found because of incomplete 
# record keeping.  If you were overlooked, please let the maintainer 
# know and the list will be updated.  Please also contact the mainter 
# of this document in order to voluntarily participate in 
# or offer your help with this work. 
# 
msgid ""
msgstr ""
"Project-Id-Version: translation.ko_0.0.1.4\n"
"Report-Msgid-Bugs-To: chl948@mail.usask.ca\n"
"POT-Creation-Date: 2015-08-18 02:47-0600\n"
"PO-Revision-Date: 2015-07-20 22:48-0600\n"
"Last-Translator: Chel Hee Lee  <chl948@mail.usask.ca>\n"
"Language-Team: Chel Hee Lee  <chl948@mail.usask.ca>\n"
"Language: ko\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#. type: top
#: R-lang.texi:4
#: R-lang.texi:35
#: R-lang.texi:53
#, no-wrap
msgid "R Language Definition"
msgstr ""

#. type: dircategory
#: R-lang.texi:10
#, no-wrap
msgid "Programming"
msgstr ""

#. type: menuentry
#: R-lang.texi:13
msgid "R Language: (R-lang)"
msgstr ""

#. type: menuentry
#: R-lang.texi:13
msgid "The R Language Definition."
msgstr ""

#. type: include
#: R-lang.texi:17
#, no-wrap
msgid "R-defs.texi"
msgstr ""

#. type: include
#: R-lang.texi:18
#, no-wrap
msgid "version.texi"
msgstr ""

#. type: strong{#1}
#: R-lang.texi:22
msgid "C"
msgstr ""

#. type: copying
#: R-lang.texi:26
msgid "This manual is for R, version @value{VERSION}."
msgstr ""

#. type: copying
#: R-lang.texi:28
msgid "@Rcopyright{2000}"
msgstr ""

#. type: quotation
#: R-lang.texi:31
msgid "@permission{}"
msgstr ""

#. type: subtitle
#: R-lang.texi:36
#, no-wrap
msgid "Version @value{VERSION} @b{DRAFT}"
msgstr ""

#. type: author
#: R-lang.texi:37
#, no-wrap
msgid "R Core Team"
msgstr ""

#. type: node
#: R-lang.texi:52
#: R-lang.texi:79
#: R-lang.texi:137
#: R-lang.texi:905
#: R-lang.texi:2186
#: R-lang.texi:2600
#: R-lang.texi:3125
#: R-lang.texi:3756
#: R-lang.texi:3881
#: R-lang.texi:3995
#: R-lang.texi:4152
#: R-lang.texi:4812
#: R-lang.texi:4817
#: R-lang.texi:4822
#, no-wrap
msgid "Top"
msgstr ""

#. type: node
#: R-lang.texi:52
#: R-lang.texi:77
#: R-lang.texi:79
#: R-lang.texi:81
#: R-lang.texi:137
#, no-wrap
msgid "Introduction"
msgstr ""

#. type: node
#: R-lang.texi:52
#, no-wrap
msgid "(dir)"
msgstr ""

#. type: ifnottex
#: R-lang.texi:58
msgid "This is an introduction to the @R{} language, explaining evaluation, parsing, object oriented programming, computing on the language, and so forth."
msgstr "이 문서는 @R{} 언어에 대한 소개자료로서 평가(evaluation), 구문 분석(parsing), 객체 지향 프로그래밍 (objective oriented programming), R 언어 상에서의 컴퓨팅 (computing) 등과 같은 내용을 설명하고 있습니다. "

#. type: node
#: R-lang.texi:77
#: R-lang.texi:79
#: R-lang.texi:137
#: R-lang.texi:138
#: R-lang.texi:251
#: R-lang.texi:639
#: R-lang.texi:782
#: R-lang.texi:905
#, no-wrap
msgid "Objects"
msgstr ""

#. type: node
#: R-lang.texi:77
#: R-lang.texi:137
#: R-lang.texi:905
#: R-lang.texi:907
#: R-lang.texi:933
#: R-lang.texi:1227
#: R-lang.texi:1508
#: R-lang.texi:1605
#: R-lang.texi:2030
#: R-lang.texi:2186
#, no-wrap
msgid "Evaluation of expressions"
msgstr ""

#. type: node
#: R-lang.texi:77
#: R-lang.texi:905
#: R-lang.texi:2186
#: R-lang.texi:2187
#: R-lang.texi:2195
#: R-lang.texi:2291
#: R-lang.texi:2299
#: R-lang.texi:2600
#, no-wrap
msgid "Functions"
msgstr ""

#. type: node
#: R-lang.texi:77
#: R-lang.texi:2186
#: R-lang.texi:2600
#: R-lang.texi:2601
#: R-lang.texi:2685
#: R-lang.texi:2832
#: R-lang.texi:2844
#: R-lang.texi:2878
#: R-lang.texi:2965
#: R-lang.texi:3041
#: R-lang.texi:3086
#: R-lang.texi:3125
#, no-wrap
msgid "Object-oriented programming"
msgstr ""

#. type: node
#: R-lang.texi:77
#: R-lang.texi:2600
#: R-lang.texi:3125
#: R-lang.texi:3126
#: R-lang.texi:3170
#: R-lang.texi:3290
#: R-lang.texi:3441
#: R-lang.texi:3496
#: R-lang.texi:3555
#: R-lang.texi:3715
#: R-lang.texi:3756
#, no-wrap
msgid "Computing on the language"
msgstr ""

#. type: node
#: R-lang.texi:77
#: R-lang.texi:3125
#: R-lang.texi:3756
#: R-lang.texi:3757
#: R-lang.texi:3765
#: R-lang.texi:3851
#: R-lang.texi:3871
#: R-lang.texi:3881
#, no-wrap
msgid "System and foreign language interfaces"
msgstr ""

#. type: node
#: R-lang.texi:77
#: R-lang.texi:3756
#: R-lang.texi:3881
#: R-lang.texi:3882
#: R-lang.texi:3896
#: R-lang.texi:3903
#: R-lang.texi:3924
#: R-lang.texi:3969
#: R-lang.texi:3995
#, no-wrap
msgid "Exception handling"
msgstr ""

#. type: node
#: R-lang.texi:77
#: R-lang.texi:3881
#: R-lang.texi:3995
#: R-lang.texi:3996
#: R-lang.texi:4052
#: R-lang.texi:4074
#: R-lang.texi:4120
#: R-lang.texi:4142
#: R-lang.texi:4152
#, no-wrap
msgid "Debugging"
msgstr ""

#. type: node
#: R-lang.texi:77
#: R-lang.texi:3995
#: R-lang.texi:4152
#: R-lang.texi:4153
#: R-lang.texi:4170
#: R-lang.texi:4250
#: R-lang.texi:4266
#: R-lang.texi:4546
#: R-lang.texi:4780
#: R-lang.texi:4812
#, no-wrap
msgid "Parser"
msgstr ""

#. type: node
#: R-lang.texi:77
#: R-lang.texi:4152
#: R-lang.texi:4812
#: R-lang.texi:4813
#: R-lang.texi:4817
#, no-wrap
msgid "Function and Variable Index"
msgstr ""

#. type: node
#: R-lang.texi:77
#: R-lang.texi:4812
#: R-lang.texi:4817
#: R-lang.texi:4818
#: R-lang.texi:4822
#, no-wrap
msgid "Concept Index"
msgstr ""

#. type: appendix
#: R-lang.texi:77
#: R-lang.texi:4817
#: R-lang.texi:4822
#: R-lang.texi:4823
#, no-wrap
msgid "References"
msgstr ""

#. type: Plain text
#: R-lang.texi:87
msgid "@R{} is a system for statistical computation and graphics. It provides, among other things, a programming language, high level graphics, interfaces to other languages and debugging facilities.  This manual details and defines the @R{} language."
msgstr "@R{}은 통계적 계산과 그래픽을 위한 시스템입니다.  R이 제공하는 것들은 여러 가지가 있지만 그 중에서도 프로그래밍 언어, 고수준의 그래픽스, 다른 언어와의 인터페이스, 그리고 디버깅 기능들을 제공합니다. 이 매뉴얼에서는 @R{} 언어에 대해서 상세히 기술하고 이를 정의합니다."

#. type: Plain text
#: R-lang.texi:92
msgid "The @R{} language is a dialect of @Sl{} which was designed in the 1980s and has been in widespread use in the statistical community since.  Its principal designer, John M. Chambers, was awarded the 1998 ACM Software Systems Award for @Sl{}."
msgstr "@R{} 언어는, 1980년대에 설계된 이후로 통계학 커뮤니티 내에서 널리 사용되어 온 @Sl{}라는 언어로부터 파생되었습니다. 이 @Sl{} 언어의 주 설계자인 존 챔버스 (John M. Chambers)는 1998 ACM Software Systems Awards을 수상한 바 있습니다."

#. type: Plain text
#: R-lang.texi:99
msgid "The language syntax has a superficial similarity with C, but the semantics are of the FPL (functional programming language) variety with stronger affinities with Lisp and @acronym{APL}.  In particular, it allows ``computing on the language'', which in turn makes it possible to write functions that take expressions as input, something that is often useful for statistical modeling and graphics."
msgstr "R 언어의 문법(syntax)은 겉으로 보기에는 C 언어와 유사하지만, 의미 구조(semantics)는 Lisp와  @acronym{APL}과 같은 언어들과 상당한 유사성을 가진 기능적 프로그래밍 언어(FPL; functional programming language)의 일종입니다. 특히, R 언어에서는 표현식(expression)을 입력으로서 받아들이는 함수를 작성하는 것이 가능하게 해주는 ``computing on the language (랭귀지를 이용한 컴퓨팅)''이 가능합니다. 이는 종종 통계 모델링(statistical modelling)과 그래픽에 유용합니다."

#. type: Plain text
#: R-lang.texi:101
msgid "It is possible to get quite far using @R{} interactively, executing"
msgstr "커맨드 라인 상에서 단순 표현식(simple expressions)을 대화식으로 @R{}을 사용하는 것만으로도 상당한 것들을 할 수 있습니다."

#. type: cindex
#: R-lang.texi:101
#: R-lang.texi:331
#: R-lang.texi:4492
#, no-wrap
msgid "expression"
msgstr ""

#. type: Plain text
#: R-lang.texi:106
msgid "simple expressions from the command line.  Some users may never need to go beyond that level, others will want to write their own functions either in an ad hoc fashion to systematize repetitive work or with the perspective of writing add-on packages for new functionality."
msgstr "일부 사용자들은 그러한 수준을 넘어갈 필요가 없겠지만, 어떤 사용자들은 반복적인 작업을 시스템화하거나 새로운 기능을 담은 애드온(add-on) 패키지를 작성하는 관점에서 사용자 자신만의 함수들을 만들고 싶어 할 것입니다."

#. type: Plain text
#: R-lang.texi:112
msgid "The purpose of this manual is to document the language @emph{per se}.  That is, the objects that it works on, and the details of the expression evaluation process, which are useful to know when programming @R{} functions.  Major subsystems for specific tasks, such as graphics, are only briefly described in this manual and will be documented separately."
msgstr "이 매뉴얼의 목적은 R 언어 그 자체를 문서화하는 것입니다. 즉, R 언어가 동작하는 객체들 그리고 표현식 평가 과정의 세부사항들과 같이 알고 있으면 @R{} 함수를 프로그래밍 할 때 유용한 내용들을 담고 있습니다. 그래픽과 같은 특정 작업을 위한 주요 하부 시스템은 이 매뉴얼에서는 간략히 소개만 되고 별도 문서로 만들어질 것입니다."

#. type: Plain text
#: R-lang.texi:116
msgid "Although much of the text will equally apply to @Sl{}, there are also some substantial differences, and in order not to confuse the issue we shall concentrate on describing @R{}."
msgstr "이 문서의 많은 내용들이 @Sl{}에도 동일하게 적용됩니다.  그러나, 몇 가지 중요한 차이점도 존재하기 때문에 혼란을 일으키지 않도록 @R{}을 설명하는 데에만 집중할 것입니다."

#. type: Plain text
#: R-lang.texi:127
msgid "The design of the language contains a number of fine points and common pitfalls which may surprise the user.  Most of these are due to consistency considerations at a deeper level, as we shall explain.  There are also a number of useful shortcuts and idioms, which allow the user to express quite complicated operations succinctly.  Many of these become natural once one is familiar with the underlying concepts.  In some cases, there are multiple ways of performing a task, but some of the techniques will rely on the language implementation, and others work at a higher level of abstraction.  In such cases we shall indicate the preferred usage."
msgstr "설계된 디자인은 여러가지 좋은 점들도 있지만 사용자를 놀라게 할 수도 있는 위험요소들도 있습니다. 이러한 것들의 대부분은 언어를 좀 더 깊은 수준에서의 일관성 때문에 존재하는 것으로 이들에 대해서는 나중에 설명하도록 하겠습니다. 꽤 복잡한 연산들을 간결하게 표현해 줄 수 있는 손 쉬운 방법들(shortcuts)과 특정한 방법(idioms)들이 있습니다. 이러한 것들의 대부분은 근본적인 개념들에 익숙해 진다면 사용에 있어 자연스러워 질 것입니다.  어떤 경우에는 하나의 작업을 수행하는 여러 가지 방법이 있는데, 이들 중 몇 가지는 랭귀지 구현에 의존하는 것이고 또 다른 몇 가지는 상위단계 추상화로부터 비롯되는 것입니다. 그러한 경우에는 선호되는 사용법을 명시하도록 할 것입니다."

#. type: Plain text
#: R-lang.texi:134
msgid "Some familiarity with @R{} is assumed.  This is not an introduction to @R{} but rather a programmers' reference manual.  Other manuals provide complementary information: in particular @ref{Preface, , , R-intro, An Introduction to R} provides an introduction to @R{} and @ref{System and foreign language interfaces, , , R-exts, Writing R Extensions} details how to extend @R{} using compiled code."
msgstr "독자들은 이미 어느 정도 @R{}에 익숙하다고 가정한 상태에서 문서가 작성되었습니다. 이 문서는 @R{}에 대한 소개서라고 하기 보다는 프로그래머의 레퍼런스 매뉴얼입니다. 추가적으로 필요한 내용들에 대해서는 다른 문서를 참고 해주시길 바랍니다. @ref{Preface, , , R-intro, An Introduction to R}은 @R{}에 대한 소개가 잘 되어 있으며, @ref{System and foreign language interfaces, , , R-exts, Writing R Extensions}은 컴파일된 코드를 이용하여 @R{}을 어떻게 확장하는지에 대하여 상세히 설명되어 있습니다."

#. type: Plain text
#: R-lang.texi:143
msgid "In every computer language"
msgstr ""

#. type: cindex
#: R-lang.texi:143
#, no-wrap
msgid "variable"
msgstr ""

#. type: Plain text
#: R-lang.texi:147
msgid "variables provide a means of accessing the data stored in memory.  @R{} does not provide direct access to the computer's memory but rather provides a number of specialized data structures we will refer to as"
msgstr "모든 컴퓨터 언어에서 변수(variable)는 메모리에 저장된 데이터에 접근하는 수단을 제공합니다. @R{}은 컴퓨터 메모리에 직접적인 접근을 제공하지 않지만, 대신 여러가지 특수화되어 있는 데이터 구조를 제공하며, 우리는 이들을 객체(object)라고 합니다."

#. type: cindex
#: R-lang.texi:147
#: R-lang.texi:233
#: R-lang.texi:368
#: R-lang.texi:643
#: R-lang.texi:2872
#, no-wrap
msgid "object"
msgstr ""

#. type: Plain text
#: R-lang.texi:153
msgid "objects.  These objects are referred to through symbols or variables.  In @R{}, however, the symbols are themselves objects and can be manipulated in the same way as any other object.  This is different from many other languages and has wide ranging effects."
msgstr "이러한 객체들은 심볼 (symbol) 또는 변수를 통해 참조될 수 있습니다. 그러나, @R{}에서는 심볼은 그 자체로서 객체이기도 하므로 다른 객체들과 동일한 방식으로 조작 할 수 있습니다. 이 점이 다른 컴퓨터 언어와 다른 점이며, R 프로그래밍에 있어 광범위하게 영향을 미칩니다. "

#. type: Plain text
#: R-lang.texi:158
msgid "In this chapter we provide preliminary descriptions of the various data structures provided in @R{}.  More detailed discussions of many of them will be found in the subsequent chapters.  The @R{} specific function @code{typeof}"
msgstr "이번 챕터에서 우리는 @R{}에서 제공되는 다양한 자료구조(data structure)에 대해 간략히 설명합니다.  이들에 대한 많은 부분들을 아래에서 설명되는 챕터들을 통하여 알 수 있을 것입니다. @R{}은 @R{} 객체의 유형(@dfn{type} of @R{} object)을 알려주는 @code{typeof} 이라는 함수를 가지고 있습니다."

#. type: findex
#: R-lang.texi:158
#, no-wrap
msgid "typeof"
msgstr ""

#. type: cindex
#: R-lang.texi:159
#: R-lang.texi:235
#: R-lang.texi:252
#: R-lang.texi:282
#: R-lang.texi:698
#: R-lang.texi:1558
#, no-wrap
msgid "type"
msgstr ""

#. type: Plain text
#: R-lang.texi:165
msgid "returns the @dfn{type} of an @R{} object.  Note that in the C code underlying @R{}, all objects are pointers to a structure with typedef @code{SEXPREC}; the different @R{} data types are represented in C by @code{SEXPTYPE}, which determines how the information in the various parts of the structure is used."
msgstr "R의 밑바탕을 이루고 있는 C 코드에서 모든 객체들은 @code{SEXPREC}이라는 불리는 typedef 자료형으로 된 구조체(structure)를 가리키는 포인터(pointer)들입니다. @R{}의 여러 가지 데이터 형(data types)들은 구조체(structure)의 다양한 부분에 어떻게 정보가 사용되는가를 결정해주는 @code{SEXPTYPE}에 의해서 C코드로 표현됩니다."

#. type: Plain text
#: R-lang.texi:168
msgid "The following table describes the possible values returned by @code{typeof} and what they are."
msgstr "아래의 표에서 @code{typeof} 함수에 의해 반환되는 값들과 그 값들이 무엇인지를 정리하였습니다."

#. type: item
#: R-lang.texi:171
#, no-wrap
msgid "@code{\"NULL\"} @tab NULL"
msgstr ""

#. type: item
#: R-lang.texi:172
#, no-wrap
msgid "@code{\"symbol\"} @tab a variable name"
msgstr "@code{\"symbol\"} @tab 변수명 (a variable name)"

#. type: item
#: R-lang.texi:173
#, no-wrap
msgid "@code{\"pairlist\"}@tab a pairlist object (mainly internal)"
msgstr " @code{\"pairlist\"}@tab 패어리스트 객체 (a pairlist object, 주로 내부용)"

#. type: item
#: R-lang.texi:174
#, no-wrap
msgid "@code{\"closure\"} @tab a function"
msgstr " @code{\"closure\"} @tab 함수 (a function)"

#. type: item
#: R-lang.texi:175
#, no-wrap
msgid "@code{\"environment\"} @tab an environment"
msgstr "@code{\"environment\"} @tab 환경 (an environment)"

#. type: cindex
#: R-lang.texi:176
#: R-lang.texi:3314
#: R-lang.texi:3390
#, no-wrap
msgid "evaluation, lazy"
msgstr ""

#. type: item
#: R-lang.texi:177
#, no-wrap
msgid "@code{\"promise\"}  @tab an object used to implement lazy evaluation"
msgstr "@code{\"promise\"}  @tab 지연 평가를 구현하는데 사용된 객체 (an object used to implement lazy evaluation)"

#. type: item
#: R-lang.texi:178
#, no-wrap
msgid "@code{\"language\"} @tab an @R{} language construct"
msgstr "@code{\"language\"} @tab @R{} 언어구조물 (an @R{} language construct)"

#. type: item
#: R-lang.texi:179
#, no-wrap
msgid "@code{\"special\"}  @tab an internal function that does not evaluate its arguments"
msgstr "@code{\"special\"}  @tab 입력인자를 평가하지 않는 내부 함수 (an internal function that does not evaluate its arguments)"

#. type: item
#: R-lang.texi:180
#, no-wrap
msgid "@code{\"builtin\"} @tab an internal function that evaluates its arguments"
msgstr "@code{\"builtin\"} @tab 입력인자를 평가하는 내부 함수 (an internal function that evaluates its arguments)"

#. type: item
#: R-lang.texi:181
#, no-wrap
msgid "@code{\"char\"} @tab a `scalar' string object (internal only) ***"
msgstr "@code{\"char\"} @tab 스칼라 문자열 객체 (a `scalar' string object, 내부전용)"

#. type: item
#: R-lang.texi:182
#, no-wrap
msgid "@code{\"logical\"} @tab a vector containing logical values"
msgstr "@code{\"logical\"} @tab 논리값을 가지는 벡터 (a vector containing logical values)"

#. type: item
#: R-lang.texi:183
#, no-wrap
msgid "@code{\"integer\"} @tab a vector containing integer values"
msgstr "@code{\"integer\"} @tab 정수값을 가지는 벡터 (a vector containing integer values)"

#. type: item
#: R-lang.texi:184
#, no-wrap
msgid "@code{\"double\"}  @tab a vector containing real values"
msgstr "@code{\"double\"}  @tab 실수값을 가지는 벡터 (a vector containing real values)"

#. type: item
#: R-lang.texi:185
#, no-wrap
msgid "@code{\"complex\"} @tab a vector containing complex values"
msgstr "@code{\"complex\"} @tab 복소수를 가지는 벡터 (a vector containing complex values)"

#. type: item
#: R-lang.texi:186
#, no-wrap
msgid "@code{\"character\"} @tab a vector containing character values"
msgstr " @code{\"character\"} @tab 문자값을 가지는 벡터 (a vector containing character values)"

#. type: item
#: R-lang.texi:187
#, no-wrap
msgid "@code{\"...\"} @tab the special variable length argument ***"
msgstr "@code{\"...\"} @tab 특수 변수 길이 인자 (the special variable length argument) ***  "

#. type: item
#: R-lang.texi:188
#, no-wrap
msgid "@code{\"any\"} @tab a special type that matches all types: there are no objects of this type"
msgstr "@code{\"any\"} @tab 모든 유형에 부합하는 특별한 유형 (a special type that matches all types: there are no objects of this type)"

#. type: item
#: R-lang.texi:189
#, no-wrap
msgid "@code{\"expression\"} @tab an expression object"
msgstr "@code{\"expression\"} @tab 표현식 객체 (an expression object)"

#. type: item
#: R-lang.texi:190
#, no-wrap
msgid "@code{\"list\"} @tab a list"
msgstr " @code{\"list\"} @tab 리스트 (a list)"

#. type: item
#: R-lang.texi:191
#, no-wrap
msgid "@code{\"bytecode\"} @tab byte code (internal only) ***"
msgstr "@code{\"bytecode\"} @tab 바이트 코드 (byte code, 내부 전용) ***"

#. type: item
#: R-lang.texi:192
#, no-wrap
msgid "@code{\"externalptr\"} @tab an external pointer object"
msgstr "@code{\"externalptr\"} @tab 외부 포인터 객체 (an external pointer object)"

#. type: item
#: R-lang.texi:193
#, no-wrap
msgid "@code{\"weakref\"} @tab a weak reference object"
msgstr "@code{\"weakref\"} @tab 약한 참조 객체 (a weak reference object)"

#. type: item
#: R-lang.texi:194
#, no-wrap
msgid "@code{\"raw\"} @tab a vector containing bytes"
msgstr "@code{\"raw\"} @tab 바이트를 포함하는 벡터 (a vector containing bytes)"

#. type: item
#: R-lang.texi:195
#, no-wrap
msgid "@code{\"S4\"} @tab an S4 object which is not a simple object"
msgstr "@code{\"S4\"} @tab 단순 객체가 아닌 S4 객체 (an S4 object which is not a simple object)"

#. type: Plain text
#: R-lang.texi:201
msgid "Users cannot easily get hold of objects of types marked with a `***'."
msgstr "사용자는 `***'로 표시된 유형의 객체들을 쉽게 찾을 수 없습니다."

#. type: cindex
#: R-lang.texi:203
#: R-lang.texi:204
#: R-lang.texi:283
#: R-lang.texi:292
#: R-lang.texi:376
#, no-wrap
msgid "mode"
msgstr ""

#. type: Plain text
#: R-lang.texi:213
msgid "Function @code{mode} gives information about the @dfn{mode} of an object in the sense of Becker, Chambers & Wilks (1988), and is more compatible with other implementations of the @Sl{} language."
msgstr "함수 @code{mode}는 Becker, Chambers & Wilks (1988)에서 설명된 객체의 모드(@dfn{mode})에 대한 정보를 알려줍니다. 그리고 이는 @Sl{} 언어를 이용하여 구현된 것들과 더 잘 호환됩니다. "

#. type: multitable
#: R-lang.texi:213
#: R-lang.texi:292
#, no-wrap
msgid "storage.mode"
msgstr ""

#. type: Plain text
#: R-lang.texi:221
msgid "Finally, the function @code{storage.mode} returns the @dfn{storage mode} of its argument in the sense of Becker et al.@: (1988).  It is generally used when calling functions written in another language, such as C or FORTRAN, to ensure that @R{} objects have the data type expected by the routine being called.  (In the @Sl{} language, vectors with integer or real values are both of mode @code{\"numeric\"}, so their storage modes need to be distinguished.)"
msgstr "마지막으로, 함수 @code{storage.mode}는 Becker et al.@: (1988)에서 설명된 입력인자의 저장모드(@dfn{storage mode})를 알려줍니다. 이 함수는 보통 C 또는 FORTRAN 과 같은 다른 언어로 작성된 함수를 호출할때 @R{} 객체들이 호출되어진 루틴에 의하여 입력되어지기를 기대되는 자료형(data type)을 가지고 있는지 확인하기 위하여 사용됩니다. (@Sl{} 언어에서는 정수 또는 실수를 가지는 벡터는 모두 @code{\"numeric\"} 모드를 가지기 때문에 저장모드가 구분될 필요가 있습니다)."

#. type: example
#: R-lang.texi:230
#, no-wrap
msgid ""
"> x <- 1:3\n"
"> typeof(x)\n"
"[1] \"integer\"\n"
"> mode(x)\n"
"[1] \"numeric\"\n"
"> storage.mode(x)\n"
"[1] \"integer\"\n"
msgstr ""

#. type: Plain text
#: R-lang.texi:233
msgid "@R{}"
msgstr ""

#. type: Plain text
#: R-lang.texi:235
msgid "objects are often coerced to different"
msgstr "@R{}객체들은 연산이 수행되는 도중에 종종 다른 유형(type)으로 강제변환(coercion)이 이루어지기도 합니다."

#. type: Plain text
#: R-lang.texi:238
msgid "types during computations.  There are also many functions available to perform explicit"
msgstr "또한, 명시적으로 강제변환을 수행하는 많은 함수들이 있습니다."

#. type: cindex
#: R-lang.texi:238
#: R-lang.texi:379
#: R-lang.texi:633
#: R-lang.texi:745
#: R-lang.texi:1582
#, no-wrap
msgid "coercion"
msgstr ""

#. type: Plain text
#: R-lang.texi:244
msgid "coercion.  When programming in the @R{} language the type of an object generally doesn't affect the computations, however, when dealing with foreign languages or the operating system it is often necessary to ensure that an object is of the correct type."
msgstr "@R{}을 이용한 프로그래밍에서 객체의 유형 (또는 종류)는 일반적으로 연산(의 결과)에 영향을 미치지 않습니다. 그러나, 외부언어(foreign languages) 또는 운영체제를 함께 다룰 때에는 종종 객체가 올바른 유형을 가지고 있는지 확인하는 것이 필요합니다."

#. type: node
#: R-lang.texi:249
#: R-lang.texi:251
#: R-lang.texi:253
#: R-lang.texi:271
#: R-lang.texi:310
#: R-lang.texi:325
#: R-lang.texi:388
#: R-lang.texi:411
#: R-lang.texi:471
#: R-lang.texi:485
#: R-lang.texi:505
#: R-lang.texi:536
#: R-lang.texi:558
#: R-lang.texi:597
#: R-lang.texi:627
#: R-lang.texi:639
#, no-wrap
msgid "Basic types"
msgstr ""

#. type: node
#: R-lang.texi:249
#: R-lang.texi:251
#: R-lang.texi:639
#: R-lang.texi:640
#: R-lang.texi:685
#: R-lang.texi:708
#: R-lang.texi:723
#: R-lang.texi:731
#: R-lang.texi:748
#: R-lang.texi:755
#: R-lang.texi:782
#, no-wrap
msgid "Attributes"
msgstr ""

#. type: node
#: R-lang.texi:249
#: R-lang.texi:639
#: R-lang.texi:782
#: R-lang.texi:783
#: R-lang.texi:790
#: R-lang.texi:813
#, no-wrap
msgid "Special compound objects"
msgstr ""

#. type: node
#: R-lang.texi:269
#: R-lang.texi:271
#: R-lang.texi:310
#, no-wrap
msgid "Vector objects"
msgstr ""

#. type: node
#: R-lang.texi:269
#: R-lang.texi:271
#: R-lang.texi:310
#: R-lang.texi:325
#, no-wrap
msgid "List objects"
msgstr ""

#. type: node
#: R-lang.texi:269
#: R-lang.texi:310
#: R-lang.texi:325
#: R-lang.texi:326
#: R-lang.texi:362
#: R-lang.texi:388
#, no-wrap
msgid "Language objects"
msgstr ""

#. type: node
#: R-lang.texi:269
#: R-lang.texi:325
#: R-lang.texi:388
#: R-lang.texi:389
#: R-lang.texi:411
#, no-wrap
msgid "Expression objects"
msgstr ""

#. type: node
#: R-lang.texi:269
#: R-lang.texi:388
#: R-lang.texi:411
#: R-lang.texi:412
#: R-lang.texi:471
#, no-wrap
msgid "Function objects"
msgstr ""

#. type: node
#: R-lang.texi:269
#: R-lang.texi:411
#: R-lang.texi:471
#: R-lang.texi:485
#, no-wrap
msgid "NULL object"
msgstr ""

#. type: node
#: R-lang.texi:269
#: R-lang.texi:471
#: R-lang.texi:485
#: R-lang.texi:505
#, no-wrap
msgid "Builtin objects and special forms"
msgstr ""

#. type: node
#: R-lang.texi:269
#: R-lang.texi:485
#: R-lang.texi:505
#: R-lang.texi:506
#: R-lang.texi:536
#, no-wrap
msgid "Promise objects"
msgstr ""

#. type: node
#: R-lang.texi:269
#: R-lang.texi:505
#: R-lang.texi:536
#: R-lang.texi:537
#: R-lang.texi:558
#, no-wrap
msgid "Dot-dot-dot"
msgstr ""

#. type: node
#: R-lang.texi:269
#: R-lang.texi:536
#: R-lang.texi:558
#: R-lang.texi:597
#, no-wrap
msgid "Environment objects"
msgstr ""

#. type: node
#: R-lang.texi:269
#: R-lang.texi:558
#: R-lang.texi:597
#: R-lang.texi:598
#: R-lang.texi:627
#, no-wrap
msgid "Pairlist objects"
msgstr ""

#. type: node
#: R-lang.texi:269
#: R-lang.texi:597
#: R-lang.texi:627
#, no-wrap
msgid "Any-type"
msgstr ""

#. type: subsection
#: R-lang.texi:272
#, no-wrap
msgid "Vectors"
msgstr ""

#. type: cindex
#: R-lang.texi:274
#: R-lang.texi:718
#: R-lang.texi:1183
#, no-wrap
msgid "vector"
msgstr ""

#. type: Plain text
#: R-lang.texi:277
msgid "Vectors can be thought of as contiguous cells containing data.  Cells are accessed through"
msgstr "벡터들은 데이터를 포함하고 있는 인접한 셀들과 같이 생각될 수 있습니다.셀들은 @code{x[5]}와 같이 인덱싱 조작(indexing operation)을 통하여 접근 되어집니다. "

#. type: cindex
#: R-lang.texi:277
#: R-lang.texi:317
#: R-lang.texi:1630
#: R-lang.texi:1673
#: R-lang.texi:1756
#: R-lang.texi:1798
#, no-wrap
msgid "index"
msgstr ""

#. type: Plain text
#: R-lang.texi:281
msgid "indexing operations such as @code{x[5]}.  More details are given in @ref{Indexing}."
msgstr "더 자세한 사항은 @ref{Indexing}에 설명되어 있습니다."

#. type: cindex
#: R-lang.texi:284
#, no-wrap
msgid "atomic"
msgstr ""

#. type: Plain text
#: R-lang.texi:288
msgid "@R{} has six basic (`atomic') vector types: logical, integer, real, complex, string (or character) and raw.  The modes and storage modes for the different vector types are listed in the following table."
msgstr "@R{}은 여섯 가지의 기본 (`atomic', 아토믹) 벡터를 가지고 있습니다. 이들은 논리형(logical), 정수형(integer), 실수형(real), 복소수형(complex), 문자열 (string) 또는 문자 (character), 그리고 원형(raw)입니다. 다음의 표는 유형이 다른 벡터들의 모드와 저장모드들을 정리하였습니다."

#. type: multitable
#: R-lang.texi:292
msgid "@headitem typeof"
msgstr ""

#. type: item
#: R-lang.texi:292
#, no-wrap
msgid "@code{logical}   @tab @code{logical}   @tab @code{logical}"
msgstr ""

#. type: item
#: R-lang.texi:293
#, no-wrap
msgid "@code{integer}   @tab @code{numeric}   @tab @code{integer}"
msgstr ""

#. type: item
#: R-lang.texi:294
#, no-wrap
msgid "@code{double}    @tab @code{numeric}   @tab @code{double}"
msgstr ""

#. type: item
#: R-lang.texi:295
#, no-wrap
msgid "@code{complex}   @tab @code{complex}   @tab @code{complex}"
msgstr ""

#. type: item
#: R-lang.texi:296
#, no-wrap
msgid "@code{character} @tab @code{character} @tab @code{character}"
msgstr ""

#. type: item
#: R-lang.texi:297
#, no-wrap
msgid "@code{raw}       @tab @code{raw}       @tab @code{raw}"
msgstr ""

#. type: Plain text
#: R-lang.texi:304
msgid "Single numbers, such as @code{4.2}, and strings, such as @code{\"four point two\"} are still vectors, of length 1; there are no more basic types.  Vectors with length zero are possible (and useful)."
msgstr "@code{4.2}와 같은 하나의 숫자와 @code{\"four point two\"}와 같은 문자열도 길이가 1인 벡터입니다. 이외의 다른 기본유형은 없습니다.  길이가 0인 벡터 또한 가능하며 (유용합니다)."

#. type: Plain text
#: R-lang.texi:308
msgid "String vectors have mode and storage mode @code{\"character\"}. A single element of a character vector is often referred to as a @emph{character string}."
msgstr "문자열 벡터들은 둘 다 @code{\"character\"} (문자형) 모드와 저장모드를 가집니다. 문자형 벡터의 구성요소 하나를 종종 @emph{character string}(문자형 문자열)라고도 합니다."

#. type: subsection
#: R-lang.texi:311
#, no-wrap
msgid "Lists"
msgstr ""

#. type: Plain text
#: R-lang.texi:317
msgid "Lists (``generic vectors'') are another kind of data storage.  Lists have elements, each of which can contain any type of @R{} object, i.e.@: the elements of a list do not have to be of the same type.  List elements are accessed through three different"
msgstr "리스트 (``generic vectors'')는 데이터 저장(data storage)의 또 다른 종류입니다. 리스트들의 구성요소는 어떠한 유형의 @R{} 객체들이 될 수 있습니다. 즉, 리스트의 구성요소들은 같은 유형일 필요가 없습니다.리스트의 구성요소들은 세가지 다른 인덱싱 조작(indexing operation)에 의하여 접근되어 집니다."

#. type: Plain text
#: R-lang.texi:321
msgid "indexing operations.  These are explained in detail in @ref{Indexing}."
msgstr "자세한 사항은 @ref{Indexing}에 설명되어 있습니다"

#. type: Plain text
#: R-lang.texi:324
msgid "Lists are vectors, and the basic vector types are referred to as @emph{atomic vectors} where it is necessary to exclude lists."
msgstr "리스트도 벡터의 종류이긴 하지만, 리스트 유형을 제외한 기본 벡터의 종류들을 @emph{atomic vectors}(벡터를 구성하는데 있어 더 이상 하위단계로 분류할 수 최소의 기본구성단위 요소만으로 된 벡터 -- 아토믹 벡터)라고 합니다. "

#. type: Plain text
#: R-lang.texi:330
msgid "There are three types of objects that constitute the @R{} language.  They are @emph{calls}, @emph{expressions}, and @emph{names}."
msgstr "@R{} 언어는 세가지의 객체들로 구성되어 있습니다. 이들은 @emph{calls}, @emph{expressions}, 그리고 @emph{names}입니다."

#. type: cindex
#: R-lang.texi:330
#, no-wrap
msgid "call"
msgstr ""

#. type: cindex
#: R-lang.texi:332
#: R-lang.texi:370
#: R-lang.texi:988
#: R-lang.texi:1535
#: R-lang.texi:2034
#: R-lang.texi:2275
#: R-lang.texi:2347
#: R-lang.texi:2399
#: R-lang.texi:2858
#: R-lang.texi:3009
#: R-lang.texi:3231
#: R-lang.texi:4031
#, no-wrap
msgid "name"
msgstr ""

#. type: Plain text
#: R-lang.texi:341
msgid "Since @R{} has objects of type @code{\"expression\"} we will try to avoid the use of the word expression in other contexts.  In particular syntactically correct expressions will be referred to as @emph{statements}."
msgstr "@R{}은 @code{\"expression\"}이라는 유형의 객체들을 가지고 있기 때문에 우리는 expression이라는 단어를 다른 의미로 사용하지 않으려고 노력할 것입니다. 특히 구문상으로 올바른 expression을 @emph{statements}라고 지칭할 것입니다."

#. type: cindex
#: R-lang.texi:341
#, no-wrap
msgid "statement"
msgstr ""

#. type: Plain text
#: R-lang.texi:346
msgid "These objects have modes @code{\"call\"}, @code{\"expression\"}, and @code{\"name\"}, respectively."
msgstr "이러한 객체들은 @code{\"call\"}, @code{\"expression\"}, 그리고 @code{\"name\"}라는 모드를 가지고 있습니다."

#. type: Plain text
#: R-lang.texi:350
msgid "They can be created directly from expressions using the @code{quote} mechanism and converted to and from lists by the @code{as.list} and @code{as.call} functions."
msgstr "이들은 @code{quote} 매커니즘 (즉, 따옴표와 함께 사용하여)을 이용하여 expressions 로부터 바로 생성되고, @code{as.list}와 @code{as.call} 함수들에 의하여 리스트에서 리스트로 서로 전환될 수 있습니다."

#. type: findex
#: R-lang.texi:350
#, no-wrap
msgid "quote"
msgstr ""

#. type: findex
#: R-lang.texi:351
#, no-wrap
msgid "as.list"
msgstr ""

#. type: findex
#: R-lang.texi:352
#, no-wrap
msgid "as.call"
msgstr ""

#. type: Plain text
#: R-lang.texi:354
msgid "Components of the"
msgstr ""

#. type: cindex
#: R-lang.texi:354
#: R-lang.texi:384
#: R-lang.texi:912
#: R-lang.texi:3140
#: R-lang.texi:3259
#: R-lang.texi:3371
#: R-lang.texi:4154
#: R-lang.texi:4220
#, no-wrap
msgid "parsing"
msgstr ""

#. type: Plain text
#: R-lang.texi:357
msgid "parse tree can be extracted using the standard indexing operations."
msgstr "구문트리(parse tree)의 구성요소(component)들은 표준 인덱싱 조작(standard indexing operations)을 이용하여 얻어질 수 있습니다. "

#. type: subsubsection
#: R-lang.texi:360
#: R-lang.texi:362
#: R-lang.texi:363
#, no-wrap
msgid "Symbol objects"
msgstr ""

#. type: cindex
#: R-lang.texi:366
#: R-lang.texi:375
#: R-lang.texi:990
#: R-lang.texi:2492
#: R-lang.texi:3369
#: R-lang.texi:3688
#, no-wrap
msgid "symbol"
msgstr ""

#. type: Plain text
#: R-lang.texi:368
msgid "Symbols refer to @R{}"
msgstr ""

#. type: Plain text
#: R-lang.texi:370
msgid "objects.  The"
msgstr ""

#. type: Plain text
#: R-lang.texi:374
msgid "name of any @R{} object is usually a symbol.  Symbols can be created through the functions @code{as.name} and @code{quote}."
msgstr "심볼 (symbols)들은 @R{} 객체들을 지칭합니다. 모든 @R{} 객체의 이름은 일반적으로 심볼입니다. 심볼들은 함수 @code{as.name}과 @code{quote}을 통하여 생성되어질 수 있습니다."

#. type: Plain text
#: R-lang.texi:379
msgid "Symbols have mode @code{\"name\"}, storage mode @code{\"symbol\"}, and type @code{\"symbol\"}.  They can be"
msgstr "심볼들은 @code{\"name\"}이라는 모드, @code{\"symbol\"}이라는 저장모드, 그리고 @code{\"symbol\"}이라는 유형을 가지게 됩니다."

#. type: Plain text
#: R-lang.texi:382
msgid "coerced to and from character strings using @code{as.character} and @code{as.name}."
msgstr "이들은 @code{as.character}와 @code{as.name}을 이용하여 문자열로 강제변환될 수 있습니다."

#. type: findex
#: R-lang.texi:382
#, no-wrap
msgid "as.character"
msgstr ""

#. type: findex
#: R-lang.texi:383
#, no-wrap
msgid "as.name"
msgstr ""

#. type: Plain text
#: R-lang.texi:387
msgid "They naturally appear as atoms of parsed expressions, try e.g.@: @code{as.list(quote(x + y))}."
msgstr "이들은 구문분석된 표현의 기본단위(atoms of parsed expressions)으로 나타나게 됩니다. 예를들어 보기 위하여, @code{as.list(quote(x+y))}를 입력해 보시길 바랍니다."

#. type: Plain text
#: R-lang.texi:394
msgid "In @R{} one can have objects of type @code{\"expression\"}.  An @emph{expression} contains one or more statements.  A statement is a syntactically correct collection of"
msgstr "@R{}에서는 @code{\"expression\"}이라는 객체의 유형을 가질 수 있습니다. @emph{expression}은 한 개 또는 그 이상의 statement를 포함합니다. statement는 구문상 올바른 토큰(token)들의 모음(collection)입니다."

#. type: cindex
#: R-lang.texi:394
#, no-wrap
msgid "token"
msgstr ""

#. type: Plain text
#: R-lang.texi:396
msgid "tokens."
msgstr ""

#. type: cindex
#: R-lang.texi:396
#: R-lang.texi:407
#, no-wrap
msgid "expression object"
msgstr ""

#. type: Plain text
#: R-lang.texi:401
msgid "Expression objects are special language objects which contain parsed but unevaluated @R{} statements.  The main difference is that an expression object can contain several such expressions.  Another more subtle difference is that objects of type @code{\"expression\"} are only"
msgstr "다른 점은 expression 객체들은 여러개의 그런 expression들을 포함할 수 있다는 것입니다. 또 다른 미묘한 차이점은 @code{\"expression\"} 유형의 객체들은 오로지 @code{eval}에 명시적으로 넘겨졌을 때에만 평가되어지는 "

#. type: cindex
#: R-lang.texi:401
#: R-lang.texi:522
#: R-lang.texi:2269
#, no-wrap
msgid "evaluation, expression"
msgstr ""

#. type: Plain text
#: R-lang.texi:405
msgid "evaluated when explicitly passed to @code{eval}, whereas other language objects may get evaluated in some unexpected cases."
msgstr "반면, 다른 랭귀지 객체들은 일부 예상하지 못한 경우에도 평가될 수도 있습니다. "

#. type: Plain text
#: R-lang.texi:407
#: R-lang.texi:2231
msgid "An"
msgstr ""

#. type: Plain text
#: R-lang.texi:410
msgid "expression object behaves much like a list and its components should be accessed in the same way as the components of a list."
msgstr "expression 객체는 리스트(list)와 매우 흡사하게 작동하며, 이들의 구성요소들은 리스의 구성요소에 접근하는 방법으로 접근되어집니다. "

#. type: cindex
#: R-lang.texi:414
#: R-lang.texi:437
#: R-lang.texi:464
#: R-lang.texi:489
#: R-lang.texi:502
#: R-lang.texi:513
#: R-lang.texi:552
#: R-lang.texi:1064
#: R-lang.texi:2067
#: R-lang.texi:2093
#: R-lang.texi:2109
#: R-lang.texi:2200
#: R-lang.texi:2219
#: R-lang.texi:2242
#: R-lang.texi:2286
#: R-lang.texi:2313
#: R-lang.texi:2339
#: R-lang.texi:2389
#: R-lang.texi:2426
#: R-lang.texi:2443
#: R-lang.texi:2463
#: R-lang.texi:2507
#: R-lang.texi:2532
#: R-lang.texi:2552
#: R-lang.texi:2616
#: R-lang.texi:2737
#: R-lang.texi:3559
#: R-lang.texi:3719
#: R-lang.texi:3746
#: R-lang.texi:4225
#: R-lang.texi:4572
#: R-lang.texi:4757
#, no-wrap
msgid "function"
msgstr ""

#. type: Plain text
#: R-lang.texi:419
msgid "In @R{} functions are objects and can be manipulated in much the same way as any other object.  Functions (or more precisely, function closures) have three basic components: a formal argument list, a body and an"
msgstr "@R{}에서 함수(function)은 객체(object)이며, 다른 종류의 객체들과 꽤 많이 비슷한 방법으로 다루어질 수 있습니다.  함수 (또는 보다 정교하게 말하면 펀션 클로우져 -- function closure)는 세가지 구성요소를 가지고 있습니다. 이들은 형식인자 목록(formal argument list), 본체(body), 그리고 인바이런먼트 (enviroment)입니다."

#. type: cindex
#: R-lang.texi:419
#: R-lang.texi:438
#: R-lang.texi:454
#: R-lang.texi:511
#: R-lang.texi:561
#: R-lang.texi:2055
#: R-lang.texi:2070
#: R-lang.texi:2122
#: R-lang.texi:2163
#: R-lang.texi:2321
#: R-lang.texi:2418
#: R-lang.texi:2450
#: R-lang.texi:2524
#: R-lang.texi:2893
#: R-lang.texi:2912
#: R-lang.texi:3448
#: R-lang.texi:3730
#: R-lang.texi:3731
#: R-lang.texi:3786
#: R-lang.texi:4007
#: R-lang.texi:4036
#, no-wrap
msgid "environment"
msgstr ""

#. type: Plain text
#: R-lang.texi:422
msgid "environment.  The argument list is a comma-separated list of arguments.  An"
msgstr "인자 목록은 컴마로 분리된 입력인자들의 목록입니다."

#. type: cindex
#: R-lang.texi:422
#: R-lang.texi:2231
#, no-wrap
msgid "argument"
msgstr ""

#. type: Plain text
#: R-lang.texi:431
msgid "argument can be a symbol, or a @samp{@var{symbol} = @var{default}} construct, or the special argument @samp{...}.  The second form of argument is used to specify a default value for an argument.  This value will be used if the function is called without any value specified for that argument.  The @samp{...} argument is special and can contain any number of arguments.  It is generally used if the number of arguments is unknown or in cases where the arguments will be passed on to another function."
msgstr "인자는 심볼(symbol) 또는 @samp{@var{symbol} = @var{default}}라는 구성체(construct), 또는 @samp{...}이라는 특수인자가 될 수 있습니다.  여기에서 두번째에 사용된 형식은 인자에 기본값을 부여하는데 사용됩니다.  만약 이 값은 인자에 어떠한 값도 지정되지 않은 상태로 함수가 호출되었을때 사용될 것입니다.  @samp{...} 인자는 특별하며, 입력받는 인자의 개수에 제한을 받지 않습니다. 이는 주로 인자의 개수를 정확히 모를 때 사용하거나, 다른 함수에 전달될 함수의 인자들이 존재할 경우에 사용됩니다. "

#. type: Plain text
#: R-lang.texi:435
msgid "The body is a parsed @R{} statement.  It is usually a collection of statements in braces but it can be a single statement, a symbol or even a constant."
msgstr "함수의 본체(body)는 구문이 분석된 @R{} 문장 (parsed R statement)입니다. 이는 일반적으로 중괄호(brace)안에 놓인 문장들의 집합체이지만, 한개의 문장, 한개의 심볼 또는 심지어 한 개의 상수(constant) 일 수도 있습니다."

#. type: Plain text
#: R-lang.texi:437
msgid "A function's"
msgstr ""

#. type: Plain text
#: R-lang.texi:446
msgid "environment is the environment that was active at the time that the function was created.  Any symbols bound in that environment are @emph{captured} and available to the function. This combination of the code of the function and the bindings in its environment is called a `function closure', a term from functional programming theory. In this document we generally use the term `function', but use `closure' to emphasize the importance of the attached environment."
msgstr "함수의 인바이런먼트(environment)는 함수가 생성되었을 당시 그 시점에 활성화 되어 있는 장소(environment)를 의미합니다. 해당 인바이런트와 함께 묶여 있는 모든 심볼들을 파일화 (@emph{captured})하게 되어 함수에서 사용할 수 있습니다. 함수의 코드와 인바이런먼트 내의 바인딩의 이러한 조합을 펀션 클로우져(`function closure')라고 합니다. 이 용어는 `functional programming theory'로 부터 나온것입니다.  이 문서내에서 우리는 일반적으로 `함수'(function)라고 사용할 것이지만, 함께 부착된 인바이런먼트 (attached environment)의 중요성을 강조하고자 할 때에는 `클로져'(closure)를 사용할 것입니다. "

#. type: Plain text
#: R-lang.texi:450
msgid "It is possible to extract and manipulate the three parts of a closure object using @code{formals}, @code{body}, and @code{environment} constructs (all three can also be used on the left hand side of"
msgstr "@code{formals}(형식인자들), @code{body}(본체), @code{environment}(인바이런먼트)라는 구성체(construct)들을 이용하여 클로져 객체(closure object)의 세부분을 추출하고 조작을 할 수 있습니다 (세가지 모든 것은 할당문의 좌변에 사용될 수 있습니다)."

#. type: cindex
#: R-lang.texi:450
#: R-lang.texi:1077
#: R-lang.texi:1218
#: R-lang.texi:1859
#: R-lang.texi:2057
#: R-lang.texi:2413
#: R-lang.texi:2518
#: R-lang.texi:2915
#: R-lang.texi:2944
#: R-lang.texi:3483
#: R-lang.texi:3613
#: R-lang.texi:4633
#: R-lang.texi:4662
#, no-wrap
msgid "assignment"
msgstr ""

#. type: Plain text
#: R-lang.texi:452
msgid "assignments)."
msgstr ""

#. type: item
#: R-lang.texi:452
#: R-lang.texi:3727
#, no-wrap
msgid "formals"
msgstr ""

#. type: item
#: R-lang.texi:453
#: R-lang.texi:3725
#, no-wrap
msgid "body"
msgstr ""

#. type: Plain text
#: R-lang.texi:456
msgid "The last of these can be used to remove unwanted environment capture."
msgstr "이것들중의 마지막 구성체는 원하지 않았던 인바이런먼트가 파일하였던 것을 제거하는데 사용할 수 있습니다. "

#. type: Plain text
#: R-lang.texi:463
msgid "When a function is called, a new environment (called the @emph{evaluation environment}) is created, whose enclosure (see @ref{Environment objects}) is the environment from the function closure.  This new environment is initially populated with the unevaluated arguments to the function; as evaluation proceeds, local variables are created within it."
msgstr "함수가 호출되었을대, @emph{evaluation environment}(이밸류에이션 인바이런먼트)라고 불리는 새로운 인바이런먼트가 생성됩니다.  이 인바이런먼트의 인클로져(enclosure)는 함수의 클로져(function closure)로부터 나온 인바이런먼트입니다 (@ref{Environment objects}를 살펴보시길 바랍니다). 처음에 이 새로운 인바이런먼트는 평가가 아직 되지 않은 함수의 인자들로 이루어져 있습니다. 그러나, 평가(evaluation)이 진행됨에 따라서, 지역변수(local variables)들이 이 인바이런먼트내에서 생성되게 됩니다. "

#. type: Plain text
#: R-lang.texi:467
msgid "There is also a facility for converting functions to and from list structures using @code{as.list} and @code{as.function}."
msgstr "@code{as.list}와  @code{as.function}을 이용하여 함수와 리스트 구조체가 서로 전환할 수 있는 기능이 있습니다. "

#. type: findex
#: R-lang.texi:467
#, no-wrap
msgid "as.function"
msgstr ""

#. type: Plain text
#: R-lang.texi:470
msgid "These have been included to provide compatibility with @Sl{} and their use is discouraged."
msgstr "이러한 것들은 @Sl{}와의 호환성을 제공하나, 이들의 사용은 추천되지 않습니다."

#. type: findex
#: R-lang.texi:472
#: R-lang.texi:477
#, no-wrap
msgid "NULL"
msgstr ""

#. type: Plain text
#: R-lang.texi:477
msgid "There is a special object called @code{NULL}.  It is used whenever there is a need to indicate or specify that an object is absent.  It should not be confused with a vector or list of zero length."
msgstr "NULL이라고 불리우는 특별한 객체가 있습니다.이것은 객체의 부재를 나타내거나 명시해야할 필요가 있을 때 사용되게 됩니다. 그러나, 이것은 길이가 0인 벡터 또는 리스트와 혼돈해서는 안됩니다. "

#. type: Plain text
#: R-lang.texi:483
msgid "The @code{NULL} object has no type and no modifiable properties.  There is only one @code{NULL} object in @R{}, to which all instances refer. To test for @code{NULL} use @code{is.null}.  You cannot set attributes on @code{NULL}."
msgstr "@code{NULL} 객체는 이를 나타내는 유형(type)이 없으면 수정할 수 있는 속성들을 가지고 있지 않습니다. @R{}에서는 이러한 객체들을 나타내는데 있어 오로지 하나의 @code{NULL} 객체가 있을 뿐입니다. 객체가 @code{NULL}인지 확인하기 위해서는 @code{is.null}을 이용하세요. @code{NULL} 객체에 속성(attributes)를 부여할 수 없습니다."

#. type: subsection
#: R-lang.texi:486
#, no-wrap
msgid "Builtin objects and  special forms"
msgstr "내장객체들과 특수한 형식들"

#. type: Plain text
#: R-lang.texi:489
msgid "These two kinds of object contain the builtin"
msgstr ""

#. type: findex
#: R-lang.texi:490
#: R-lang.texi:3874
#, no-wrap
msgid ".Primitive"
msgstr ""

#. type: findex
#: R-lang.texi:491
#: R-lang.texi:3873
#, no-wrap
msgid ".Internal"
msgstr ""

#. type: Plain text
#: R-lang.texi:499
msgid "functions of @R{}, i.e., those that are displayed as @code{.Primitive} in code listings (as well as those accessed via the @code{.Internal} function and hence not user-visible as objects).  The difference between the two lies in the argument handling.  Builtin functions have all their arguments evaluated and passed to the internal function, in accordance with @emph{call-by-value}, whereas special functions pass the unevaluated arguments to the internal function."
msgstr "이러한 두 종류의 객체는 @R{}의 내장함수(builtin function)를 가지고 있습니다.즉, 코드가 보여질 때 (code listings) @code{.Primitive}와 같이 보여지는 것들을 말합니다. (또한 @code{.Internal} 함수를 통하여 접근되어지는 것들을 말하는데, 이 객체들은 사용자가 볼 수 없습니다).이 두가지 종류의 객체 사이에는 인자처리(argumnet handling)방법이 다릅니다.내장함수들은 @emph{call-by-value}에 따라서 인자들이 평가되어 내부 함수(internal function)로 전달되는 반면에 특수함수(special function)들은 평가되지 않은 인자들을 내부함수로 전달합니다."

#. type: Plain text
#: R-lang.texi:502
msgid "From the @R{} language, these objects are just another kind of function.  The @code{is.primitive} function can distinguish them from interpreted"
msgstr "@R{} 언어에서는 이러한 객체들은 단지 또다른 종류의 함수일뿐입니다. @code{is.primitive} 함수는 인터프리티드된 함수들로부터 이들을 구별해 낼 수 있습니다."

#. type: Plain text
#: R-lang.texi:504
msgid "functions."
msgstr ""

#. type: cindex
#: R-lang.texi:508
#, no-wrap
msgid "promise"
msgstr ""

#. type: Plain text
#: R-lang.texi:511
msgid "Promise objects are part of @R{}'s lazy evaluation mechanism.  They contain three slots: a value, an expression, and an"
msgstr "프라미스 객체들(promise objects)는 @R{}의 지연연산방법(lazy evaluation mechanism)의 부분입니다.이들은 세 부분으로 되어 있습니다: 값(value), 표현식(expression), 그리고 환경 (environment)입니다."

#. type: Plain text
#: R-lang.texi:513
msgid "environment.  When a"
msgstr ""

#. type: cindex
#: R-lang.texi:514
#: R-lang.texi:553
#, no-wrap
msgid "function argument"
msgstr ""

#. type: Plain text
#: R-lang.texi:519
msgid "function is called the arguments are matched and then each of the formal arguments is bound to a promise.  The expression that was given for that formal argument and a pointer to the environment the function was called from are stored in the promise."
msgstr "함수가 호출될때 인자들은 짝지어진 후, 각각의 형식인자들은 프라미스(promise)와 결합하게 됩니다. 형식인자들을 위해 주어진 표현식과 함수를 호출되어진 환경(environment)에 대한 포인터들은 프라미스에 저장됩니다."

#. type: Plain text
#: R-lang.texi:522
msgid "Until that argument is accessed there is no @emph{value} associated with the promise.  When the argument is accessed, the stored expression is"
msgstr "해당 인자에 접근되어질 때 까지, 프라미스(promise)와 연관된 값은 존재하지 않습니다."

#. type: Plain text
#: R-lang.texi:528
msgid "evaluated in the stored environment, and the result is returned.  The result is also saved by the promise.  The @code{substitute} function will extract the content of the expression slot.  This allows the programmer to access either the value or the expression associated with the promise."
msgstr "인자가 접근되어질 때, 저장된 표현(expression)이 저장된 환경(environment)내에서 평가되어지고, 그 결과가 반환됩니다. 이 결과는 또한 프라미스에 의하여 저장되어집니다. @code{substitute} 함수는 익스프레이션 슬롯 (expression slot)의 내용을 뽑아낼 것입니다. 이것은 프로그래머가 프라미스와 연관된 표현 또는 값에 접근하도록 해주는 것입니다."

#. type: Plain text
#: R-lang.texi:535
msgid "Within the @R{} language, promise objects are almost only seen implicitly: actual function arguments are of this type.  There is also a @code{delayedAssign} function that will make a promise out of an expression.  There is generally no way in @R{} code to check whether an object is a promise or not, nor is there a way to use @R{} code to determine the environment of a promise."
msgstr "@R{} 언어에서는 프라미스 객체들은 거의 직접적으로 보여지지 않지만 실제적인 함수의 인자들은 이러한 종류에 해당합니다. 또한, 프라미스를 익스프레이션(expression) 밖으로 꺼내주는 @code{delayedAssign} 함수가 있습니다. @R{} 코드내에서 객체가 프라미스인지 아닌지를 확인하는 방법이 없으며, 또한 프라미스의 환경을 정하기 위하여 @R{} 코드를 사용하는 방법 또한 없습니다. "

#. type: Plain text
#: R-lang.texi:544
msgid "The @samp{...} object type is stored as a type of pairlist.  The components of @samp{...} can be accessed in the usual pairlist manner from C code, but is not easily accessed as an object in interpreted code.  The object can be captured as a list, so for example in @code{table} one sees"
msgstr "@samp{...} 객체유형은 패어리스트(pairlist)라는 유형으로 저장됩니다. @samp{...}의 구성요소들은 C 코드에서의 일반적인 패어리스트 방법으로 접근할 수 있습니다. 그러나, 인터프리티드된 코드내에 있는 객체처럼 쉽게 접근되지는 않습니다. 아래의 예제에서 보이는 것과 같이 객체는 리스트로서로 캡쳐할 수 있습니다."

#. type: example
#: R-lang.texi:550
#, no-wrap
msgid ""
"    args <- list(...)\n"
"## ....\n"
"    for (a in args) @{\n"
"## ....\n"
msgstr ""

#. type: Plain text
#: R-lang.texi:557
msgid "If a function has @samp{...} as a formal argument then any actual arguments that do not match a formal argument are matched with @samp{...}."
msgstr "만약 함수가 @code{...}를 형식인자로 가지게 된다면, @samp{...}는 형식인자와 일치하지 않은 어떠한 실제적인 인자들과도 일치하지 않습니다."

#. type: subsection
#: R-lang.texi:559
#, no-wrap
msgid "Environments"
msgstr ""

#. type: Plain text
#: R-lang.texi:570
msgid "Environments can be thought of as consisting of two things.  A @emph{frame}, consisting of a set of symbol-value pairs, and an @emph{enclosure}, a pointer to an enclosing environment. When @R{} looks up the value for a symbol the frame is examined and if a matching symbol is found its value will be returned.  If not, the enclosing environment is then accessed and the process repeated.  Environments form a tree structure in which the enclosures play the role of parents.  The tree of environments is rooted in an empty"
msgstr "인바이런먼트(environment)는 두 가지로 구성되어 있다고 생각할 수 있습니다.  심볼(symbol)과 값(value)들이 짝으로 이루어져 있는 프레임(@emph{frame})과 인클로징 인바이런먼트(enclosing environment)에 대한 포인터(pointer)인 인클로저(@emph{enclosure})입니다. @R{}이 심볼에 대한 값을 찾고자 할때 프레임이 검사되며 만약 일치하는 심볼을 찾게 된다면 이것의 값을 반환하게 됩니다.  만약 그렇지 않다면 인클로징 인바이런먼트에 접근된 후에 이 과정을 반복하게 됩니다.  인바이런먼트는 인클로져들의 부모 역할을 하는 트리 구조(tree structure)로 되어 있습니다. 인바이런먼트들로 되어 있는 트리는 부모(parent)가 없는 비어있는 인바이런먼트(empty environment)로부터 시작되며 @code{emptyenv()}를 통하여 사용가능합니다.  "

#. type: findex
#: R-lang.texi:570
#, no-wrap
msgid "emptyenv"
msgstr ""

#. type: Plain text
#: R-lang.texi:573
msgid "environment, available through @code{emptyenv()}, which has no parent.  It is the direct parent of the environment of the base package"
msgstr "이는 base 패키지의 환경에 대한 직접적인 부모이며 (@code{baseenv()}함수를 통하여 이용할 수 있습니다)."

#. type: findex
#: R-lang.texi:573
#, no-wrap
msgid "baseenv"
msgstr ""

#. type: Plain text
#: R-lang.texi:577
msgid "(available through the @code{baseenv()} function). Formerly @code{baseenv()} had the special value @code{NULL}, but as from version 2.4.0, the use of @code{NULL} as an environment is defunct."
msgstr "2.4.0 이전에는 @code{baseenv()}는 @code{NULL}이라는 특별한 값을 가지고 있었으나, 이후부터는 환경에 @code{NULL}은 더 이상 사용되지 않습니다. "

#. type: Plain text
#: R-lang.texi:583
msgid "Environments are created implicitly by function calls, as described in @ref{Function objects} and @ref{Lexical environment}.  In this case the environment contains the variables local to the function (including the arguments), and its enclosure is the environment of the currently called function.  Environments may also be created directly by @code{new.env}."
msgstr "환경(environment)이라는 것은 @ref{Function objects}와 @ref{Lexical environment}에 설명된 것과 같이 함수호출에 의하여 직접적으로 생성되지 않을 수도 있습니다. 이 경우 환경은 인자들을 포함하여 함수에 국한적인 변수들을 포함하게 되며, 이것의 인클로져(enclosure)는 현재 호출된 함수의 환경입니다. 환경들은 아마도 @code{new.env}를 이용하여 직접적으로 생성될 수도 있습니다."

#. type: findex
#: R-lang.texi:583
#, no-wrap
msgid "new.env"
msgstr ""

#. type: Plain text
#: R-lang.texi:587
msgid "The frame content of an environment can be accessed and manipulated by use of @code{ls}, @code{get} and @code{assign} as well as @code{eval} and @code{evalq}."
msgstr " 함수의 프레임내에 있는 내용들은 @code{ls}, @code{get}, @code{assign}, @code{eval}, 그리고 @code{evalq}에 의하여 접근되고 조작되어질 수 있습니다. "

#. type: Plain text
#: R-lang.texi:590
msgid "The @code{parent.env} function may be used to access the enclosure of an environment."
msgstr "@code{parent.env} 함수는 환경의 인클로져에 접근하기 위해서 사용될 수 있습니다."

#. type: Plain text
#: R-lang.texi:596
msgid "Unlike most other @R{} objects, environments are not copied when passed to functions or used in assignments.  Thus, if you assign the same environment to several symbols and change one, the others will change too.  In particular, assigning attributes to an environment can lead to surprises."
msgstr "대부분의 @R{} 객체들과는 다르게 환경들은 함수에 전달되어지거나 할당에 사용이 될 때 복사되어지지 않습니다. 따라서, 만약 같은 환경을 여러개의 심볼에 할당하거나 이를 변경한다면 다른 것들이 함께 변경되게 됩니다. 특히, 환경에 속성을 부여하는 것은 예상치 못한 결과를 가져오기도 합니다."

#. type: Plain text
#: R-lang.texi:606
msgid "Pairlist objects are similar to Lisp's dotted-pair lists.  They are used extensively in the internals of @R{}, but are rarely visible in interpreted code, although they are returned by @code{formals}, and can be created by (e.g.) the @code{pairlist} function. A zero-length pairlist is @code{NULL}, as would be expected in Lisp but in contrast to a zero-length list."
msgstr "Pairlist object들은 Lisp의 dotted-pair 목록들과 비슷합니다. 그들은 R의 내부에서 광범위하게 쓰여지지만, 그들이 formals에 의해 return되고 (예를들어) pairlist function에 의해 생성될 수도 있음에도 불구하고, 변환된 코드에서는 드물게 보여집니다. Lisp에서 예상되는 것 처럼 길이가 0인 pairlist는 NULL이지만 길이가 0인 목록과는 반대입니다.  "

#. type: findex
#: R-lang.texi:606
#, no-wrap
msgid "pairlist"
msgstr ""

#. type: Plain text
#: R-lang.texi:616
msgid "Each such object has three slots, a CAR value, a CDR value and a TAG value.  The TAG value is a text string and CAR and CDR usually represent, respectively, a list item (head) and the remainder (tail) of the list with a NULL object as terminator (the CAR/CDR terminology is traditional Lisp and originally referred to the address and decrement registers on an early 60's IBM computer)."
msgstr "각각의 object들은 CAR 값, CDR값과 TAG값의 세 개의 자리가 있습니다. TAG 값은 text string이고 CAR과 CDR는 순서대로 보통 나타내는 list item (head)과 목록의 NULL object를 terminator처럼 가지고있는 목록의 remainder (tail)입니다 (CAR/CDR 용어는 전통적인 Lisp이고 처음으로 address를 나타냈고 60년대 초반 IBM 컴퓨터에서 감소가 되었습니다???). "

#. type: Plain text
#: R-lang.texi:624
msgid "Pairlists are handled in the @R{} language in exactly the same way as generic vectors (``lists'').  In particular, elements are accessed using the same @code{[[]]} syntax.  The use of pairlists is deprecated since generic vectors are usually more efficient to use.  When an internal pairlist is accessed from @R{} it is generally (including when subsetted) converted to a generic vector."
msgstr "Pairlist들은 포괄적인 벡터들 (\"lists\")와 똑같은 방법으로 R 언어에서 다루어 집니다. 특히, element들은 같은[[]] syntax를 사용하여 접근됩니다. 내부의 pairlist가 R에서부터 접근되었을때, 이는 일반적으로 (subset이 되었을때를 포함) 포괄적인 벡터로 전환됩니다."

#. type: Plain text
#: R-lang.texi:626
msgid "In a very few cases pairlists are user-visible: one is @code{.Options}."
msgstr "아주 드문 경우들로 pairlist들이 user-visible합니다: 한 개의 예는 .Options입니다."

#. type: subsection
#: R-lang.texi:628
#, no-wrap
msgid "The ``Any'' type"
msgstr ""

#. type: Plain text
#: R-lang.texi:633
msgid "It is not really possible for an object to be of ``Any'' type, but it is nevertheless a valid type value.  It gets used in certain (rather rare)  circumstances, e.g.@: @code{as.vector(x, \"any\")}, indicating that type"
msgstr "Object가 “Any” 의 종류가 되는 것은 거의 가능하지 않지만, 그럼에도 불구하고 이는 유효한 type 값입니다. 이는 예를들어 type coercion이 되지 않아야함을 나타내주는 as.vector(x, \"any\")와 같은 특정한 상황들에 사용됩니다 (매우 드물게)."

#. type: Plain text
#: R-lang.texi:635
msgid "coercion should not be done."
msgstr ""

#. type: findex
#: R-lang.texi:641
#: R-lang.texi:649
#, no-wrap
msgid "attributes"
msgstr ""

#. type: Plain text
#: R-lang.texi:649
msgid "All objects except @code{NULL} can have one or more attributes attached to them.  Attributes are stored as a pairlist where all elements are named, but should be thought of as a set of name=value pairs.  A listing of the attributes can be obtained using @code{attributes} and set by @code{attributes<-},"
msgstr "NULL을 제외한 모든 object들은 그들에게 부여된 하나 이상의 attribute들을 가질 수 있습니다. Attribute들은 모든 element들이 이름지어진 곳에 pairlist처럼 저장되지만, name=value pair들의 세트처럼 생각되어야만 합니다. attribute들의 목록은 attributes를 사용하여 얻을 수 있고 attributes<-에 의해 설정됩니다. 각각의 구성요소들은 attr와 attr<-를 사용하여 접근됩니다. "

#. type: findex
#: R-lang.texi:650
#, no-wrap
msgid "attributes<-"
msgstr ""

#. type: Plain text
#: R-lang.texi:652
msgid "individual components are accessed using @code{attr} and @code{attr<-}."
msgstr ""

#. type: findex
#: R-lang.texi:652
#, no-wrap
msgid "attr"
msgstr ""

#. type: findex
#: R-lang.texi:653
#, no-wrap
msgid "attr<-"
msgstr ""

#. type: Plain text
#: R-lang.texi:658
msgid "Some attributes have special accessor"
msgstr ""

#. type: cindex
#: R-lang.texi:658
#, no-wrap
msgid "function, accessor"
msgstr ""

#. type: Plain text
#: R-lang.texi:665
msgid "functions (e.g.@: @code{levels<-} for factors) and these should be used when available. In addition to hiding details of implementation they may perform additional operations.  @R{} attempts to intercept calls to @code{attr<-} and to @code{attributes<-} that involve the special attributes and enforces the consistency checks."
msgstr "몇몇의 attribute들은 (예를들어 factor들을 위한 levels<-) 특별한 accessor function들을 가지고있고 이들은 사용가능할 때만 사용되어야만 합니다. 실행의 숨겨진 디테일에 추가적으로, 그들은 추가적인operation들을 실행할 지도 모릅니다. R은 특별한 attribute을 포함하고 일관적인 확인들을 강요하는 attr<-와 attributes<-로의 call들을 가로채려고 시도합니다. "

#. type: Plain text
#: R-lang.texi:668
msgid "Matrices and arrays are simply vectors with the attribute @code{dim} and optionally @code{dimnames} attached to the vector."
msgstr "행렬들과 열들은 간단하게말해서 dim attribute를 가진 벡터들이고 옵션적으로 dimnames가 벡터에 부여되어있습니다. "

#. type: Plain text
#: R-lang.texi:672
msgid "Attributes are used to implement the class structure used in @R{}.  If an object has a @code{class} attribute then that attribute will be examined during"
msgstr "Attribute들은 R에 사용된 class structure을 이행하하기위해 사용되었습니다. 만약 object가 class attribute를 가지고 있다면 그 attribute는 평가 도중 검토될 것입니다."

#. type: cindex
#: R-lang.texi:672
#: R-lang.texi:993
#: R-lang.texi:2490
#, no-wrap
msgid "evaluation, symbol"
msgstr ""

#. type: Plain text
#: R-lang.texi:675
msgid "evaluation.  The class structure in @R{} is described in detail in @ref{Object-oriented programming}."
msgstr " R의 class structure은 Object-oriented programming에 자세하게 설명되어있습니다. "

#. type: node
#: R-lang.texi:683
#: R-lang.texi:685
#: R-lang.texi:686
#: R-lang.texi:708
#, no-wrap
msgid "Names"
msgstr ""

#. type: node
#: R-lang.texi:683
#: R-lang.texi:685
#: R-lang.texi:708
#: R-lang.texi:709
#: R-lang.texi:723
#, no-wrap
msgid "Dimensions"
msgstr ""

#. type: node
#: R-lang.texi:683
#: R-lang.texi:708
#: R-lang.texi:723
#: R-lang.texi:724
#: R-lang.texi:731
#, no-wrap
msgid "Dimnames"
msgstr ""

#. type: node
#: R-lang.texi:683
#: R-lang.texi:723
#: R-lang.texi:731
#: R-lang.texi:732
#: R-lang.texi:748
#, no-wrap
msgid "Classes"
msgstr ""

#. type: node
#: R-lang.texi:683
#: R-lang.texi:731
#: R-lang.texi:748
#: R-lang.texi:749
#: R-lang.texi:755
#, no-wrap
msgid "Time series attributes"
msgstr ""

#. type: subsection
#: R-lang.texi:683
#: R-lang.texi:748
#: R-lang.texi:755
#: R-lang.texi:756
#, no-wrap
msgid "Copying of attributes"
msgstr ""

#. type: Plain text
#: R-lang.texi:693
msgid "A @code{names} attribute, when present, labels the individual elements of a vector or list.  When an object is printed the @code{names} attribute, when present, is used to label the elements.  The @code{names} attribute can also be used for indexing purposes, for example, @code{quantile(x)[\"25%\"]}."
msgstr "Names 속성은, 존재할 때, 벡터나 목록의 각각의 요소들에 label을 합니다. Object가 존재하는 names의 속성을 프린트하려고 할 때,  요소들을 label하기위하여 쓰여집니다. Names 속성은 예를들어quantile(x)[\"25%\"]와 같은 indexing 목적으로도 쓰여질 수 있습니다. "

#. type: Plain text
#: R-lang.texi:696
msgid "One may get and set the names using @code{names} and @code{names<-} constructions."
msgstr "names와 names<- 구성들을 사용하여 name들을 얻거나 설정할 수도 있습니다."

#. type: findex
#: R-lang.texi:696
#, no-wrap
msgid "names"
msgstr ""

#. type: findex
#: R-lang.texi:697
#, no-wrap
msgid "names<-"
msgstr ""

#. type: Plain text
#: R-lang.texi:701
msgid "The latter will perform the necessary consistency checks to ensure that the names attribute has the proper type and length."
msgstr "뒷쪽 것 (names<-)은 names 속성이 적합한 타입과 길이를 가지고있는지를 확실히 하기 위해 필요한 일관적인 체크를 수행할 것입니다. "

#. type: Plain text
#: R-lang.texi:707
msgid "Pairlists and one-dimensional arrays are treated specially. For pairlist objects, a virtual @code{names} attribute is used; the @code{names} attribute is really constructed from the tags of the list components.  For one-dimensional arrays the @code{names} attribute really accesses @code{dimnames[[1]]}."
msgstr "Pairlist들과 일차원 행들은 특별하게 대해집니다. Pairlist object들에는, 가상의 names 속성이 사용되어집니다; names 속성은 사실상 목록 구성요소들의 태그에서부터 구성됩니다. 일차원 행들에서 names 속성은 실제로dimnames[[1]]에 접근합니다."

#. type: Plain text
#: R-lang.texi:717
msgid "The @code{dim} attribute is used to implement arrays.  The content of the array is stored in a vector in column-major order and the @code{dim} attribute is a vector of integers specifying the respective extents of the array.  @R{} ensures that the length of the vector is the product of the lengths of the dimensions. The length of one or more dimensions may be zero."
msgstr "dim 속성은 행들을 이행하기위하여 쓰여집니다. 행의 내용은 열방향순서의 벡터안에 저장되고, 그 dim 속성은 각각의 행의 규모를 명시하는 정수의 벡터입니다. R은 벡터의 길이가dimension 길이의 산출물임을 확실하게 합니다. 하나 이상의 dimension의 길이가 0일 수도 있습니다. "

#. type: Plain text
#: R-lang.texi:722
msgid "A vector is not the same as a one-dimensional array since the latter has a @code{dim} attribute of length one, whereas the former has no @code{dim} attribute."
msgstr "벡터는 dim 속성이 없는 반면, 일차원 행은 길이가 1인 dim 속성을 가지고 있기때문에, 일차원 행과 같지 않습니다. "

#. type: Plain text
#: R-lang.texi:730
msgid "Arrays may name each dimension separately using the @code{dimnames} attribute which is a list of character vectors.  The @code{dimnames} list may itself have names which are then used for extent headings when printing arrays."
msgstr "행은 문자 벡터의 목록인 dimnames 속성을 사용하여 각각의 dimension을 따로 이름지을 수도 있습니다. dimnames 목록이 자기 자신의 이름을 가지고 있을 수 있으며, 그러면 이는 행들을 프린트 할 때 extent heading들로 쓰여집니다. "

#. type: Plain text
#: R-lang.texi:739
msgid "@R{} has an elaborate class system@footnote{actually two, but this draft manual predates the @pkg{methods} package.}, principally controlled via the @code{class} attribute.  This attribute is a character vector containing the list of classes that an object inherits from.  This forms the basis of the ``generic methods'' functionality in @R{}."
msgstr "R은class 속성을 통해 주로 컨트롤되는 정교한 class 시스테을 가지고 있습니다. 이 속성은object가 inherit하는 곳의 class들의 목록을 포함하고있는 문자 벡터입니다. 이 형태들은 R의 “일반적인 방법을” 기능의 기초를 형성합니다. "

#. type: Plain text
#: R-lang.texi:745
msgid "This attribute can be accessed and manipulated virtually without restriction by users.  There is no checking that an object actually contains the components that class methods expect.  Thus, altering the @code{class} attribute should be done with caution, and when they are available specific creation and"
msgstr "이 속성은 사용자에의한 제한 없이도 가상적으로 접근되고 조작될 수 있습니다. 여기에는 object가 class 방법들이 예상하는 구성요소들을 확실히 포함하고 있는지를 확인하는 것이 없습니다. 그러므로 class 속성을 대신하는 것은 조심해서 해야만하며, "

#. type: Plain text
#: R-lang.texi:747
msgid "coercion functions should be preferred."
msgstr "이들이 사용 가능할 때는 구체적인 창출과 강제 function들이 선호되어야만합니다. "

#. type: Plain text
#: R-lang.texi:754
msgid "The @code{tsp} attribute is used to hold parameters of time series, start, end, and frequency.  This construction is mainly used to handle series with periodic substructure such as monthly or quarterly data."
msgstr "tsp 속성은 시계열 분석, 시작, 끝, 그리고 빈도의 매개변수를 붙잡고 있기위해 사용됩니다. 이 구성은 월간 혹은 분기별 데이터처럼 주기적인 하부구조를 가진 series들을 다루기위해 주로 사용됩니다. "

#. type: Plain text
#: R-lang.texi:761
msgid "Whether attributes should be copied when an object is altered is a complex area, but there are some general rules (Becker, Chambers & Wilks, 1988, pp. 144--6)."
msgstr "Object가 변경되었을 때 속성이 복사가 되어야만 하는지 아닌지는 복잡한 영역이지만, 몇몇의 일반적인 규칙들이 있습니다(Becker, Chambers & Wilks, 1988, pp. 144–6). "

#. type: Plain text
#: R-lang.texi:765
msgid "Scalar functions (those which operate element-by-element on a vector and whose output is similar to the input) should preserve attributes (except perhaps class)."
msgstr "Scalar function들 (벡터에서 요소에서 요소로 실행하고 output이 input과 비슷한)은 속성들을 보존해야만 합니다 (class는 제외할 수도 있습니다)."

#. type: Plain text
#: R-lang.texi:771
msgid "Binary operations normally copy most attributes from the longer argument (and if they are of the same length from both, preferring the values on the first).  Here `most' means all except the @code{names}, @code{dim} and @code{dimnames} which are set appropriately by the code for the operator."
msgstr "2항 연산은 보통 더 긴 argument에서부터의 대부분의 속성들을 복사합니다 (그리고 만약 그들이 두 개 모두에서부터 같은 길이라면, 처음의 값을 선호합니다). 여기에서 ‘대부분’은 operator의 코드에의해 알맞게 설정된 names, dim, 그리고 dimnames를 제외한 모든 것 이라는 뜻입니다. "

#. type: Plain text
#: R-lang.texi:777
msgid "Subsetting (other than by an empty index) generally drops all attributes except @code{names}, @code{dim} and @code{dimnames} which are reset as appropriate.  On the other hand, subassignment generally preserves attributes even if the length is changed.  Coercion drops all attributes."
msgstr "(빈 index에 의한 것을 제외한) subsetting은 일반적으로 알맞게 reset되는 names, dim, 그리고 dimnames를 제외한 모든 속성을 drop합니다. 반면에, subassignment는 일반적으로 길이가 바뀌더라도 속성을 보존합니다. Coercion은 모든 속성을 drop합니다. "

#. type: Plain text
#: R-lang.texi:780
msgid "The default method for sorting drops all attributes except names, which are sorted along with the object."
msgstr "Sorting의 기본 방법은 object와 마찬가지로 구분/정렬되는 names를 제외한 모든 속성들을 drop하는 것입니다."

#. type: node
#: R-lang.texi:788
#: R-lang.texi:790
#: R-lang.texi:791
#: R-lang.texi:813
#, no-wrap
msgid "Factors"
msgstr ""

#. type: subsection
#: R-lang.texi:788
#: R-lang.texi:790
#: R-lang.texi:813
#: R-lang.texi:814
#, no-wrap
msgid "Data frame objects"
msgstr ""

#. type: Plain text
#: R-lang.texi:798
msgid "Factors are used to describe items that can have a finite number of values (gender, social class, etc.).  A factor has a @code{levels} attribute and class @code{\"factor\"}.  Optionally, it may also contain a @code{contrasts} attribute which controls the parametrisation used when the factor is used in a"
msgstr "Factor들은 유한 값들을 가질 수 있는 아이템들 (성별, 사회계층 등)을 설명하기위하여 사용됩니다. Factor는 levels 속성과 “factor” class를 가집니다. 선택적으로, factor이 modeling function들에 사용되었을 때 사용된 parametrisation을 조정하기위한 contrasts 속성도 포함하고 있을 수 있습니다. "

#. type: cindex
#: R-lang.texi:798
#, no-wrap
msgid "function, modeling"
msgstr ""

#. type: cindex
#: R-lang.texi:799
#, no-wrap
msgid "modeling function"
msgstr ""

#. type: Plain text
#: R-lang.texi:801
msgid "modeling functions."
msgstr ""

#. type: Plain text
#: R-lang.texi:805
msgid "A factor may be purely nominal or may have ordered categories.  In the latter case, it should be defined as such and have a @code{class} vector @code{c(\"ordered\",\" factor\")}."
msgstr "Factor는 순수하게 명목상이거나 순차적인 카테고리일 수도 있습니다. 순차적인 카테고리일 경우, 그렇게 정의되어야만하고 class 벡터c(\"ordered\",\" factor\")를 가집니다."

#. type: Plain text
#: R-lang.texi:812
msgid "Factors are currently implemented using an integer array to specify the actual levels and a second array of names that are mapped to the integers.  Rather unfortunately users often make use of the implementation in order to make some calculations easier.  This, however, is an implementation issue and is not guaranteed to hold in all implementations of @R{}."
msgstr "Factor들은 현재 실질적인 레벨과 정수로 연결된 names의 두 번째 행을 지정하기위한 정수 행을 사용하여 실행됩니다. 불행하게도, 사용자들은 때때로 몇몇의 계산을 조금 더 쉬게 맘ㄴ들기 위하여 실행을 사용합니다. 그러나 이는 이행 문제이고 R의 모든 이행들을 할 수 있다고 장담할 수 없습니다."

#. type: Plain text
#: R-lang.texi:818
msgid "Data frames are the @R{} structures which most closely mimic the SAS or SPSS data set, i.e.@: a ``cases by variables'' matrix of data."
msgstr "데이터 프레임은 SAS 혹은 SPSS 데이터 셋을 가장 비슷하게 흉내내는 R structure들 입니다, 즉 데이터의 “값에 의한 경우들” 행렬."

#. type: Plain text
#: R-lang.texi:823
msgid "A data frame is a list of vectors, factors, and/or matrices all having the same length (number of rows in the case of matrices).  In addition, a data frame generally has a @code{names} attribute labeling the variables and a @code{row.names} attribute for labeling the cases."
msgstr "데이터 프레임은 모두가 같은 길이(행렬일 경우에는 열의 갯수)를 가지고있는 벡터들, factor들, 그리고/또는 행렬들의 목록입니다. 추가적으로, 데이터 프레임은 일반적으로 값들을 label하는 names 속성과 경우들을 label하는 row.names 속성을 가지고 있습니다. "

#. type: Plain text
#: R-lang.texi:828
msgid "A data frame can contain a list that is the same length as the other components.  The list can contain elements of differing lengths thereby providing a data structure for ragged arrays.  However, as of this writing such arrays are not generally handled correctly."
msgstr "데이터 프레임은 다른 구성요소들처럼 같은 길이의 목록을 포함할 수 있습니다. 목록은 상이한 길이의 요소들을 포함할 수 있고 그렇게 함으로써 rag된 배열들의 데이터 structure을 제공합니다. 그러나, 현재 이 글에서 그러한 배열들은 일반적으로 올바르게 다루어지지 않습니다."

#. type: Plain text
#: R-lang.texi:912
msgid "When a user types a command at the prompt (or when an expression is read from a file) the first thing that happens to it is that the command is transformed by the"
msgstr "사용자가 prompt에 명령어를 입력했을 때 (혹은 파일에서부터 expression이 읽혀졌을 때), 그에 처음으로 일어나는 일은 명령어가 parser에 의해 internal representation으로 변형된다는 것입니다."

#. type: Plain text
#: R-lang.texi:917
msgid "parser into an internal representation.  The evaluator executes parsed @R{} expressions and returns the value of the expression.  All expressions have a value.  This is the core of the language."
msgstr "Evaluator는 parse된 R expression들을 실행하고 그 expression의 값을 돌려줍니다. 모든 expression들은 값을 가지고 있습니다. 이는 언어의 핵심입니다. "

#. type: Plain text
#: R-lang.texi:922
msgid "This chapter describes the basic mechanisms of the evaluator, but avoids discussion of specific functions or groups of functions which are described in separate chapters later on or where the help pages should be sufficient documentation."
msgstr "이 챕터는 evaluator의 기본 mechanism들을 설명하지만, 다른 챕터들에서 나중에 설명되었거나 help 페이지들이 충분히 문서화되어있는 특정한 function들이나 function들의 그룹들에 대하여 이야기하는것은 피합니다. "

#. type: Plain text
#: R-lang.texi:924
msgid "Users can construct expressions and invoke the evaluator on them."
msgstr "사용자는 expression들을 구성할 수 있고 그에 evaluator를 적용할 수 있습니다."

#. type: node
#: R-lang.texi:931
#: R-lang.texi:933
#: R-lang.texi:934
#: R-lang.texi:943
#: R-lang.texi:984
#: R-lang.texi:1041
#: R-lang.texi:1096
#: R-lang.texi:1227
#, no-wrap
msgid "Simple evaluation"
msgstr ""

#. type: node
#: R-lang.texi:931
#: R-lang.texi:933
#: R-lang.texi:1227
#: R-lang.texi:1228
#: R-lang.texi:1284
#: R-lang.texi:1356
#: R-lang.texi:1384
#: R-lang.texi:1401
#: R-lang.texi:1417
#: R-lang.texi:1436
#: R-lang.texi:1508
#, no-wrap
msgid "Control structures"
msgstr ""

#. type: node
#: R-lang.texi:931
#: R-lang.texi:1227
#: R-lang.texi:1508
#: R-lang.texi:1509
#: R-lang.texi:1522
#: R-lang.texi:1533
#: R-lang.texi:1541
#: R-lang.texi:1547
#: R-lang.texi:1605
#, no-wrap
msgid "Elementary arithmetic operations"
msgstr ""

#. type: node
#: R-lang.texi:931
#: R-lang.texi:1508
#: R-lang.texi:1605
#: R-lang.texi:1606
#: R-lang.texi:1663
#: R-lang.texi:1753
#: R-lang.texi:1829
#: R-lang.texi:1857
#: R-lang.texi:2030
#, no-wrap
msgid "Indexing"
msgstr ""

#. type: node
#: R-lang.texi:931
#: R-lang.texi:1605
#: R-lang.texi:2030
#: R-lang.texi:2031
#: R-lang.texi:2051
#: R-lang.texi:2063
#: R-lang.texi:2105
#: R-lang.texi:2159
#, no-wrap
msgid "Scope of variables"
msgstr ""

#. type: subsection
#: R-lang.texi:941
#: R-lang.texi:943
#: R-lang.texi:944
#: R-lang.texi:984
#: R-lang.texi:4288
#, no-wrap
msgid "Constants"
msgstr ""

#. type: node
#: R-lang.texi:941
#: R-lang.texi:943
#: R-lang.texi:984
#: R-lang.texi:985
#: R-lang.texi:1041
#, no-wrap
msgid "Symbol lookup"
msgstr ""

#. type: subsection
#: R-lang.texi:941
#: R-lang.texi:984
#: R-lang.texi:1041
#: R-lang.texi:1042
#: R-lang.texi:1096
#: R-lang.texi:4570
#, no-wrap
msgid "Function calls"
msgstr ""

#. type: subsection
#: R-lang.texi:941
#: R-lang.texi:1041
#: R-lang.texi:1096
#: R-lang.texi:1097
#, no-wrap
msgid "Operators"
msgstr ""

#. type: Plain text
#: R-lang.texi:947
msgid "Any number typed directly at the prompt is a constant and is evaluated."
msgstr "Prompt에 바로 입력된 모든 숫자들은 항수이고 평가되어집니다. "

#. type: example
#: R-lang.texi:951
#, no-wrap
msgid ""
"> 1\n"
"[1] 1\n"
msgstr ""

#. type: Plain text
#: R-lang.texi:963
msgid "Perhaps unexpectedly, the number returned from the expression @code{1} is a numeric.  In most cases, the difference between an integer and a numeric value will be unimportant as R will do the right thing when using the numbers.  There are, however, times when we would like to explicitly create an integer value for a constant.  We can do this by calling the function @code{as.integer} or using various other techniques. But perhaps the simplest approach is to qualify our constant with the suffix character `L'.  For example, to create the integer value 1, we might use"
msgstr "아마 예상밖일지도 모르지만, expression 1에서부터 돌아오는 숫자는 numeric입니다. 대부분의 경우에, 숫자들을 사용할 때 R이 알맞게 할 것이기 때문에 정수와 numeric값의 다른점은 중요하지 않을 것입니다.  하지만, 항수에 확실하게 정수 값을 생성하고 싶을때도 있습니다. 이럴 경우, as.integer function을 call하거나 여러가지의 다른 기술들을 사용함으로써 할 수 있습니다. 하지만 아마도 가장 쉬운 접근방법은 suffix character “L”로 우리의 항수를 qualify 하도록 하는 것 입니다. 예를들어, 정수 값 1을 생성하기위해, 우리는 다음을 사용할 수도 있습니다."

#. type: example
#: R-lang.texi:967
#, no-wrap
msgid ""
"> 1L\n"
"[1]\n"
msgstr ""

#. type: Plain text
#: R-lang.texi:978
msgid "We can use the `L' suffix to qualify any number with the intent of making it an explicit integer.  So `0x10L' creates the integer value 16 from the hexadecimal representation.  The constant @code{1e3L} gives 1000 as an integer rather than a numeric value and is equivalent to @code{1000L}.  (Note that the `L' is treated as qualifying the term @code{1e3} and not the @code{3}.)  If we qualify a value with `L' that is not an integer value, e.g. @code{1e-3L}, we get a warning and the numeric value is created.  A warning is also created if there is an unnecessary decimal point in the number, e.g. @code{1.L}."
msgstr "‘L’ suffix를 확실하게 정수도 만들려는 의도를 가진 어떠한 숫자라도 qualify하도록 할 때 사용할 수 있습니다. 그래서 ‘0x10L’은 16진법 representation으로부터의 정수값 16ㅇ르 생성합니다. 항수 1e3L은 1000을 numeric값 대신 정수로 주고 이는 1000L과 동일합니다. (‘L’이 3이 아닌 1e3항을 qualify 하는 것 처럼 취급됩니다.) 만약 우리가 정수값이 아닌 ‘L’로, 예를들어 1e-3L, 값을 qualify한다면, warning을 받고 numeric값이 생성됩니다. Warning은 숫자에 필요하지 않은 소수점이, 예를들어 1.L, 있을때도 생성됩니다."

#. type: Plain text
#: R-lang.texi:981
msgid "We get a syntax error when using `L' with complex numbers, e.g. @code{12iL} gives an error."
msgstr "복소수인 ‘L’을 사용할 때, 예로 12iL,  syntax 에러를 받습니다."

#. type: Plain text
#: R-lang.texi:983
msgid "Constants are fairly boring and to do more we need symbols."
msgstr "항수들은꽤나 지루하고  부호들이 필요할 때 더 작업합니다.?????(영어가 이상)"

#. type: Plain text
#: R-lang.texi:988
msgid "When a new variable is created it must have a"
msgstr "새로운 값이 생성되었을 때,"

#. type: Plain text
#: R-lang.texi:990
msgid "name so it can be referenced and it usually has a value.  The name itself is a"
msgstr "이는 찾아질 수 있도록 이름이 있어야만하고 보통 값이 있습니다."

#. type: Plain text
#: R-lang.texi:993
msgid "symbol.  When a symbol is"
msgstr "이름 자체가 symbol입니다. "

#. type: Plain text
#: R-lang.texi:995
msgid "evaluated its"
msgstr "Symbol이 평가될 때 그 값이 되돌려집니다."

#. type: cindex
#: R-lang.texi:995
#, no-wrap
msgid "value"
msgstr ""

#. type: Plain text
#: R-lang.texi:998
msgid "value is returned.  Later we shall explain in detail how to determine the value associated with a symbol."
msgstr "나중에 symbol에 관련된 값을 어떻게 알아내는지를 자세하게 설명할 것입니다. "

#. type: Plain text
#: R-lang.texi:1003
msgid "In this small example @code{y} is a symbol and its value is 4.  A symbol is an @R{} object too, but one rarely needs to deal with symbols directly, except when doing ``programming on the language'' (@ref{Computing on the language})."
msgstr "아래의 간단한 예제에서 y 는 symbol이고 그의 값은 4입니다. Symbol도 R object이지만, “programming on the language”를 할 때를 제외하고는, symbol들을 직접적으로 쓸 일은 거의 없습니다 (Computing on the language). "

#. type: example
#: R-lang.texi:1008
#, no-wrap
msgid ""
"> y <- 4\n"
"> y\n"
"[1] 4\n"
msgstr ""

#. type: Plain text
#: R-lang.texi:1046
msgid "Most of the computations carried out in @R{} involve the evaluation of functions.  We will also refer to this as"
msgstr "대부분의 계산들은 function들의 evaluation이 포함된 R에서 이루어집니다. "

#. type: cindex
#: R-lang.texi:1046
#, no-wrap
msgid "function invocation"
msgstr ""

#. type: Plain text
#: R-lang.texi:1050
msgid "function @emph{invocation}.  Functions are invoked by name with a list of arguments separated by commas."
msgstr "이를 function invocation처럼 여길것 입니다. function들은 쉼표로 분리된 argument들의 목록으로 된 이름에의해 불러집니다"

#. type: example
#: R-lang.texi:1054
#, no-wrap
msgid ""
"> mean(1:10)\n"
"[1] 5.5\n"
msgstr ""

#. type: Plain text
#: R-lang.texi:1059
msgid "In this example the function @code{mean} was called with one argument, the vector of integers from 1 to 10."
msgstr "위의 예에서 function mean은 1부터 10까지의 정수 벡터인, 하나의 argument로 불려졌습니다. "

#. type: Plain text
#: R-lang.texi:1063
msgid "@R{} contains a huge number of functions with different purposes.  Most are used for producing a result which is an @R{} object, but others are used for their side effects, e.g., printing and plotting functions."
msgstr "R은 다른 목적의 방대한 양의 function들을 포함하고 있습니다. 대부분은 R object인 결과를 산출하기위해 쓰여지지만, 다른 것들은 예를들어 프린트하거나 함수의 그래프를 그리는 것 등의 side effect들을 위하여 사용됩니다. "

#. type: cindex
#: R-lang.texi:1065
#, no-wrap
msgid "function arguments"
msgstr ""

#. type: Plain text
#: R-lang.texi:1073
msgid "Function calls can have @emph{tagged} (or @emph{named}) arguments, as in @code{plot(x, y, pch = 3)}.  Arguments without tags are known as @emph{positional} since the function must distinguish their meaning from their sequential positions among the arguments of the call, e.g., that @code{x} denotes the abscissa variable and @code{y} the ordinate.  The use of tags/names is an obvious convenience for functions with a large number of optional arguments."
msgstr "Function call들은 tagged (혹은 named)된 argument들을 가지고 있을 수 있습니다. plot(x, y, pch = 3)에서처럼 tag가 없는 argument들은, 예로 x가 가로축 값을 그리고 y가 세로축을 나타내는 것과 같이, call의 argument들 중 순차배열에서 이 의미를 구별해야만 하기때문에 positional로 알려져 있습니다. Tags/names의 사용은 많은 양의 옵션적인 argument들이 function들에 매우 편리합니다.특별한 종류의 function call들은 다음과 같이 assignment operator의 왼쪽에 나타날 수도 있습니다. "

#. type: cindex
#: R-lang.texi:1074
#, no-wrap
msgid "function, assignment"
msgstr ""

#. type: Plain text
#: R-lang.texi:1077
msgid "A special type of function calls can appear on the left hand side of the"
msgstr ""

#. type: Plain text
#: R-lang.texi:1079
msgid "assignment operator as in"
msgstr ""

#. type: example
#: R-lang.texi:1082
#, no-wrap
msgid "> class(x) <- \"foo\"\n"
msgstr ""

#. type: Plain text
#: R-lang.texi:1091
msgid "What this construction really does is to call the function @code{class<-} with the original object and the right hand side.  This function performs the modification of the object and returns the result which is then stored back into the original variable.  (At least conceptually, this is what happens.  Some additional effort is made to avoid unnecessary data duplication.)"
msgstr "이 구성이 실제로 하는 것은 원래의 object인  class<- function과 오른쪽을 부르는 것입니다. 이 function은 object의 변경을 수행하고 그리고 나서 원래의 값에 다시 저장되는 결과를 돌려줍니다. (적어도 개념상으로, 이가 행해집니다. 몇몇의 추가적인 노력은 필요하지 않은 데이터 중복을 피하도록하는 것 입니다.) "

#. type: Plain text
#: R-lang.texi:1101
msgid "@R{} allows the use of arithmetic expressions using operators similar to those of the C programming language, for instance"
msgstr "R은 C 프로그래밍 언어의 것도 비슷하게 operator들을 사용한 연산 expression들의 사용을 허용합니다. 예를들어,"

#. type: example
#: R-lang.texi:1105
#, no-wrap
msgid ""
"> 1 + 2\n"
"[1] 3\n"
msgstr ""

#. type: Plain text
#: R-lang.texi:1109
msgid "Expressions can be grouped using parentheses, mixed with function calls, and assigned to variables in a straightforward manner"
msgstr "Expression들은 괄호를 사용하여 그룹지어질 수 있고, function call들과 조합될 수도 있으며, 간단한 방법으로 값들에 assign될 수도 있습니다. R은 아래 테이블에 나열되어있는 다양한 operator들을 포함합니다"

#. type: example
#: R-lang.texi:1112
#, no-wrap
msgid "> y <- 2 * (a + log(x))\n"
msgstr ""

#. type: Plain text
#: R-lang.texi:1116
msgid "@R{} contains a number of operators.  They are listed in the table below."
msgstr ""

#. type: code{#1}
#: R-lang.texi:1119
#, no-wrap
msgid "-"
msgstr ""

#. type: multitable
#: R-lang.texi:1121
msgid "Minus, can be unary or binary"
msgstr ""

#. type: code{#1}
#: R-lang.texi:1121
#, no-wrap
msgid "+"
msgstr ""

#. type: multitable
#: R-lang.texi:1123
msgid "Plus, can be unary or binary"
msgstr ""

#. type: code{#1}
#: R-lang.texi:1123
#, no-wrap
msgid "!"
msgstr ""

#. type: multitable
#: R-lang.texi:1125
msgid "Unary not"
msgstr ""

#. type: code{#1}
#: R-lang.texi:1125
#, no-wrap
msgid "~"
msgstr ""

#. type: multitable
#: R-lang.texi:1127
msgid "Tilde, used for model formulae, can be either unary or binary"
msgstr ""

#. type: code{#1}
#: R-lang.texi:1127
#, no-wrap
msgid "?"
msgstr ""

#. type: multitable
#: R-lang.texi:1129
msgid "Help"
msgstr ""

#. type: code{#1}
#: R-lang.texi:1129
#, no-wrap
msgid ":"
msgstr ""

#. type: multitable
#: R-lang.texi:1131
msgid "Sequence, binary (in model formulae: interaction)"
msgstr ""

#. type: code{#1}
#: R-lang.texi:1131
#, no-wrap
msgid "*"
msgstr ""

#. type: multitable
#: R-lang.texi:1133
msgid "Multiplication, binary"
msgstr ""

#. type: code{#1}
#: R-lang.texi:1133
#, no-wrap
msgid "/"
msgstr ""

#. type: multitable
#: R-lang.texi:1135
msgid "Division, binary"
msgstr ""

#. type: code{#1}
#: R-lang.texi:1135
#, no-wrap
msgid "^"
msgstr ""

#. type: multitable
#: R-lang.texi:1137
msgid "Exponentiation, binary"
msgstr ""

#. type: code{#1}
#: R-lang.texi:1137
#, no-wrap
msgid "%@var{x}%"
msgstr ""

#. type: multitable
#: R-lang.texi:1139
msgid "Special binary operators, @var{x} can be replaced by any valid name"
msgstr ""

#. type: code{#1}
#: R-lang.texi:1139
#, no-wrap
msgid "%%"
msgstr ""

#. type: multitable
#: R-lang.texi:1141
msgid "Modulus, binary"
msgstr ""

#. type: code{#1}
#: R-lang.texi:1141
#, no-wrap
msgid "%/%"
msgstr ""

#. type: multitable
#: R-lang.texi:1143
msgid "Integer divide, binary"
msgstr ""

#. type: code{#1}
#: R-lang.texi:1143
#, no-wrap
msgid "%*%"
msgstr ""

#. type: multitable
#: R-lang.texi:1145
msgid "Matrix product, binary"
msgstr ""

#. type: code{#1}
#: R-lang.texi:1145
#, no-wrap
msgid "%o%"
msgstr ""

#. type: multitable
#: R-lang.texi:1147
msgid "Outer product, binary"
msgstr ""

#. type: code{#1}
#: R-lang.texi:1147
#, no-wrap
msgid "%x%"
msgstr ""

#. type: multitable
#: R-lang.texi:1149
msgid "Kronecker product, binary"
msgstr ""

#. type: code{#1}
#: R-lang.texi:1149
#, no-wrap
msgid "%in%"
msgstr ""

#. type: multitable
#: R-lang.texi:1151
msgid "Matching operator, binary (in model formulae: nesting)"
msgstr ""

#. type: code{#1}
#: R-lang.texi:1151
#, no-wrap
msgid "<"
msgstr ""

#. type: multitable
#: R-lang.texi:1153
msgid "Less than, binary"
msgstr ""

#. type: code{#1}
#: R-lang.texi:1153
#, no-wrap
msgid ">"
msgstr ""

#. type: multitable
#: R-lang.texi:1155
msgid "Greater than, binary"
msgstr ""

#. type: code{#1}
#: R-lang.texi:1155
#, no-wrap
msgid "=="
msgstr ""

#. type: multitable
#: R-lang.texi:1157
msgid "Equal to, binary"
msgstr ""

#. type: code{#1}
#: R-lang.texi:1157
#, no-wrap
msgid ">="
msgstr ""

#. type: multitable
#: R-lang.texi:1159
msgid "Greater than or equal to, binary"
msgstr ""

#. type: code{#1}
#: R-lang.texi:1159
#, no-wrap
msgid "<="
msgstr ""

#. type: multitable
#: R-lang.texi:1161
msgid "Less than or equal to, binary"
msgstr ""

#. type: code{#1}
#: R-lang.texi:1161
#, no-wrap
msgid "&"
msgstr ""

#. type: multitable
#: R-lang.texi:1163
msgid "And, binary, vectorized"
msgstr ""

#. type: code{#1}
#: R-lang.texi:1163
#, no-wrap
msgid "&&"
msgstr ""

#. type: multitable
#: R-lang.texi:1165
msgid "And, binary, not vectorized"
msgstr ""

#. type: code{#1}
#: R-lang.texi:1165
#, no-wrap
msgid "|"
msgstr ""

#. type: multitable
#: R-lang.texi:1167
msgid "Or, binary, vectorized"
msgstr ""

#. type: code{#1}
#: R-lang.texi:1167
#, no-wrap
msgid "||"
msgstr ""

#. type: multitable
#: R-lang.texi:1169
msgid "Or, binary, not vectorized"
msgstr ""

#. type: code{#1}
#: R-lang.texi:1169
#, no-wrap
msgid "<-"
msgstr ""

#. type: multitable
#: R-lang.texi:1171
msgid "Left assignment, binary"
msgstr ""

#. type: code{#1}
#: R-lang.texi:1171
#, no-wrap
msgid "->"
msgstr ""

#. type: multitable
#: R-lang.texi:1173
msgid "Right assignment, binary"
msgstr ""

#. type: findex
#: R-lang.texi:1173
#: R-lang.texi:1629
#: R-lang.texi:4695
#, no-wrap
msgid "$"
msgstr ""

#. type: multitable
#: R-lang.texi:1175
msgid "List subset, binary"
msgstr ""

#. type: Plain text
#: R-lang.texi:1182
msgid "Except for the syntax, there is no difference between applying an operator and calling a function.  In fact, @code{x + y} can equivalently be written @code{`+`(x, y)}.  Notice that since @samp{+} is a non-standard function name, it needs to be quoted."
msgstr "Syntax를 제외하고, operator를 적용하는 것과 function을 부르는 것의 차이는 없습니다. 실질적으로, x+y는`+`(x, y)로 동일하게 쓰여질 수 있습니다. ‘+’가 기본 function 이름이 아니기 때문에, quoted 되어야 한다는 것을 유의하십시오. "

#. type: Plain text
#: R-lang.texi:1196
msgid "@R{} deals with entire vectors of data at a time, and most of the elementary operators and basic mathematical functions like @code{log} are vectorized (as indicated in the table above).  This means that e.g.@: adding two vectors of the same length will create a vector containing the element-wise sums, implicitly looping over the vector index.  This applies also to other operators like @code{-}, @code{*}, and @code{/} as well as to higher dimensional structures.  Notice in particular that multiplying two matrices does not produce the usual matrix product (the @code{%*%} operator exists for that purpose).  Some finer points relating to vectorized operations will be discussed in @ref{Elementary arithmetic operations}."
msgstr "R은 한번에 데이터의 모든 행렬들을 다루고, 대부분의 기초 operator들과 log 같은 기본 수학 function들은 (위의 테이블에 나타난 것 처럼) 벡터화 됩니다. 이는 예로 같은 길이의 두개의 벡터들을 더하면 암암리에 벡터 인덱스에 looping하는 element-wise 덧셈을 포함한 벡터를 생성할 것입니다. 이는 -, *, 그리고 /와 더 높은 차원의 구조들과 같은 다른 operator들에도 적용합니다. 두 개의 행렬을 곱하는 것은 일반적인 행렬 값을 생산하지 않는다는 것을 특히 유의하십시오 (%*% operator가 이런 목적으로 존재합니다). Vectorized 작업들에 관련된 몇몇의 더 나은 사항들은 Elementary arithmetic operations에서 의논될 것 입니다.  "

#. type: Plain text
#: R-lang.texi:1199
msgid "To access individual elements of an atomic vector, one generally uses the @code{x[i]} construction."
msgstr "Atomic 벡터의 각각의 요소들에 접근하기 위해서는,  x[i] 구성을 일반적으로 사용합니다."

#. type: example
#: R-lang.texi:1206
#, no-wrap
msgid ""
"> x <- rnorm(5)\n"
"> x\n"
"[1] -0.12526937 -0.27961154 -1.03718717 -0.08156527  1.37167090\n"
"> x[2]\n"
"[1] -0.2796115\n"
msgstr ""

#. type: Plain text
#: R-lang.texi:1210
msgid "List components are more commonly accessed using @code{x$a} or @code{x[[i]]}."
msgstr ""

#. type: example
#: R-lang.texi:1215
#, no-wrap
msgid ""
"> x <- options()\n"
"> x$prompt\n"
"[1] \"> \"\n"
msgstr ""

#. type: Plain text
#: R-lang.texi:1218
msgid "Indexing constructs can also appear on the right hand side of an"
msgstr "Indexing construct들은 assignment의 오른쪽에 나타날 수도 있습니다. "

#. type: Plain text
#: R-lang.texi:1220
#: R-lang.texi:2520
msgid "assignment."
msgstr ""

#. type: Plain text
#: R-lang.texi:1223
msgid "Like the other operators, indexing is really done by functions, and one could have used @code{`[`(x, 2)} instead of @code{x[2]}."
msgstr "다른 operator들과 마찬가지로, indexing은 function들에 의해 취급되고, x[2] 대신 `[`(x, 2)를 썼을수도 있습니다. "

#. type: Plain text
#: R-lang.texi:1226
msgid "@R{}'s indexing operations contain many advanced features which are further described in @ref{Indexing}."
msgstr "R의 indexing 작업들은 Indexing에 더 자세하게 설명된 많은 고급 특성들은 포함하고 있습니다. "

#. type: Plain text
#: R-lang.texi:1234
msgid "Computation in @R{} consists of sequentially evaluating @emph{statements}.  Statements, such as @code{x<-1:10} or @code{mean(y)}, can be separated by either a semi-colon or a new line.  Whenever the"
msgstr "R의 계산은 statement들을 순차적으로 평가하는 것으로 구성되어져 있습니다. x<-1:10 혹은 mean(y)와 같은 Statement들은 semi-colon이나 새로운 줄에 의해 나누어 질 수 있습니다. "

#. type: cindex
#: R-lang.texi:1234
#, no-wrap
msgid "evaluation, statement"
msgstr ""

#. type: Plain text
#: R-lang.texi:1243
msgid "evaluator is presented with a syntactically complete statement that statement is evaluated and the @emph{value} returned.  The result of evaluating a statement can be referred to as the value of the statement@footnote{Evaluation always takes place in an @cindex environment environment.  See @ref{Scope of variables} for more details.} The value can always be assigned to a symbol."
msgstr "Evaluator이 통사적으로 완성된 평가된 statement들과 함께 존재할 때마다 값이 return됩니다. Statement의 평가의 결과는 statement의 값처럼 여겨질 수도 있습니다. 그 값은 언제나 기호로 지정될 수 있습니다."

#. type: Plain text
#: R-lang.texi:1250
msgid "Both semicolons and new lines can be used to separate statements.  A semicolon always indicates the end of a statement while a new line @emph{may} indicate the end of a statement.  If the current statement is not syntactically complete new lines are simply ignored by the evaluator.  If the session is interactive the prompt changes from @samp{>} to @samp{+}."
msgstr "semicolon들과 새로운 줄은 둘 다 서로 다른 statement들로 사용될 수 있습니다. 새로운 줄이 문장의 끝을 나타낼 수도 있는 반면, Semicolon은 항상 문장의 끝을 나타냅니다. 만약 현재 문장이 syntactically하게 완성되지 않았다면, 새로운 줄들은 evaluator로 간단하게 무시됩니다. 만약 그 세션이 상호적이라면, 그 prompt는 ‘>’ 에서 ‘+’로 바뀝니다."

#. type: example
#: R-lang.texi:1258
#, no-wrap
msgid ""
"> x <- 0; x + 5\n"
"[1] 5\n"
"> y <- 1:10\n"
"> 1; 2\n"
"[1] 1\n"
"[1] 2\n"
msgstr ""

#. type: Plain text
#: R-lang.texi:1267
msgid "Statements can be grouped together using braces @samp{@{} and @samp{@}}.  A group of statements is sometimes called a @emph{block}.  Single statements are evaluated when a new line is typed at the end of the syntactically complete statement.  Blocks are not evaluated until a new line is entered after the closing brace.  In the remainder of this section, @emph{statement} refers to either a single statement or a block."
msgstr "문장들은 중괄호 를 사용하여 그룹지어질 수 있습니다. 문장들의 하나의 그룹은 때때로 block이라고 불리어집니다. 단일 문장들은 syntactically하게 완성된 문장의 끝에 새로운 줄이 입력되었을 때 evaluate됩니다. Block들은 끝맺는 중괄호가 입력된 후 새로운 줄이 입력되기 전까지는 evaluate되지 않습니다. 이 섹션의 마지막으로, statement는 단일 문장혹은 block중에 하나를 지칭합니다."

#. type: example
#: R-lang.texi:1273
#, no-wrap
msgid ""
"> @{ x <- 0\n"
"+ x + 5\n"
"+ @}\n"
"[1] 5\n"
msgstr ""

#. type: node
#: R-lang.texi:1282
#: R-lang.texi:1284
#: R-lang.texi:1285
#: R-lang.texi:1356
#, no-wrap
msgid "if"
msgstr ""

#. type: node
#: R-lang.texi:1282
#: R-lang.texi:1284
#: R-lang.texi:1356
#: R-lang.texi:1357
#: R-lang.texi:1384
#, no-wrap
msgid "Looping"
msgstr ""

#. type: node
#: R-lang.texi:1282
#: R-lang.texi:1356
#: R-lang.texi:1384
#: R-lang.texi:1385
#: R-lang.texi:1386
#: R-lang.texi:1401
#, no-wrap
msgid "repeat"
msgstr ""

#. type: node
#: R-lang.texi:1282
#: R-lang.texi:1384
#: R-lang.texi:1401
#: R-lang.texi:1402
#: R-lang.texi:1403
#: R-lang.texi:1417
#, no-wrap
msgid "while"
msgstr ""

#. type: node
#: R-lang.texi:1282
#: R-lang.texi:1401
#: R-lang.texi:1417
#: R-lang.texi:1418
#: R-lang.texi:1419
#: R-lang.texi:1436
#, no-wrap
msgid "for"
msgstr ""

#. type: findex
#: R-lang.texi:1282
#: R-lang.texi:1417
#: R-lang.texi:1436
#: R-lang.texi:1437
#: R-lang.texi:1438
#, no-wrap
msgid "switch"
msgstr ""

#. type: Plain text
#: R-lang.texi:1293
msgid "The @code{if}/@code{else} statement conditionally evaluates two statements.  There is a @emph{condition} which is evaluated and if the @emph{value} is @code{TRUE} then the first statement is evaluated; otherwise the second statement will be evaluated.  The @code{if}/@code{else} statement returns, as its value, the value of the statement that was selected.  The formal syntax is"
msgstr "if/else 문장은 조건적으로 두 개의 문장들을 evaluate합니다. evaluate되려면 조건이 있는데, 만약 값이 TRUE이면 첫번째 문장이 evaluate됩니다; 그렇지 않으면 두번째 문장이 evaluate됩니다. if/else 문장은 선택된 문장의 값을 그의 값인 것 처럼 return합니다. 공식적인 syntax는 다음과 같습니다. "

#. type: example
#: R-lang.texi:1299
#, no-wrap
msgid ""
"if ( @var{statement1} )\n"
"    @var{statement2}\n"
"else\n"
"    @var{statement3}\n"
msgstr ""

#. type: Plain text
#: R-lang.texi:1310
msgid "First, @var{statement1} is evaluated to yield @var{value1}.  If @var{value1} is a logical vector with first element @code{TRUE} then @var{statement2} is evaluated.  If the first element of @var{value1} is @code{FALSE} then @var{statement3} is evaluated.  If @var{value1} is a numeric vector then @var{statement3} is evaluated when the first element of @var{value1} is zero and otherwise @var{statement2} is evaluated.  Only the first element of @var{value1} is used.  All other elements are ignored.  If @var{value1} has any type other than a logical or a numeric vector an error is signalled."
msgstr "첫 째로, statement1은 value1을 산추하기위해 evaluate됩니다. 만약 value1이 첫 번째element가 TRUE인 logical 벡터이면 statement2가evaluate됩니다. 만약 value1의 첫 번째 element가 FAULSE이면 statement3가 evaluate됩니다. 만약 value1이 숫자 벡터이면 value1의 첫 번째 element가 제로일 때 statement3이 evaluate되고 그렇지 않으면 statment2가 evaluate됩니다. Value1의 첫 번째 element만이 사용됩니다. 다른 모든 element들은 무시됩니다. 만약 value1이 logical이나 숫자 벡터가 아닌 다른 종류이면 에러 신호가 보내질 것입니다."

#. type: Plain text
#: R-lang.texi:1315
msgid "@code{if}/@code{else} statements can be used to avoid numeric problems such as taking the logarithm of a negative number.  Because @code{if}/@code{else} statements are the same as other statements you can assign the value of them.  The two examples below are equivalent."
msgstr "If/else 문장들은 음수의 logarithm을 취하는 등의 숫자 문제들을 피하기위해 사용될 수도 있습니다. If/else 문장들은 다른 문장들과 같기 때문에 그들에게 값을 지정할 수 있습니다. 아래의 두 개의 예는 동일합니다. "

#. type: example
#: R-lang.texi:1319
#, no-wrap
msgid ""
"> if( any(x <= 0) ) y <- log(1+x) else y <- log(x)\n"
"> y <- if( any(x <= 0) ) log(1+x) else log(x)\n"
msgstr ""

#. type: Plain text
#: R-lang.texi:1329
msgid "The @code{else} clause is optional.  The statement @code{if(any(x <= 0))  x <- x[x <= 0]} is valid.  When the @code{if} statement is not in a block the @code{else}, if present, must appear on the same line as the end of @var{statement2}.  Otherwise the new line at the end of @var{statement2} completes the @code{if} and yields a syntactically complete statement that is evaluated.  A simple solution is to use a compound statement wrapped in braces, putting the @code{else} on the same line as the closing brace that marks the end of the statement."
msgstr "else 절은 선택사항입니다. if(any(x <= 0)) x <- x[x <= 0]문장은 유효합니다. If 문장이 else에서 막히지 않았을 때, 만약 존재한다면, statement2의 끝에서 처럼 같은 줄에 나타나야만 합니다. 그렇지 않으면 statement2 끝의 새로운 줄은 if를 완성할 것이고 evaluate이 된 syntactically하게 완성된 문장을 산출 할 것입니다. 간단한 해결책은 else를 문장의 끝을 나타내는 끝마치는 중괄호와 같은 줄에 넣고, 중괄호들 안에 둘러싸인 조합된 문장을 사용하는 것입니다. "

#. type: Plain text
#: R-lang.texi:1331
msgid "@code{if}/@code{else} statements can be nested."
msgstr "If/else 문장들은 nested될 수 있습니다."

#. type: example
#: R-lang.texi:1341
#, no-wrap
msgid ""
"if ( @var{statement1} ) @{\n"
"    @var{statement2}\n"
"@} else if ( @var{statement3} ) @{\n"
"    @var{statement4}\n"
"@} else if ( @var{statement5} ) @{\n"
"    @var{statement6}\n"
"@} else\n"
"    @var{statement8}\n"
msgstr ""

#. type: Plain text
#: R-lang.texi:1347
msgid "One of the even numbered statements will be evaluated and the resulting value returned.  If the optional @code{else} clause is omitted and all the odd numbered @var{statement}s evaluate to @code{FALSE} no statement will be evaluated and @code{NULL} is returned."
msgstr "짝수 숫자의 문장들 중 하나는 evaluate될 것이고 값을 return하는 결과를 일으킬 것입니다. 만약 선택사항인 else절이 생략되고 모든 홀수 숫자의 문장들이 FALSE로 evaluate된다면, 아무런 문장도 evaluate되지 않을 것이고 NULL이 return됩니다. "

#. type: Plain text
#: R-lang.texi:1355
msgid "The odd numbered @var{statement}s are evaluated, in order, until one evaluates to @code{TRUE} and then the associated even numbered @var{statement} is evaluated.  In this example, @var{statement6} will only be evaluated if @var{statement1} is @code{FALSE} and @var{statement3} is @code{FALSE} and @var{statement5} is @code{TRUE}.  There is no limit to the number of @code{else if} clauses that are permitted."
msgstr "홀수 숫자의 문장들은 TRUE일 때 까지 순서대로 evaluate되고 그런 다음 연관된 짝수 숫자의 문장들이 evaluate됩니다. 위의 예제에서, statement6는 statement1이 FALSE이고 statement3가 FALSE이고 statement5가 TRUE일 때만 evaluate됩니다. else if 절이 허용되는 갯 수의 제한은 없습니다. "

#. type: Plain text
#: R-lang.texi:1370
msgid "@R{} has three statements that provide explicit looping.@footnote{Looping is the repeated evaluation of a statement or block of statements.} They are @code{for}, @code{while} and @code{repeat}.  The two built-in constructs, @code{next} and @code{break}, provide additional control over the evaluation.  Each of the three statements returns the value of the last statement that was evaluated.  It is possible, although uncommon, to assign the result of one of these statements to a symbol.  @R{} provides other functions for implicit looping such as @code{tapply}, @code{apply}, and @code{lapply}.  In addition many operations, especially arithmetic ones, are vectorized so you may not need to use a loop."
msgstr "R은 명쾌한 looping을 제공하는 세 가지 statement들을 가지고 있습니다. 그들은 for, while, 그리고 repeat입니다. 두 개의 built-in 구성들, next와 break,는 evaluation에 대한 추가적인 컨트롤을 제공합니다. 각각의 세 statement들은 evaluate된 마지막 statetment의 값을 return합니다. 흔하지는 않지만, statement들 중 하나의 결과를 symbol에 지정하는 것이 가능합니다. R은 tapply, apply, 그리고 lapply와 같은 함축적인 looing들을 위한 다른 function들을 제공합니다. 추가적으로, 많은 operation들, 특히 산술적인것들,은 벡터화되기 때문에 loopd을 사용하지 않아도 될지도 모릅니다. "

#. type: Plain text
#: R-lang.texi:1373
msgid "There are two statements that can be used to explicitly control looping.  They are @code{break} and @code{next}."
msgstr "명쾨하게 looping을 컨트롤하는데 사용되어 질 수 있는 두 개의 statement들이 있습니다. 그들은 break와 next입니다."

#. type: findex
#: R-lang.texi:1373
#, no-wrap
msgid "break"
msgstr ""

#. type: findex
#: R-lang.texi:1374
#, no-wrap
msgid "next"
msgstr ""

#. type: Plain text
#: R-lang.texi:1380
msgid "The @code{break} statement causes an exit from the innermost loop that is currently being executed.  The @code{next} statement immediately causes control to return to the start of the loop.  The next iteration of the loop (if there is one) is then executed.  No statement below @code{next} in the current loop is evaluated."
msgstr "break statement는 현재 실행되고있는 가장 안쪽의 loop에서부터의 exit을 바로하게하는 원인입니다. next statement는 loop의 시작으로 return하기위한 컨트롤을 바로 일으킵니다. loop의 다음 반복이 (만약에 있다면) 그 다음에 execute됩니다. 현재 loop안의 next아래의 statement는 evaluate되지 않습니다. "

#. type: Plain text
#: R-lang.texi:1383
msgid "The value returned by a loop statement is always @code{NULL} and is returned invisibly."
msgstr "Loop statement에 의해 return된 값은 항상 NULL이고 보이지 않게 return 됩니다."

#. type: Plain text
#: R-lang.texi:1392
msgid "The @code{repeat} statement causes repeated evaluation of the body until a break is specifically requested.  This means that you need to be careful when using @code{repeat} because of the danger of an infinite loop.  The syntax of the @code{repeat} loop is"
msgstr "repeat statement는 break가 특별히 요청되기 전 까지 body의 evaluation를 반복하는 것을 초래합니다. 이는 무한 loop의 위험때문에 repeat을 사용할 때 조심해야 한다는 뜻입니다. repeat loop의 Syntax는 다음과 같습니다."

#. type: example
#: R-lang.texi:1395
#, no-wrap
msgid "repeat @var{statement}\n"
msgstr ""

#. type: Plain text
#: R-lang.texi:1400
msgid "When using @code{repeat}, @var{statement} must be a block statement.  You need to both perform some computation and test whether or not to break from the loop and usually this requires two statements."
msgstr "repeat을 사용할 때, statement는 block statement이어야만 합니다. loop에서부터 break를 하던지 하지 않던지 간에 몇몇의 계산과 테스트 둘 다를 수행해야하고 보통 이는 두 개의 statement들을 필요로 합니다. "

#. type: Plain text
#: R-lang.texi:1407
msgid "The @code{while} statement is very similar to the @code{repeat} statement.  The syntax of the @code{while} loop is"
msgstr "while statement는 repeat statement와 매우 유사합니다. while loop의 syntax는 다음과 같습니다."

#. type: example
#: R-lang.texi:1410
#, no-wrap
msgid "while ( @var{statement1} ) @var{statement2}\n"
msgstr ""

#. type: Plain text
#: R-lang.texi:1416
msgid "where @var{statement1} is evaluated and if its value is @code{TRUE} then @var{statement2} is evaluated.  This process continues until @var{statement1} evaluates to @code{FALSE}."
msgstr "statement1이 evaluate되고 만약 값이 TRUE라면 statement2가 evaluate됩니다. 이 프로세스는 statement1이 FALSE로 evaluate될 때까지 계속됩니다. "

#. type: Plain text
#: R-lang.texi:1422
msgid "The syntax of the @code{for} loop is"
msgstr "for loop의 syntax는 아래와 같습니다. "

#. type: example
#: R-lang.texi:1426
#, no-wrap
msgid ""
"for ( @var{name} in @var{vector} )\n"
"   @var{statement1}\n"
msgstr ""

#. type: Plain text
#: R-lang.texi:1435
msgid "where @var{vector} can be either a vector or a list.  For each element in @var{vector} the variable @var{name} is set to the value of that element and @var{statement1} is evaluated.  A side effect is that the variable @var{name} still exists after the loop has concluded and it has the value of the last element of @var{vector} that the loop was evaluated for."
msgstr "vector 은 벡터 혹은 목록이 될 수 있습니다. vector 안의 각각의 element에 간해 name 값은 element의 값으로 설정되고 statement1가 evaluate됩니다. 부작용은 loop이 끝나고도 name 값이 계속 존재하고 이가 loop이 evaluate된vector의 마지막 element의 값을 가지고 있다는 것입니다. "

#. type: Plain text
#: R-lang.texi:1443
msgid "Technically speaking, @code{switch} is just another function, but its semantics are close to those of control structures of other programming languages."
msgstr ""

#. type: Plain text
#: R-lang.texi:1445
msgid "The syntax is"
msgstr ""

#. type: example
#: R-lang.texi:1448
#, no-wrap
msgid "switch (@var{statement}, @var{list})\n"
msgstr ""

#. type: Plain text
#: R-lang.texi:1456
msgid "where the elements of @var{list} may be named.  First, @var{statement} is evaluated and the result, @var{value}, obtained.  If @var{value} is a number between 1 and the length of @var{list} then the corresponding element of @var{list} is evaluated and the result returned.  If @var{value} is too large or too small @code{NULL} is returned."
msgstr ""

#. type: example
#: R-lang.texi:1465
#, no-wrap
msgid ""
"> x <- 3\n"
"> switch(x, 2+2, mean(1:10), rnorm(5))\n"
"[1]  2.2903605  2.3271663 -0.7060073  1.3622045 -0.2892720\n"
"> switch(2, 2+2, mean(1:10), rnorm(5))\n"
"[1] 5.5\n"
"> switch(6, 2+2, mean(1:10), rnorm(5))\n"
"NULL\n"
msgstr ""

#. type: Plain text
#: R-lang.texi:1471
msgid "If @var{value} is a character vector then the element of @samp{...} with a name that exactly matches @var{value} is evaluated.  If there is no match a single unnamed argument will be used as a default.  If no default is specified, @code{NULL} is returned."
msgstr ""

#. type: example
#: R-lang.texi:1479
#, no-wrap
msgid ""
"> y <- \"fruit\"\n"
"> switch(y, fruit = \"banana\", vegetable = \"broccoli\", \"Neither\")\n"
"[1] \"banana\"\n"
"> y <- \"meat\"\n"
"> switch(y, fruit = \"banana\", vegetable = \"broccoli\", \"Neither\")\n"
"[1] \"Neither\"\n"
msgstr ""

#. type: Plain text
#: R-lang.texi:1483
msgid "A common use of @code{switch} is to branch according to the character value of one of the arguments to a function."
msgstr ""

#. type: example
#: R-lang.texi:1498
#, no-wrap
msgid ""
"> centre <- function(x, type) @{\n"
"+ switch(type,\n"
"+        mean = mean(x),\n"
"+        median = median(x),\n"
"+        trimmed = mean(x, trim = .1))\n"
"+ @}\n"
"> x <- rcauchy(10)\n"
"> centre(x, \"mean\")\n"
"[1] 0.8760325\n"
"> centre(x, \"median\")\n"
"[1] 0.5360891\n"
"> centre(x, \"trimmed\")\n"
"[1] 0.6086504\n"
msgstr ""

#. type: Plain text
#: R-lang.texi:1502
msgid "@code{switch} returns either the value of the statement that was evaluated or @code{NULL} if no statement was evaluated."
msgstr ""

#. type: Plain text
#: R-lang.texi:1507
msgid "To choose from a list of alternatives that already exists @code{switch} may not be the best way to select one for evaluation.  It is often better to use @code{eval} and the subset operator, @code{[[}, directly via @code{eval(x[[condition]])}."
msgstr ""

#. type: node
#: R-lang.texi:1516
#: R-lang.texi:1522
#: R-lang.texi:1523
#: R-lang.texi:1533
#, no-wrap
msgid "Recycling rules"
msgstr ""

#. type: node
#: R-lang.texi:1516
#: R-lang.texi:1522
#: R-lang.texi:1533
#: R-lang.texi:1534
#: R-lang.texi:1541
#, no-wrap
msgid "Propagation of names"
msgstr ""

#. type: node
#: R-lang.texi:1516
#: R-lang.texi:1533
#: R-lang.texi:1541
#: R-lang.texi:1542
#: R-lang.texi:1547
#, no-wrap
msgid "Dimensional attributes"
msgstr ""

#. type: subsection
#: R-lang.texi:1516
#: R-lang.texi:1541
#: R-lang.texi:1547
#: R-lang.texi:1548
#, no-wrap
msgid "NA handling"
msgstr ""

#. type: Plain text
#: R-lang.texi:1521
msgid "In this section, we discuss the finer points of the rules that apply to basic operation like addition or multiplication of two vectors or matrices."
msgstr ""

#. type: Plain text
#: R-lang.texi:1529
msgid "If one tries to add two structures with a different number of elements, then the shortest is recycled to length of longest.  That is, if for instance you add @code{c(1, 2, 3)} to a six-element vector then you will really add @code{c(1, 2, 3, 1, 2, 3)}.  If the length of the longer vector is not a multiple of the shorter one, a warning is given."
msgstr ""

#. type: Plain text
#: R-lang.texi:1532
msgid "As from @R{} 1.4.0, any arithmetic operation involving a zero-length vector has a zero-length result."
msgstr ""

#. type: Plain text
#: R-lang.texi:1539
msgid "propagation of names (first one wins, I think - also if it has no names?? ---- first one *with names* wins, recycling causes shortest to lose names)"
msgstr ""

#. type: Plain text
#: R-lang.texi:1546
msgid "(matrix+matrix, dimensions must match. vector+matrix: first recycle, then check if dims fit, error if not)"
msgstr ""

#. type: Plain text
#: R-lang.texi:1554
msgid "Missing values in the statistical sense, that is, variables whose value is not known, have the value @code{NA}. This should not be confused with the @code{missing} property for a function argument that has not been supplied (see @ref{Arguments})."
msgstr ""

#. type: findex
#: R-lang.texi:1554
#, no-wrap
msgid "missing"
msgstr ""

#. type: findex
#: R-lang.texi:1555
#: R-lang.texi:1741
#, no-wrap
msgid "NA"
msgstr ""

#. type: findex
#: R-lang.texi:1556
#, no-wrap
msgid "NaN"
msgstr ""

#. type: Plain text
#: R-lang.texi:1565
msgid "As the elements of an atomic vector must be of the same type there are multiple types of @code{NA} values.  There is one case where this is particularly important to the user.  The default type of @code{NA} is @code{logical}, unless coerced to some other type, so the appearance of a missing value may trigger logical rather than numeric indexing (see @ref{Indexing} for details)."
msgstr ""

#. type: Plain text
#: R-lang.texi:1572
msgid "Numeric and logical calculations with @code{NA} generally return @code{NA}. In cases where the result of the operation would be the same for all possible values the @code{NA} could take, the operation may return this value. In particular, @samp{FALSE & NA} is @code{FALSE}, @samp{TRUE | NA} is @code{TRUE}.  @code{NA} is not equal to any other value or to itself; testing for @code{NA} is done using @code{is.na}."
msgstr ""

#. type: findex
#: R-lang.texi:1572
#, no-wrap
msgid "is.na"
msgstr ""

#. type: Plain text
#: R-lang.texi:1575
msgid "However, an @code{NA} value will match another @code{NA} value in @code{match}."
msgstr ""

#. type: Plain text
#: R-lang.texi:1580
msgid "Numeric calculations whose result is undefined, such as @samp{0/0}, produce the value @code{NaN}.  This exists only in the @code{double} type and for real or imaginary components of the complex type.  The function @code{is.nan} is provided to check specifically for"
msgstr ""

#. type: findex
#: R-lang.texi:1580
#, no-wrap
msgid "is.nan"
msgstr ""

#. type: Plain text
#: R-lang.texi:1582
msgid "@code{NaN}, @code{is.na} also returns @code{TRUE} for @code{NaN}."
msgstr ""

#. type: Plain text
#: R-lang.texi:1589
msgid "Coercing @code{NaN} to logical or integer type gives an @code{NA} of the appropriate type, but coercion to character gives the string @code{\"NaN\"}.  @code{NaN} values are incomparable so tests of equality or collation involving @code{NaN} will result in @code{NA}.  They are regarded as matching any @code{NaN} value (and no other value, not even @code{NA}) by @code{match}."
msgstr ""

#. type: Plain text
#: R-lang.texi:1594
msgid "The @code{NA} of character type is as from R 1.5.0 distinct from the string @code{\"NA\"}.  Programmers who need to specify an explicit string @code{NA} should use @samp{as.character(NA)} rather than @code{\"NA\"}, or set elements to @code{NA} using @code{is.na<-}."
msgstr ""

#. type: Plain text
#: R-lang.texi:1601
msgid "As from @R{} 2.5.0 there are constants @code{NA_integer_}, @code{NA_real_}, @code{NA_complex_} and @code{NA_character_} which will generate (in the parser) an @code{NA} value of the appropriate type, and will be used in deparsing when it is not otherwise possible to identify the type of an @code{NA} (and the @code{control} options ask for this to be done)."
msgstr ""

#. type: Plain text
#: R-lang.texi:1603
msgid "There is no @code{NA} value for raw vectors."
msgstr ""

#. type: Plain text
#: R-lang.texi:1615
msgid "@R{} contains several constructs which allow access to individual elements or subsets through indexing operations.  In the case of the basic vector types one can access the i-th element using @code{x[i]}, but there is also indexing of lists, matrices, and multi-dimensional arrays.  There are several forms of indexing in addition to indexing with a single integer.  Indexing can be used both to extract part of an object and to replace parts of an object (or to add parts)."
msgstr ""

#. type: Plain text
#: R-lang.texi:1618
msgid "@R{} has three basic indexing operators, with syntax displayed by the following examples"
msgstr ""

#. type: example
#: R-lang.texi:1626
#, no-wrap
msgid ""
"x[i]\n"
"x[i, j]\n"
"x[[i]]\n"
"x[[i, j]]\n"
"x$a\n"
"x$\"a\"\n"
msgstr ""

#. type: findex
#: R-lang.texi:1627
#: R-lang.texi:4679
#, no-wrap
msgid "["
msgstr ""

#. type: findex
#: R-lang.texi:1628
#: R-lang.texi:4680
#, no-wrap
msgid "[["
msgstr ""

#. type: Plain text
#: R-lang.texi:1638
msgid "For vectors and matrices the @code{[[} forms are rarely used, although they have some slight semantic differences from the @code{[} form (e.g.  it drops any @code{names} or @code{dimnames} attribute, and that partial matching is used for character indices).  When indexing multi-dimensional structures with a single index, @code{x[[i]]} or @code{x[i]} will return the @code{i}th sequential element of @code{x}."
msgstr ""

#. type: Plain text
#: R-lang.texi:1641
msgid "For lists, one generally uses @code{[[} to select any single element, whereas @code{[} returns a list of the selected elements."
msgstr ""

#. type: Plain text
#: R-lang.texi:1648
msgid "The @code{[[} form allows only a single element to be selected using integer or character indices, whereas @code{[} allows indexing by vectors.  Note though that for a list or other recursive object, the index can be a vector and each element of the vector is applied in turn to the list, the selected component, the selected component of that component, and so on. The result is still a single element."
msgstr ""

#. type: Plain text
#: R-lang.texi:1655
msgid "The form using @code{$} applies to recursive objects such as lists and pairlists.  It allows only a literal character string or a symbol as the index.  That is, the index is not computable: for cases where you need to evaluate an expression to find the index, use @code{x[[expr]]}.  When @code{$} is applied to a non-recursive object the result used to be always @code{NULL}: as from @R{} 2.6.0 this is an error."
msgstr ""

#. type: node
#: R-lang.texi:1661
#: R-lang.texi:1663
#: R-lang.texi:1664
#: R-lang.texi:1753
#, no-wrap
msgid "Indexing by vectors"
msgstr ""

#. type: node
#: R-lang.texi:1661
#: R-lang.texi:1663
#: R-lang.texi:1753
#: R-lang.texi:1754
#: R-lang.texi:1829
#, no-wrap
msgid "Indexing matrices and arrays"
msgstr ""

#. type: node
#: R-lang.texi:1661
#: R-lang.texi:1753
#: R-lang.texi:1829
#: R-lang.texi:1830
#: R-lang.texi:1857
#, no-wrap
msgid "Indexing other structures"
msgstr ""

#. type: subsection
#: R-lang.texi:1661
#: R-lang.texi:1829
#: R-lang.texi:1857
#: R-lang.texi:1858
#, no-wrap
msgid "Subset assignment"
msgstr ""

#. type: Plain text
#: R-lang.texi:1670
msgid "@R{} allows some powerful constructions using vectors as indices.  We shall discuss indexing of simple vectors first.  For simplicity, assume that the expression is @code{x[i]}.  Then the following possibilities exist according to the type of @code{i}."
msgstr ""

#. type: itemize
#: R-lang.texi:1678
msgid "@strong{Integer}.  All elements of @code{i} must have the same sign.  If they are positive, the elements of @code{x} with those index numbers are selected.  If @code{i} contains negative elements, all elements except those indicated are selected."
msgstr ""

#. type: itemize
#: R-lang.texi:1684
msgid "If @code{i} is positive and exceeds @code{length(x)} then the corresponding selection is @code{NA}.  Negative out of bounds values for @code{i} are silently disregarded since R version 2.6.0, S compatibly, as they mean to drop non-existing elements and that is an empty operation (``no-op'')."
msgstr ""

#. type: itemize
#: R-lang.texi:1690
msgid "A special case is the zero index, which has null effects: @code{x[0]} is an empty vector and otherwise including zeros among positive or negative indices has the same effect as if they were omitted."
msgstr ""

#. type: itemize
#: R-lang.texi:1694
msgid "@strong{Other numeric}.  Non-integer values are converted to integer (by truncation towards zero) before use."
msgstr ""

#. type: itemize
#: R-lang.texi:1703
msgid "@strong{Logical}.  The indexing @code{i} should generally have the same length as @code{x}.  If it is shorter, then its elements will be recycled as discussed in @ref{Elementary arithmetic operations}.  If it is longer, then @code{x} is conceptually extended with @code{NA}s. The selected values of @code{x} are those for which @code{i} is @code{TRUE}."
msgstr ""

#. type: cindex
#: R-lang.texi:1704
#, no-wrap
msgid "partial matching"
msgstr ""

#. type: itemize
#: R-lang.texi:1720
msgid "@strong{Character}.  The strings in @code{i} are matched against the names attribute of @code{x} and the resulting integers are used.  For @code{[[} and @code{$} partial matching is used if exact matching fails, so @code{x$aa} will match @code{x$aabb} if @code{x} does not contain a component named @code{\"aa\"} and @code{\"aabb\"} is the only name which has prefix @code{\"aa\"}.  For @code{[[}, partial matching can be controlled via the @code{exact} argument which defaults to @code{NA} indicating that partial matching is allowed, but should result in a warning when it occurs.  Setting @code{exact} to @code{TRUE} prevents partial matching from occurring, a @code{FALSE} value allows it and does not issue any warnings.  Note that @code{[} always requires an exact match.  The string @code{\"\"} is treated specially: it indicates `no name' and matches no element (not even those without a name).  Note that partial matching is only used when extracting and not when replacing."
msgstr ""

#. type: itemize
#: R-lang.texi:1725
msgid "@strong{Factor}.  The result is identical to @code{x[as.integer(i)]}.  The factor levels are never used.  If so desired, use @code{x[as.character(i)]} or a similar construction."
msgstr ""

#. type: itemize
#: R-lang.texi:1731
msgid "@strong{Empty}.  The expression @code{x[]} returns @code{x}, but drops ``irrelevant'' attributes from the result.  Only @code{names} and in multi-dimensional arrays @code{dim} and @code{dimnames} attributes are retained."
msgstr ""

#. type: itemize
#: R-lang.texi:1734
msgid "@strong{NULL}.  This is treated as if it were @code{integer(0)}."
msgstr ""

#. type: Plain text
#: R-lang.texi:1741
msgid "Indexing with a missing (i.e.@: @code{NA}) value gives an @code{NA} result.  This rule applies also to the case of logical indexing, i.e.@: the elements of @code{x} that have an @code{NA} selector in @code{i} get included in the result, but their value will be @code{NA}."
msgstr ""

#. type: Plain text
#: R-lang.texi:1749
msgid "Notice however, that there are different modes of @code{NA}---the literal constant is of mode @code{\"logical\"}, but it is frequently automatically coerced to other types.  One effect of this is that @code{x[NA]} has the length of @code{x}, but @code{x[c(1, NA)]} has length 2.  That is because the rules for logical indices apply in the former case, but those for integer indices in the latter."
msgstr ""

#. type: Plain text
#: R-lang.texi:1752
msgid "Indexing with @code{[} will also carry out the relevant subsetting of any names attributes."
msgstr ""

#. type: Plain text
#: R-lang.texi:1761
msgid "Subsetting multi-dimensional structures generally follows the same rules as single-dimensional indexing for each index variable, with the relevant component of @code{dimnames} taking the place of @code{names}.  A couple of special rules apply, though:"
msgstr ""

#. type: Plain text
#: R-lang.texi:1768
msgid "Normally, a structure is accessed using the number of indices corresponding to its dimension.  It is however also possible to use a single index in which case the @code{dim} and @code{dimnames} attributes are disregarded and the result is effectively that of @code{c(m)[i]}.  Notice that @code{m[1]} is usually very different from @code{m[1, ]} or @code{m[, 1]}."
msgstr ""

#. type: Plain text
#: R-lang.texi:1775
msgid "It is possible to use a matrix of integers as an index.  In this case, the number of columns of the matrix should match the number of dimensions of the structure, and the result will be a vector with length as the number of rows of the matrix.  The following example shows how to extract the elements @code{m[1, 1]} and @code{m[2, 2]} in one operation."
msgstr ""

#. type: example
#: R-lang.texi:1789
#, no-wrap
msgid ""
"> m <- matrix(1:4, 2)\n"
"> m\n"
"     [,1] [,2]\n"
"[1,]    1    3\n"
"[2,]    2    4\n"
"> i <- matrix(c(1, 1, 2, 2), 2, byrow = TRUE)\n"
"> i\n"
"     [,1] [,2]\n"
"[1,]    1    1\n"
"[2,]    2    2\n"
"> m[i]\n"
"[1] 1 4\n"
msgstr ""

#. type: Plain text
#: R-lang.texi:1796
msgid "Indexing matrices may not contain negative indices.  @code{NA} and zero values are allowed: rows in an index matrix containing a zero are ignored, whereas rows containing an @code{NA} produce an @code{NA} in the result."
msgstr ""

#. type: Plain text
#: R-lang.texi:1798
msgid "Both in the case of using a single"
msgstr ""

#. type: Plain text
#: R-lang.texi:1801
msgid "index and in matrix indexing, a @code{names} attribute is used if present, as had the structure been one-dimensional."
msgstr ""

#. type: Plain text
#: R-lang.texi:1816
msgid "If an indexing operation causes the result to have one of its extents of length one, as in selecting a single slice of a three-dimensional matrix with (say) @code{m[2, , ]}, the corresponding dimension is generally dropped from the result.  If a single-dimensional structure results, a vector is obtained.  This is occasionally undesirable and can be turned off by adding the @samp{drop = FALSE} to the indexing operation.  Notice that this is an additional argument to the @code{[} function and doesn't add to the index count.  Hence the correct way of selecting the first row of a matrix as a @math{1} by @math{n} matrix is @code{m[1, , drop = FALSE]}.  Forgetting to disable the dropping feature is a common cause of failure in general subroutines where an index occasionally, but not usually has length one.  This rule still applies to a one-dimensional array, where any subsetting will give a vector result unless @samp{drop = FALSE} is used."
msgstr ""

#. type: Plain text
#: R-lang.texi:1824
msgid "Notice that vectors are distinct from one-dimensional arrays in that the latter have @code{dim} and @code{dimnames} attributes (both of length one).  One-dimensional arrays are not easily obtained from subsetting operations but they can be constructed explicitly and are returned by @code{table}.  This is sometimes useful because the elements of the @code{dimnames} list may themselves be named, which is not the case for the @code{names} attribute."
msgstr ""

#. type: Plain text
#: R-lang.texi:1828
msgid "Some operations such as @code{m[FALSE, ]} result in structures in which a dimension has zero extent.  @R{} generally tries to handle these structures sensibly."
msgstr ""

#. type: Plain text
#: R-lang.texi:1842
msgid "The operator @code{[} is a generic function which allows class methods to be added, and the @code{$} and @code{[[} operators likewise.  Thus, it is possible to have user-defined indexing operations for any structure.  Such a function, say @code{[.foo} is called with a set of arguments of which the first is the structure being indexed and the rest are the indices.  In the case of @code{$}, the index argument is of mode @code{\"symbol\"} even when using the @code{x$\"abc\"} form.  It is important to be aware that class methods do not necessarily behave in the same way as the basic methods, for example with respect to partial matching."
msgstr ""

#. type: Plain text
#: R-lang.texi:1851
msgid "The most important example of a class method for @code{[} is that used for data frames.  It is not described in detail here (see the help page for @code{[.data.frame}, but in broad terms, if two indices are supplied (even if one is empty) it creates matrix-like indexing for a structure that is basically a list of vectors of the same length.  If a single index is supplied, it is interpreted as indexing the list of columns---in that case the @code{drop} argument is ignored, with a warning."
msgstr ""

#. type: Plain text
#: R-lang.texi:1855
msgid "The basic operators @code{$} and @code{[[} can be applied to environments.  Only character indices are allowed and no partial matching is done."
msgstr ""

#. type: cindex
#: R-lang.texi:1860
#, no-wrap
msgid "complex assignment"
msgstr ""

#. type: Plain text
#: R-lang.texi:1864
msgid "Assignment to subsets of a structure is a special case of a general mechanism for complex assignment:"
msgstr ""

#. type: example
#: R-lang.texi:1866
#, no-wrap
msgid "x[3:5] <- 13:15\n"
msgstr ""

#. type: Plain text
#: R-lang.texi:1868
msgid "The result of this command is as if the following had been executed"
msgstr ""

#. type: example
#: R-lang.texi:1872
#, no-wrap
msgid ""
"`*tmp*` <- x\n"
"x <- \"[<-\"(`*tmp*`, 3:5, value=13:15)\n"
"rm(`*tmp*`)\n"
msgstr ""

#. type: Plain text
#: R-lang.texi:1879
msgid "Note that the index is first converted to a numeric index and then the elements are replaced sequentially along the numeric index, as if a @code{for} loop had been used.  Any existing variable called @code{`*tmp*`} will be overwritten and deleted, and this variable name should not be used in code."
msgstr ""

#. type: Plain text
#: R-lang.texi:1884
msgid "The same mechanism can be applied to functions other than @code{[}.  The replacement function has the same name with @code{<-} pasted on.  Its last argument, which must be called @code{value}, is the new value to be assigned.  For example,"
msgstr ""

#. type: example
#: R-lang.texi:1886
#, no-wrap
msgid "names(x) <- c(\"a\",\"b\")\n"
msgstr ""

#. type: Plain text
#: R-lang.texi:1888
#: R-lang.texi:1899
#: R-lang.texi:1913
#: R-lang.texi:1956
msgid "is equivalent to"
msgstr ""

#. type: example
#: R-lang.texi:1892
#, no-wrap
msgid ""
"`*tmp*` <- x\n"
"x <- \"names<-\"(`*tmp*`, value=c(\"a\",\"b\"))\n"
"rm(`*tmp*`)\n"
msgstr ""

#. type: Plain text
#: R-lang.texi:1895
msgid "Nesting of complex assignments is evaluated recursively"
msgstr ""

#. type: example
#: R-lang.texi:1897
#, no-wrap
msgid "names(x)[3] <- \"Three\"\n"
msgstr ""

#. type: example
#: R-lang.texi:1903
#, no-wrap
msgid ""
"`*tmp*` <- x\n"
"x <- \"names<-\"(`*tmp*`, value=\"[<-\"(names(`*tmp*`), 3, value=\"Three\"))\n"
"rm(`*tmp*`)\n"
msgstr ""

#. type: Plain text
#: R-lang.texi:1909
msgid "Complex assignments in the enclosing environment (using @code{<<-}) are also permitted:"
msgstr ""

#. type: example
#: R-lang.texi:1911
#, no-wrap
msgid "names(x)[3] <<- \"Three\"\n"
msgstr ""

#. type: example
#: R-lang.texi:1918
#, no-wrap
msgid ""
"`*tmp*` <<- get(x, envir=parent.env(), inherits=TRUE)\n"
"names(`*tmp*`)[3] <- \"Three\"\n"
"x <<- `*tmp*`\n"
"rm(`*tmp*`)\n"
msgstr ""

#. type: Plain text
#: R-lang.texi:1920
msgid "and also to"
msgstr ""

#. type: example
#: R-lang.texi:1924
#, no-wrap
msgid ""
"`*tmp*` <- get(x,envir=parent.env(), inherits=TRUE)\n"
"x <<- \"names<-\"(`*tmp*`, value=\"[<-\"(names(`*tmp*`), 3, value=\"Three\"))\n"
"rm(`*tmp*`)\n"
msgstr ""

#. type: Plain text
#: R-lang.texi:1927
msgid "Only the target variable is evaluated in the enclosing environment, so"
msgstr ""

#. type: example
#: R-lang.texi:1935
#, no-wrap
msgid ""
"e<-c(a=1,b=2)\n"
"i<-1\n"
"local(@{\n"
"   e <- c(A=10,B=11)\n"
"   i <-2\n"
"   e[i] <<- e[i]+1\n"
"@})\n"
msgstr ""

#. type: Plain text
#: R-lang.texi:1939
msgid "uses the local value of @code{i} on both the LHS and RHS, and the local value of @code{e} on the RHS of the superassignment statement.  It sets @code{e} in the outer environment to"
msgstr ""

#. type: example
#: R-lang.texi:1942
#, no-wrap
msgid ""
" a  b \n"
" 1 12\n"
msgstr ""

#. type: Plain text
#: R-lang.texi:1944
msgid "That is, the superassignment is equivalent to the four lines"
msgstr ""

#. type: example
#: R-lang.texi:1949
#, no-wrap
msgid ""
"`*tmp*` <- get(e, envir=parent.env(), inherits=TRUE)\n"
"`*tmp*`[i] <- e[i]+1\n"
"e <<- `*tmp*`\n"
"rm(`*tmp*`)\n"
msgstr ""

#. type: Plain text
#: R-lang.texi:1952
msgid "Similarly"
msgstr ""

#. type: example
#: R-lang.texi:1954
#, no-wrap
msgid "x[is.na(x)] <<- 0\n"
msgstr ""

#. type: example
#: R-lang.texi:1961
#, no-wrap
msgid ""
"`*tmp*` <- get(x,envir=parent.env(), inherits=TRUE)\n"
"`*tmp*`[is.na(x)] <- 0\n"
"x <<- `*tmp*`\n"
"rm(`*tmp*`)\n"
msgstr ""

#. type: Plain text
#: R-lang.texi:1963
msgid "and not to"
msgstr ""

#. type: example
#: R-lang.texi:1968
#, no-wrap
msgid ""
"`*tmp*` <- get(x,envir=parent.env(), inherits=TRUE)\n"
"`*tmp*`[is.na(`*tmp*`)] <- 0\n"
"x <<- `*tmp*`\n"
"rm(`*tmp*`)\n"
msgstr ""

#. type: Plain text
#: R-lang.texi:1974
msgid "These two candidate interpretations differ only if there is also a local variable @code{x}.  It is a good idea to avoid having a local variable with the same name as the target variable of a superassignment.  As this case was handled incorrectly in versions 1.9.1 and earlier there must not be a serious need for such code."
msgstr ""

#. type: cindex
#: R-lang.texi:2032
#: R-lang.texi:2118
#: R-lang.texi:2488
#: R-lang.texi:2505
#: R-lang.texi:2565
#: R-lang.texi:3461
#, no-wrap
msgid "scope"
msgstr ""

#. type: Plain text
#: R-lang.texi:2038
msgid "Almost every programming language has a set of scoping rules, allowing the same name to be used for different objects.  This allows, e.g., a local variable in a function to have the same name as a global object."
msgstr ""

#. type: Plain text
#: R-lang.texi:2043
msgid "@R{} uses a @emph{lexical scoping} model, similar to languages like Pascal.  However, @R{} is a @emph{functional programming language} and allows dynamic creation and manipulation of functions and language objects, and has additional features reflecting this fact."
msgstr ""

#. type: node
#: R-lang.texi:2049
#: R-lang.texi:2051
#: R-lang.texi:2052
#: R-lang.texi:2063
#, no-wrap
msgid "Global environment"
msgstr ""

#. type: node
#: R-lang.texi:2049
#: R-lang.texi:2051
#: R-lang.texi:2063
#: R-lang.texi:2064
#: R-lang.texi:2105
#, no-wrap
msgid "Lexical environment"
msgstr ""

#. type: node
#: R-lang.texi:2049
#: R-lang.texi:2063
#: R-lang.texi:2105
#: R-lang.texi:2159
#, no-wrap
msgid "Stacks"
msgstr ""

#. type: subsection
#: R-lang.texi:2049
#: R-lang.texi:2105
#: R-lang.texi:2159
#: R-lang.texi:2160
#, no-wrap
msgid "Search path"
msgstr ""

#. type: Plain text
#: R-lang.texi:2055
msgid "The global"
msgstr ""

#. type: Plain text
#: R-lang.texi:2057
msgid "environment is the root of the user workspace.  An"
msgstr ""

#. type: Plain text
#: R-lang.texi:2062
msgid "assignment operation from the command line will cause the relevant object to belong to the global environment.  Its enclosing environment is the next environment on the search path, and so on back to the empty environment that is the enclosure of the base environment."
msgstr ""

#. type: Plain text
#: R-lang.texi:2067
msgid "Every call to a"
msgstr ""

#. type: Plain text
#: R-lang.texi:2069
msgid "function creates a"
msgstr ""

#. type: cindex
#: R-lang.texi:2069
#, no-wrap
msgid "frame"
msgstr ""

#. type: Plain text
#: R-lang.texi:2074
msgid "@emph{frame} which contains the local variables created in the function, and is evaluated in an environment, which in combination creates a new environment."
msgstr ""

#. type: Plain text
#: R-lang.texi:2078
msgid "Notice the terminology: A frame is a set of variables, an environment is a nesting of frames (or equivalently: the innermost frame plus the enclosing environment)."
msgstr ""

#. type: Plain text
#: R-lang.texi:2082
msgid "Environments may be assigned to variables or be contained in other objects.  However, notice that they are not standard objects---in particular, they are not copied on assignment."
msgstr ""

#. type: Plain text
#: R-lang.texi:2087
msgid "A closure (mode @code{\"function\"}) object will contain the environment in which it is created as part of its definition (By default.  The environment can be manipulated using @code{environment<-}).  When the function is subsequently called, its"
msgstr ""

#. type: cindex
#: R-lang.texi:2087
#: R-lang.texi:2096
#: R-lang.texi:2420
#, no-wrap
msgid "environment, evaluation"
msgstr ""

#. type: Plain text
#: R-lang.texi:2091
msgid "evaluation environment is created with the closure's environment as enclosure.  Notice that this is not necessarily the environment of the caller!"
msgstr ""

#. type: Plain text
#: R-lang.texi:2093
msgid "Thus, when a variable is requested inside a"
msgstr ""

#. type: Plain text
#: R-lang.texi:2096
msgid "function, it is first sought in the"
msgstr ""

#. type: Plain text
#: R-lang.texi:2104
msgid "evaluation environment, then in the enclosure, the enclosure of the enclosure, etc.; once the global environment or the environment of a package is reached, the search continues up the search path to the environment of the base package.  If the variable is not found there, the search will proceed next to the empty environment, and will fail."
msgstr ""

#. type: subsection
#: R-lang.texi:2106
#, no-wrap
msgid "The call stack"
msgstr ""

#. type: Plain text
#: R-lang.texi:2109
msgid "Every time a"
msgstr ""

#. type: Plain text
#: R-lang.texi:2116
msgid "function is invoked a new evaluation frame is created.  At any point in time during the computation the currently active environments are accessible through the @emph{call stack}.  Each time a function is invoked a special construct called a context is created internally and is placed on a list of contexts.  When a function has finished evaluating its context is removed from the call stack."
msgstr ""

#. type: Plain text
#: R-lang.texi:2118
msgid "Making variables defined higher up the call stack available is called"
msgstr ""

#. type: Plain text
#: R-lang.texi:2122
msgid "dynamic scope. The binding for a variable is then determined by the most recent (in time) definition of the variable.  This contradicts the default scoping rules in @R{}, which use the bindings in the"
msgstr ""

#. type: Plain text
#: R-lang.texi:2127
msgid "environment in which the function was defined (lexical scope). Some functions, particularly those that use and manipulate model formulas, need to simulate dynamic scope by directly accessing the call stack."
msgstr ""

#. type: Plain text
#: R-lang.texi:2129
msgid "Access to the"
msgstr ""

#. type: cindex
#: R-lang.texi:2129
#, no-wrap
msgid "call stack"
msgstr ""

#. type: Plain text
#: R-lang.texi:2132
msgid "call stack is provided through a family of functions which have names that start with @samp{sys.}.  They are listed briefly below."
msgstr ""

#. type: cindex
#: R-lang.texi:2133
#: R-lang.texi:2315
#: R-lang.texi:2455
#: R-lang.texi:2549
#: R-lang.texi:2835
#: R-lang.texi:2889
#: R-lang.texi:3444
#: R-lang.texi:3604
#, no-wrap
msgid "evaluation"
msgstr ""

#. type: item
#: R-lang.texi:2135
#, no-wrap
msgid "sys.call"
msgstr ""

#. type: table
#: R-lang.texi:2137
msgid "Get the call for the specified context."
msgstr ""

#. type: item
#: R-lang.texi:2137
#, no-wrap
msgid "sys.frame"
msgstr ""

#. type: table
#: R-lang.texi:2139
msgid "Get the evaluation frame for the specified context."
msgstr ""

#. type: item
#: R-lang.texi:2139
#, no-wrap
msgid "sys.nframe"
msgstr ""

#. type: table
#: R-lang.texi:2141
msgid "Get the environment frame for all active contexts."
msgstr ""

#. type: item
#: R-lang.texi:2141
#, no-wrap
msgid "sys.function"
msgstr ""

#. type: table
#: R-lang.texi:2143
msgid "Get the function being invoked in the specified context."
msgstr ""

#. type: item
#: R-lang.texi:2143
#, no-wrap
msgid "sys.parent"
msgstr ""

#. type: table
#: R-lang.texi:2145
msgid "Get the parent of the current function invocation."
msgstr ""

#. type: item
#: R-lang.texi:2145
#, no-wrap
msgid "sys.calls"
msgstr ""

#. type: table
#: R-lang.texi:2147
msgid "Get the calls for all the active contexts."
msgstr ""

#. type: item
#: R-lang.texi:2147
#, no-wrap
msgid "sys.frames"
msgstr ""

#. type: table
#: R-lang.texi:2149
msgid "Get the evaluation frames for all the active contexts."
msgstr ""

#. type: item
#: R-lang.texi:2149
#, no-wrap
msgid "sys.parents"
msgstr ""

#. type: table
#: R-lang.texi:2151
msgid "Get the numeric labels for all active contexts."
msgstr ""

#. type: item
#: R-lang.texi:2151
#, no-wrap
msgid "sys.on.exit"
msgstr ""

#. type: table
#: R-lang.texi:2153
msgid "Set a function to be executed when the specified context is exited."
msgstr ""

#. type: item
#: R-lang.texi:2153
#, no-wrap
msgid "sys.status"
msgstr ""

#. type: table
#: R-lang.texi:2155
msgid "Calls @code{sys.frames}, @code{sys.parents} and @code{sys.calls}."
msgstr ""

#. type: item
#: R-lang.texi:2155
#, no-wrap
msgid "parent.frame"
msgstr ""

#. type: table
#: R-lang.texi:2157
msgid "Get the evaluation frame for the specified parent context."
msgstr ""

#. type: Plain text
#: R-lang.texi:2163
msgid "In addition to the evaluation"
msgstr ""

#. type: cindex
#: R-lang.texi:2164
#, no-wrap
msgid "search path"
msgstr ""

#. type: Plain text
#: R-lang.texi:2169
msgid "environment structure, @R{} has a search path of environments which are searched for variables not found elsewhere.  This is used for two things: packages of functions and attached user data."
msgstr ""

#. type: Plain text
#: R-lang.texi:2174
msgid "The first element of the search path is the global environment and the last is the base package.  An @code{Autoloads} environment is used for holding proxy objects that may be loaded on demand.  Other environments are inserted in the path using @code{attach} or @code{library}."
msgstr ""

#. type: cindex
#: R-lang.texi:2175
#, no-wrap
msgid "namespace"
msgstr ""

#. type: Plain text
#: R-lang.texi:2184
msgid "Packages which have a @emph{namespace} have a different search path.  When a search for an @R{} object is started from an object in such a package, the package itself is searched first, then its imports, then the base namespace and finally the global environment and the rest of the regular search path.  The effect is that references to other objects in the same package will be resolved to the package, and objects cannot be masked by objects of the same name in the global environment or in other packages."
msgstr ""

#. type: node
#: R-lang.texi:2193
#: R-lang.texi:2195
#: R-lang.texi:2196
#: R-lang.texi:2215
#: R-lang.texi:2255
#: R-lang.texi:2291
#, no-wrap
msgid "Writing functions"
msgstr ""

#. type: node
#: R-lang.texi:2193
#: R-lang.texi:2195
#: R-lang.texi:2291
#: R-lang.texi:2292
#: R-lang.texi:2299
#, no-wrap
msgid "Functions as objects"
msgstr ""

#. type: node
#: R-lang.texi:2193
#: R-lang.texi:2291
#: R-lang.texi:2299
#: R-lang.texi:2300
#: R-lang.texi:2309
#: R-lang.texi:2330
#: R-lang.texi:2382
#: R-lang.texi:2485
#, no-wrap
msgid "Evaluation"
msgstr ""

#. type: Plain text
#: R-lang.texi:2200
msgid "While @R{} can be very useful as a data analysis tool most users very quickly find themselves wanting to write their own"
msgstr ""

#. type: Plain text
#: R-lang.texi:2205
msgid "functions.  This is one of the real advantages of @R{}.  Users can program it and they can, if they want to, change the system level functions to functions that they find more appropriate."
msgstr ""

#. type: Plain text
#: R-lang.texi:2209
msgid "@R{} also provides facilities that make it easy to document any functions that you have created.  @xref{Writing R documentation, , , R-exts, Writing R Extensions}."
msgstr ""

#. type: node
#: R-lang.texi:2213
#: R-lang.texi:2215
#: R-lang.texi:2216
#: R-lang.texi:2255
#, no-wrap
msgid "Syntax and examples"
msgstr ""

#. type: subsection
#: R-lang.texi:2213
#: R-lang.texi:2215
#: R-lang.texi:2255
#: R-lang.texi:2256
#, no-wrap
msgid "Arguments"
msgstr ""

#. type: Plain text
#: R-lang.texi:2219
msgid "The syntax for writing a"
msgstr ""

#. type: Plain text
#: R-lang.texi:2221
msgid "function is"
msgstr ""

#. type: example
#: R-lang.texi:2224
#: R-lang.texi:4762
#, no-wrap
msgid "function ( @var{arglist} ) @var{body}\n"
msgstr ""

#. type: Plain text
#: R-lang.texi:2229
msgid "The first component of the function declaration is the keyword @code{function} which indicates to @R{} that you want to create a function."
msgstr ""

#. type: Plain text
#: R-lang.texi:2236
msgid "argument list is a comma separated list of formal arguments.  A formal argument can be a symbol, a statement of the form @samp{@var{symbol} = @var{expression}}, or the special formal argument @samp{...}."
msgstr ""

#. type: Plain text
#: R-lang.texi:2240
msgid "The @emph{body} can be any valid @R{} expression.  Generally, the body is a group of expressions contained in curly braces (@samp{@{} and @samp{@}})."
msgstr ""

#. type: Plain text
#: R-lang.texi:2242
msgid "Generally"
msgstr ""

#. type: Plain text
#: R-lang.texi:2246
msgid "functions are assigned to symbols but they don't need to be.  The value returned by the call to @code{function} is a function.  If this is not given a name it is referred to as an"
msgstr ""

#. type: cindex
#: R-lang.texi:2246
#, no-wrap
msgid "function, anonymous"
msgstr ""

#. type: Plain text
#: R-lang.texi:2250
msgid "anonymous function. Anonymous functions are most frequently used as arguments to other functions such as the @code{apply} family or @code{outer}."
msgstr ""

#. type: Plain text
#: R-lang.texi:2254
msgid "Here is a simple function: @code{echo <- function(x) print(x)}.  So @code{echo} is a function that takes a single argument and when @code{echo} is invoked it prints its argument."
msgstr ""

#. type: Plain text
#: R-lang.texi:2262
msgid "The formal arguments to the function define the variables whose values will be supplied at the time the function is invoked.  The names of these arguments can be used within the function body where they obtain the value supplied at the time of function invocation."
msgstr ""

#. type: cindex
#: R-lang.texi:2263
#, no-wrap
msgid "argument, default values"
msgstr ""

#. type: Plain text
#: R-lang.texi:2269
msgid "Default values for arguments can be specified using the special form @samp{@var{name} = @var{expression}}.  In this case, if the user does not specify a value for the argument when the function is invoked the expression will be associated with the corresponding symbol.  When a value is needed the @var{expression} is"
msgstr ""

#. type: Plain text
#: R-lang.texi:2272
msgid "evaluated in the evaluation frame of the function."
msgstr ""

#. type: Plain text
#: R-lang.texi:2275
msgid "Default behaviours can also be specified by using the function @code{missing}.  When @code{missing} is called with the"
msgstr ""

#. type: Plain text
#: R-lang.texi:2282
msgid "name of a formal argument it returns @code{TRUE} if the formal argument was not matched with any actual argument and has not been subsequently modified in the body of the function.  An argument that is @code{missing} will thus have its default value, if any. The @code{missing} function does not force evaluation of the argument."
msgstr ""

#. type: Plain text
#: R-lang.texi:2286
msgid "The special type of argument @samp{...} can contain any number of supplied arguments.  It is used for a variety of purposes.  It allows you to write a"
msgstr ""

#. type: Plain text
#: R-lang.texi:2290
msgid "function that takes an arbitrary number of arguments.  It can be used to absorb some arguments into an intermediate function which can then be extracted by functions called subsequently."
msgstr ""

#. type: Plain text
#: R-lang.texi:2298
msgid "Functions are first class objects in @R{}.  They can be used anywhere that an @R{} object is required.  In particular they can be passed as arguments to functions and returned as values from functions.  See @ref{Function objects} for the details."
msgstr ""

#. type: node
#: R-lang.texi:2307
#: R-lang.texi:2309
#: R-lang.texi:2310
#: R-lang.texi:2330
#, no-wrap
msgid "Evaluation environment"
msgstr ""

#. type: node
#: R-lang.texi:2307
#: R-lang.texi:2309
#: R-lang.texi:2330
#: R-lang.texi:2331
#: R-lang.texi:2382
#, no-wrap
msgid "Argument matching"
msgstr ""

#. type: node
#: R-lang.texi:2307
#: R-lang.texi:2330
#: R-lang.texi:2382
#: R-lang.texi:2383
#: R-lang.texi:2485
#, no-wrap
msgid "Argument evaluation"
msgstr ""

#. type: subsection
#: R-lang.texi:2307
#: R-lang.texi:2382
#: R-lang.texi:2485
#: R-lang.texi:2486
#, no-wrap
msgid "Scope"
msgstr ""

#. type: Plain text
#: R-lang.texi:2313
#: R-lang.texi:2443
msgid "When a"
msgstr ""

#. type: Plain text
#: R-lang.texi:2315
msgid "function is called or invoked a new"
msgstr ""

#. type: Plain text
#: R-lang.texi:2321
msgid "evaluation frame is created.  In this frame the formal arguments are matched with the supplied arguments according to the rules given in @ref{Argument matching}.  The statements in the body of the function are evaluated sequentially in this"
msgstr ""

#. type: Plain text
#: R-lang.texi:2323
msgid "environment frame."
msgstr ""

#. type: Plain text
#: R-lang.texi:2329
msgid "The enclosing frame of the evaluation frame is the environment frame associated with the function being invoked.  This may be different from @Sl{}.  While many functions have @code{.GlobalEnv} as their environment this does not have to be true and functions defined in packages with namespaces (normally) have the package namespace as their environment."
msgstr ""

#. type: Plain text
#: R-lang.texi:2337
msgid "This subsection applies to closures but not to primitive functions.  The latter typically ignore tags and do positional matching, but their help pages should be consulted for exceptions, which include @code{log}, @code{round}, @code{signif}, @code{rep} and @code{seq.int}."
msgstr ""

#. type: Plain text
#: R-lang.texi:2339
msgid "The first thing that occurs in a"
msgstr ""

#. type: Plain text
#: R-lang.texi:2343
msgid "function evaluation is the matching of formal to the actual or supplied arguments.  This is done by a three-pass process:"
msgstr ""

#. type: item
#: R-lang.texi:2346
#, no-wrap
msgid "@strong{Exact matching on tags}."
msgstr ""

#. type: enumerate
#: R-lang.texi:2351
msgid "For each named supplied argument the list of formal arguments is searched for an item whose name matches exactly.  It is an error to have the same formal argument match several actuals or vice versa."
msgstr ""

#. type: item
#: R-lang.texi:2352
#, no-wrap
msgid "@strong{Partial matching on tags}."
msgstr ""

#. type: enumerate
#: R-lang.texi:2364
msgid "Each remaining named supplied argument is compared to the remaining formal arguments using partial matching.  If the name of the supplied argument matches exactly with the first part of a formal argument then the two arguments are considered to be matched.  It is an error to have multiple partial matches.  Notice that if @code{f <- function(fumble, fooey) fbody}, then @code{f(f = 1, fo = 2)} is illegal, even though the 2nd actual argument only matches @code{fooey}.  @code{f(f = 1, fooey = 2)} @emph{is} legal though since the second argument matches exactly and is removed from consideration for partial matching.  If the formal arguments contain @samp{...} then partial matching is only applied to arguments that precede it."
msgstr ""

#. type: item
#: R-lang.texi:2365
#, no-wrap
msgid "@strong{Positional matching}."
msgstr ""

#. type: enumerate
#: R-lang.texi:2369
msgid "Any unmatched formal arguments are bound to @emph{unnamed} supplied arguments, in order.  If there is a @samp{...} argument, it will take up the remaining arguments, tagged or not."
msgstr ""

#. type: Plain text
#: R-lang.texi:2373
msgid "If any arguments remain unmatched an error is declared."
msgstr ""

#. type: Plain text
#: R-lang.texi:2376
msgid "Argument matching is augmented by the functions @code{match.arg}, @code{match.call} and @code{match.fun}."
msgstr ""

#. type: findex
#: R-lang.texi:2376
#, no-wrap
msgid "match.arg"
msgstr ""

#. type: findex
#: R-lang.texi:2377
#: R-lang.texi:3623
#, no-wrap
msgid "match.call"
msgstr ""

#. type: findex
#: R-lang.texi:2378
#, no-wrap
msgid "match.fun"
msgstr ""

#. type: Plain text
#: R-lang.texi:2381
msgid "Access to the partial matching algorithm used by @R{} is via @code{pmatch}."
msgstr ""

#. type: Plain text
#: R-lang.texi:2386
msgid "One of the most important things to know about the"
msgstr ""

#. type: cindex
#: R-lang.texi:2386
#, no-wrap
msgid "evaluation, argument"
msgstr ""

#. type: Plain text
#: R-lang.texi:2389
msgid "evaluation of arguments to a"
msgstr ""

#. type: Plain text
#: R-lang.texi:2395
msgid "function is that supplied arguments and default arguments are treated differently.  The supplied arguments to a function are evaluated in the evaluation frame of the calling function.  The default arguments to a function are evaluated in the evaluation frame of the function."
msgstr ""

#. type: Plain text
#: R-lang.texi:2399
msgid "The semantics of invoking a function in @R{} argument are @emph{call-by-value}.  In general, supplied arguments behave as if they are local variables initialized with the value supplied and the"
msgstr ""

#. type: Plain text
#: R-lang.texi:2404
msgid "name of the corresponding formal argument.  Changing the value of a supplied argument within a function will not affect the value of the variable in the calling frame."
msgstr ""

#. type: Plain text
#: R-lang.texi:2413
msgid "@R{} has a form of lazy evaluation of function arguments.  Arguments are not evaluated until needed.  It is important to realize that in some cases the argument will never be evaluated.  Thus, it is bad style to use arguments to functions to cause side-effects.  While in @C{} it is common to use the form, @code{foo(x = y)} to invoke @code{foo} with the value of @code{y} and simultaneously to assign the value of @code{y} to @code{x} this same style should not be used in @R{}. There is no guarantee that the argument will ever be evaluated and hence the"
msgstr ""

#. type: Plain text
#: R-lang.texi:2415
msgid "assignment may not take place."
msgstr ""

#. type: Plain text
#: R-lang.texi:2418
msgid "It is also worth noting that the effect of @code{foo(x <- y)} if the argument is evaluated is to change the value of @code{x} in the calling"
msgstr ""

#. type: Plain text
#: R-lang.texi:2420
msgid "environment and not in the"
msgstr ""

#. type: Plain text
#: R-lang.texi:2422
msgid "evaluation environment of @code{foo}."
msgstr ""

#. type: Plain text
#: R-lang.texi:2426
msgid "It is possible to access the actual (not default) expressions used as arguments inside the function.  The mechanism is implemented via promises.  When a"
msgstr ""

#. type: Plain text
#: R-lang.texi:2441
msgid "function is being evaluated the actual expression used as an argument is stored in the promise together with a pointer to the environment the function was called from.  When (if) the argument is evaluated the stored expression is evaluated in the environment that the function was called from.  Since only a pointer to the environment is used any changes made to that environment will be in effect during this evaluation.  The resulting value is then also stored in a separate spot in the promise.  Subsequent evaluations retrieve this stored value (a second evaluation is not carried out).  Access to the unevaluated expression is also available using @code{substitute}."
msgstr ""

#. type: Plain text
#: R-lang.texi:2450
msgid "function is called, each formal argument is assigned a promise in the local environment of the call with the expression slot containing the actual argument (if it exists) and the environment slot containing the environment of the caller.  If no actual argument for a formal argument is given in the call and there is a default expression, it is similarly assigned to the expression slot of the formal argument, but with the"
msgstr ""

#. type: Plain text
#: R-lang.texi:2453
msgid "environment set to the local environment."
msgstr ""

#. type: Plain text
#: R-lang.texi:2455
msgid "The process of filling the value slot of a promise by"
msgstr ""

#. type: Plain text
#: R-lang.texi:2460
msgid "evaluating the contents of the expression slot in the promise's environment is called @emph{forcing} the promise.  A promise will only be forced once, the value slot content being used directly later on."
msgstr ""

#. type: Plain text
#: R-lang.texi:2463
msgid "A promise is forced when its value is needed.  This usually happens inside internal"
msgstr ""

#. type: cindex
#: R-lang.texi:2464
#: R-lang.texi:3045
#, no-wrap
msgid "function, internal"
msgstr ""

#. type: Plain text
#: R-lang.texi:2471
msgid "functions, but a promise can also be forced by direct evaluation of the promise itself.  This is occasionally useful when a default expression depends on the value of another formal argument or other variable in the local environment.  This is seen in the following example where the lone @code{label} ensures that the label is based on the value of @code{x} before it is changed in the next line."
msgstr ""

#. type: example
#: R-lang.texi:2478
#, no-wrap
msgid ""
"function(x, label = deparse(x)) @{\n"
"    label\n"
"    x <- x + 1\n"
"    print(label)\n"
"@}\n"
msgstr ""

#. type: Plain text
#: R-lang.texi:2484
msgid "The expression slot of a promise can itself involve other promises.  This happens whenever an unevaluated argument is passed as an argument to another function.  When forcing a promise, other promises in its expression will also be forced recursively as they are evaluated."
msgstr ""

#. type: Plain text
#: R-lang.texi:2490
msgid "Scope or the scoping rules are simply the set of rules used by the"
msgstr ""

#. type: Plain text
#: R-lang.texi:2492
msgid "evaluator to find a value for a"
msgstr ""

#. type: Plain text
#: R-lang.texi:2496
msgid "symbol.  Every computer language has a set of such rules.  In @R{} the rules are fairly simple but there do exist mechanisms for subverting the usual, or default rules."
msgstr ""

#. type: Plain text
#: R-lang.texi:2499
msgid "@R{} adheres to a set of rules that are called @emph{lexical scope}.  This means the variable"
msgstr ""

#. type: cindex
#: R-lang.texi:2499
#: R-lang.texi:2509
#, no-wrap
msgid "binding"
msgstr ""

#. type: Plain text
#: R-lang.texi:2503
msgid "bindings in effect at the time the expression was created are used to provide values for any unbound symbols in the expression."
msgstr ""

#. type: Plain text
#: R-lang.texi:2505
msgid "Most of the interesting properties of"
msgstr ""

#. type: Plain text
#: R-lang.texi:2507
msgid "scope are involved with evaluating"
msgstr ""

#. type: Plain text
#: R-lang.texi:2509
msgid "functions and we concentrate on this issue.  A symbol can be either"
msgstr ""

#. type: Plain text
#: R-lang.texi:2518
msgid "bound or unbound.  All of the formal arguments to a function provide bound symbols in the body of the function.  Any other symbols in the body of the function are either local variables or unbound variables.  A local variable is one that is defined within the function.  Because @R{} has no formal definition of variables, they are simply used as needed, it can be difficult to determine whether a variable is local or not.  Local variables must first be defined, this is typically done by having them on the left-hand side of an"
msgstr ""

#. type: Plain text
#: R-lang.texi:2524
msgid "During the evaluation process if an unbound symbol is detected then @R{} attempts to find a value for it.  The scoping rules determine how this process proceeds.  In @R{} the"
msgstr ""

#. type: Plain text
#: R-lang.texi:2527
msgid "environment of the function is searched first, then its enclosure and so on until the global environment is reached."
msgstr ""

#. type: Plain text
#: R-lang.texi:2530
msgid "The global environment heads a search list of environments that are searched sequentially for a matching symbol.  The value of the first match is then used."
msgstr ""

#. type: Plain text
#: R-lang.texi:2532
msgid "When this set of rules is combined with the fact that"
msgstr ""

#. type: Plain text
#: R-lang.texi:2536
msgid "functions can be returned as values from other functions then some rather nice, but at first glance peculiar, properties obtain."
msgstr ""

#. type: Plain text
#: R-lang.texi:2538
msgid "A simple example:"
msgstr ""

#. type: example
#: R-lang.texi:2547
#, no-wrap
msgid ""
"f <- function() @{\n"
"    y <- 10\n"
"    g <- function(x) x + y\n"
"    return(g)\n"
"@}\n"
"h <- f()\n"
"h(3)\n"
msgstr ""

#. type: Plain text
#: R-lang.texi:2552
msgid "A rather interesting question is what happens when @code{h} is evaluated.  To describe this we need a bit more notation.  Within a"
msgstr ""

#. type: Plain text
#: R-lang.texi:2561
msgid "function body variables can be bound, local or unbound.  The bound variables are those that match the formal arguments to the function.  The local variables are those that were created or defined within the function body.  The unbound variables are those that are neither local nor bound.  When a function body is evaluated there is no problem determining values for local variables or for bound variables.  Scoping rules determine how the language will find values for the unbound variables."
msgstr ""

#. type: Plain text
#: R-lang.texi:2565
msgid "When @code{h(3)} is evaluated we see that its body is that of @code{g}. Within that body @code{x} is bound to the formal argument and @code{y} is unbound.  In a language with"
msgstr ""

#. type: Plain text
#: R-lang.texi:2569
msgid "lexical scope @code{x} will be associated with the value 3 and @code{y} with the value 10 local to @code{f} so @code{h(3)} should return the value 13.  In @R{} this is indeed what happens."
msgstr ""

#. type: Plain text
#: R-lang.texi:2573
msgid "In @Sl{}, because of the different scoping rules one will get an error indicating that @code{y} is not found, unless there is a variable @code{y} in your workspace in which case its value will be used."
msgstr ""

#. type: cindex
#: R-lang.texi:2603
#: R-lang.texi:2689
#, no-wrap
msgid "object-oriented"
msgstr ""

#. type: Plain text
#: R-lang.texi:2608
msgid "Object-oriented programming is a style of programming that has become popular in recent years.  Much of the popularity comes from the fact that it makes it easier to write and maintain complicated systems.  It does this through several different mechanisms."
msgstr ""

#. type: Plain text
#: R-lang.texi:2614
msgid "Central to any object-oriented language are the concepts of class and of methods.  A @emph{class} is a definition of an object.  Typically a class contains several @emph{slots} that are used to hold class-specific information.  An object in the language must be an instance of some class.  Programming is based on objects or instances of classes."
msgstr ""

#. type: Plain text
#: R-lang.texi:2616
msgid "Computations are carried out via @emph{methods}.  Methods are basically"
msgstr ""

#. type: Plain text
#: R-lang.texi:2623
msgid "functions that are specialized to carry out specific calculations on objects, usually of a specific class.  This is what makes the language object oriented.  In @R{}, @emph{generic functions} are used to determine the appropriate method.  The generic function is responsible for determining the class of its argument(s) and uses that information to select the appropriate method."
msgstr ""

#. type: Plain text
#: R-lang.texi:2628
msgid "Another feature of most object-oriented languages is the concept of inheritance.  In most programming problems there are usually many objects that are related to one another.  The programming is considerably simplified if some components can be reused."
msgstr ""

#. type: Plain text
#: R-lang.texi:2633
msgid "If a class inherits from another class then generally it gets all the slots in the parent class and can extend it by adding new slots.  On method dispatching (via the generic functions) if a method for the class does not exist then a method for the parent is sought."
msgstr ""

#. type: Plain text
#: R-lang.texi:2644
msgid "In this chapter we discuss how this general strategy has been implemented in @R{} and discuss some of the limitations within the current design.  One of the advantages that most object systems impart is greater consistency.  This is achieved via the rules that are checked by the compiler or interpreter.  Unfortunately because of the way that the object system is incorporated into @R{} this advantage does not obtain.  Users are cautioned to use the object system in a straightforward manner.  While it is possible to perform some rather interesting feats these tend to lead to obfuscated code and may depend on implementation details that will not be carried forward."
msgstr ""

#. type: Plain text
#: R-lang.texi:2648
msgid "The greatest use of object oriented programming in @R{} is through @code{print} methods, @code{summary} methods and @code{plot} methods.  These methods allow us to have one generic"
msgstr ""

#. type: cindex
#: R-lang.texi:2648
#: R-lang.texi:2705
#: R-lang.texi:2748
#: R-lang.texi:2802
#: R-lang.texi:2837
#: R-lang.texi:2847
#: R-lang.texi:3090
#: R-lang.texi:3103
#, no-wrap
msgid "function, generic"
msgstr ""

#. type: Plain text
#: R-lang.texi:2652
msgid "function call, @code{plot} say, that dispatches on the type of its argument and calls a plotting function that is specific to the data supplied."
msgstr ""

#. type: Plain text
#: R-lang.texi:2661
msgid "In order to make the concepts clear we will consider the implementation of a small system designed to teach students about probability.  In this system the objects are probability functions and the methods we will consider are methods for finding moments and for plotting.  Probabilities can always be represented in terms of the cumulative distribution function but can often be represented in other ways.  For example as a density, when it exists or as a moment generating function when it exists."
msgstr ""

#. type: node
#: R-lang.texi:2683
#: R-lang.texi:2685
#: R-lang.texi:2686
#: R-lang.texi:2832
#, no-wrap
msgid "Definition"
msgstr ""

#. type: node
#: R-lang.texi:2683
#: R-lang.texi:2685
#: R-lang.texi:2832
#: R-lang.texi:2833
#: R-lang.texi:2844
#, no-wrap
msgid "Inheritance"
msgstr ""

#. type: node
#: R-lang.texi:2683
#: R-lang.texi:2832
#: R-lang.texi:2844
#: R-lang.texi:2845
#: R-lang.texi:2878
#, no-wrap
msgid "Method dispatching"
msgstr ""

#. type: node
#: R-lang.texi:2683
#: R-lang.texi:2844
#: R-lang.texi:2878
#: R-lang.texi:2879
#: R-lang.texi:2880
#: R-lang.texi:2965
#, no-wrap
msgid "UseMethod"
msgstr ""

#. type: node
#: R-lang.texi:2683
#: R-lang.texi:2878
#: R-lang.texi:2965
#: R-lang.texi:2966
#: R-lang.texi:2967
#: R-lang.texi:3041
#, no-wrap
msgid "NextMethod"
msgstr ""

#. type: node
#: R-lang.texi:2683
#: R-lang.texi:2965
#: R-lang.texi:3041
#: R-lang.texi:3042
#: R-lang.texi:3086
#, no-wrap
msgid "Group methods"
msgstr ""

#. type: section
#: R-lang.texi:2683
#: R-lang.texi:3041
#: R-lang.texi:3086
#: R-lang.texi:3087
#, no-wrap
msgid "Writing methods"
msgstr ""

#. type: Plain text
#: R-lang.texi:2689
msgid "Rather than having a full-fledged"
msgstr ""

#. type: Plain text
#: R-lang.texi:2697
msgid "object-oriented system @R{} has a class system and a mechanism for dispatching based on the class of an object.  The dispatch mechanism for interpreted code relies on four special objects that are stored in the evaluation frame.  These special objects are @code{.Generic}, @code{.Class}, @code{.Method} and @code{.Group}.  There is a separate dispatch mechanism used for internal functions and types that will be discussed elsewhere."
msgstr ""

#. type: Plain text
#: R-lang.texi:2703
msgid "The class system is facilitated through the @code{class} attribute.  This attribute is a character vector of class names.  So to create an object of class @code{\"foo\"} one simply attaches a class attribute with the string @samp{\"foo\"} in it.  Thus, virtually anything can be turned in to an object of class @code{\"foo\"}."
msgstr ""

#. type: Plain text
#: R-lang.texi:2705
msgid "The object system makes use of"
msgstr ""

#. type: Plain text
#: R-lang.texi:2712
msgid "@emph{generic functions} via two dispatching functions, @code{UseMethod} and @code{NextMethod}.  The typical use of the object system is to begin by calling a generic function.  This is typically a very simple function and consists of a single line of code.  The system function @code{mean} is just such a function,"
msgstr ""

#. type: example
#: R-lang.texi:2717
#, no-wrap
msgid ""
"> mean\n"
"function (x, ...)\n"
"UseMethod(\"mean\")\n"
msgstr ""

#. type: Plain text
#: R-lang.texi:2726
msgid "When @code{mean} is called it can have any number of arguments but its first argument is special and the class of that first argument is used to determine which method should be called.  The variable @code{.Class} is set to the class attribute of @code{x}, @code{.Generic} is set to the string @code{\"mean\"} and a search is made for the correct method to invoke.  The class attributes of any other arguments to @code{mean} are ignored."
msgstr ""

#. type: Plain text
#: R-lang.texi:2735
msgid "Suppose that @code{x} had a class attribute that contained @code{\"foo\"} and @code{\"bar\"}, in that order.  Then @R{} would first search for a function called @code{mean.foo} and if it did not find one it would then search for a function @code{mean.bar} and if that search was also unsuccessful then a final search for @code{mean.default} would be made.  If the last search is unsuccessful @R{} reports an error.  It is a good idea to always write a default method.  Note that the functions @code{mean.foo} etc.@: are referred to, in this context, as methods."
msgstr ""

#. type: Plain text
#: R-lang.texi:2737
msgid "@code{NextMethod} provides another mechanism for dispatching.  A"
msgstr ""

#. type: Plain text
#: R-lang.texi:2744
msgid "function may have a call to @code{NextMethod} anywhere in it.  The determination of which method should then be invoked is based primarily on the current values of @code{.Class} and @code{.Generic}.  This is somewhat problematic since the method is really an ordinary function and users may call it directly.  If they do so then there will be no values for @code{.Generic} or @code{.Class}."
msgstr ""

#. type: Plain text
#: R-lang.texi:2748
msgid "If a method is invoked directly and it contains a call to @code{NextMethod} then the first argument to @code{NextMethod} is used to determine the"
msgstr ""

#. type: Plain text
#: R-lang.texi:2752
msgid "generic function.  An error is signalled if this argument has not been supplied; it is therefore a good idea to always supply this argument."
msgstr ""

#. type: Plain text
#: R-lang.texi:2755
msgid "In the case that a method is invoked directly the class attribute of the first argument to the method is used as the value of @code{.Class}."
msgstr ""

#. type: Plain text
#: R-lang.texi:2760
msgid "Methods themselves employ @code{NextMethod} to provide a form of inheritance.  Commonly a specific method performs a few operations to set up the data and then it calls the next appropriate method through a call to @code{NextMethod}."
msgstr ""

#. type: Plain text
#: R-lang.texi:2799
msgid "Consider the following simple example.  A point in two-dimensional Euclidean space can be specified by its Cartesian (x-y) or polar (r-theta) coordinates.  Hence, to store information about the location of the point, we could define two classes, @code{\"xypoint\"} and @code{\"rthetapoint\"}.  All the `xypoint' data structures are lists with an x-component and a y-component.  All `rthetapoint' objects are lists with an r-component and a theta-component."
msgstr ""

#. type: Plain text
#: R-lang.texi:2802
msgid "Now, suppose we want to get the x-position from either type of object.  This can easily be achieved through"
msgstr ""

#. type: Plain text
#: R-lang.texi:2805
msgid "generic functions.  We define the generic function @code{xpos} as follows."
msgstr ""

#. type: example
#: R-lang.texi:2809
#, no-wrap
msgid ""
"xpos <- function(x, ...)\n"
"    UseMethod(\"xpos\")\n"
msgstr ""

#. type: Plain text
#: R-lang.texi:2813
msgid "Now we can define methods:"
msgstr ""

#. type: example
#: R-lang.texi:2817
#, no-wrap
msgid ""
"xpos.xypoint <- function(x) x$x\n"
"xpos.rthetapoint <- function(x) x$r * cos(x$theta)\n"
msgstr ""

#. type: Plain text
#: R-lang.texi:2822
msgid "The user simply calls the function @code{xpos} with either representation as the argument.  The internal dispatching method finds the class of the object and calls the appropriate methods."
msgstr ""

#. type: Plain text
#: R-lang.texi:2827
msgid "It is pretty easy to add other representations.  One need not write a new generic function only the methods.  This makes it easy to add to existing systems since the user is only responsible for dealing with the new representation and not with any of the existing representations."
msgstr ""

#. type: Plain text
#: R-lang.texi:2831
msgid "The bulk of the uses of this methodology are to provide specialized printing for objects of different types; there are about 40 methods for @code{print}."
msgstr ""

#. type: Plain text
#: R-lang.texi:2837
msgid "The class attribute of an object can have several elements.  When a"
msgstr ""

#. type: Plain text
#: R-lang.texi:2841
msgid "generic function is called the first inheritance is mainly handled through @code{NextMethod}.  @code{NextMethod} determines the method currently being evaluated, finds the next class from th"
msgstr ""

#. type: Plain text
#: R-lang.texi:2843
msgid "FIXME: something is missing here"
msgstr ""

#. type: Plain text
#: R-lang.texi:2854
msgid "Generic functions should consist of a single statement.  They should usually be of the form @code{foo <- function(x, ...) UseMethod(\"foo\", x)}.  When @code{UseMethod} is called, it determines the appropriate method and then that method is invoked with the same arguments, in the same order as the call to the generic, as if the call had been made directly to the method."
msgstr ""

#. type: Plain text
#: R-lang.texi:2858
msgid "In order to determine the correct method the class attribute of the first argument to the generic is obtained and used to find the correct method.  The"
msgstr ""

#. type: Plain text
#: R-lang.texi:2871
msgid "name of the generic function is combined with the first element of the class attribute into the form, @code{@var{generic}.@var{class}} and a function with that name is sought.  If the function is found then it is used.  If no such function is found then the second element of the class attribute is used, and so on until all the elements of the class attribute have been exhausted.  If no method has been found at that point then the method @code{@var{generic}.@var{default}} is used.  If the first argument to the generic function has no class attribute then @code{@var{generic}.@var{default}} is used.  Since the introduction of namespaces the methods may not be accessible by their names (i.e. @code{get(\"@var{generic}.@var{class}\")} may fail), but they will be accessible by @code{getS3method(\"@var{generic}\",\"@var{class}\")}."
msgstr ""

#. type: Plain text
#: R-lang.texi:2877
msgid "Any object can have a @code{class} attribute.  This attribute can have any number of elements.  Each of these is a string that defines a class.  When a generic function is invoked the class of its first argument is examined."
msgstr ""

#. type: Plain text
#: R-lang.texi:2888
msgid "@code{UseMethod} is a special function and it behaves differently from other function calls.  The syntax of a call to it is @code{UseMethod(@var{generic}, @var{object})}, where @var{generic} is the name of the generic function, @var{object} is the object used to determine which method should be chosen.  @code{UseMethod} can only be called from the body of a function."
msgstr ""

#. type: Plain text
#: R-lang.texi:2893
msgid "@code{UseMethod} changes the evaluation model in two ways.  First, when it is invoked it determines the next method (function) to be called.  It then invokes that function using the current evaluation"
msgstr ""

#. type: Plain text
#: R-lang.texi:2899
msgid "environment; this process will be described shortly.  The second way in which @code{UseMethod} changes the evaluation environment is that it does not return control to the calling function.  This means, that any statements after a call to @code{UseMethod} are guaranteed not to be executed."
msgstr ""

#. type: Plain text
#: R-lang.texi:2909
msgid "When @code{UseMethod} is invoked the generic function is the specified value in the call to @code{UseMethod}.  The object to dispatch on is either the supplied second argument or the first argument to the current function.  The class of the argument is determined and the first element of it is combined with the name of the generic to determine the appropriate method.  So, if the generic had name @code{foo} and the class of the object is @code{\"bar\"}, then @R{} will search for a method named @code{foo.bar}.  If no such method exists then the inheritance mechanism described above is used to locate an appropriate method."
msgstr ""

#. type: Plain text
#: R-lang.texi:2912
msgid "Once a method has been determined @R{} invokes it in a special way.  Rather than creating a new evaluation"
msgstr ""

#. type: Plain text
#: R-lang.texi:2915
msgid "environment @R{} uses the environment of the current function call (the call to the generic).  Any"
msgstr ""

#. type: Plain text
#: R-lang.texi:2920
msgid "assignments or evaluations that were made before the call to @code{UseMethod} will be in effect.  The arguments that were used in the call to the generic are rematched to the formal arguments of the selected method."
msgstr ""

#. type: Plain text
#: R-lang.texi:2926
msgid "When the method is invoked it is called with arguments that are the same in number and have the same names as in the call to the generic.  They are matched to the arguments of the method according to the standard @R{} rules for argument matching.  However the object, i.e.@: the first argument has been evaluated."
msgstr ""

#. type: Plain text
#: R-lang.texi:2938
msgid "The call to @code{UseMethod} has the effect of placing some special objects in the evaluation frame.  They are @code{.Class}, @code{.Generic} and @code{.Method}.  These special objects are used to by @R{} to handle the method dispatch and inheritance.  @code{.Class} is the class of the object, @code{.Generic} is the name of the generic function and @code{.Method} is the name of the method currently being invoked.  If the method was invoked through one of the internal interfaces then there may also be an object called @code{.Group}.  This will be described in Section @ref{Group methods}.  After the initial call to @code{UseMethod} these special variables, not the object itself, control the selection of subsequent methods."
msgstr ""

#. type: Plain text
#: R-lang.texi:2944
msgid "The body of the method is then evaluated in the standard fashion.  In particular variable look-up in the body follows the rules for the method.  So if the method has an associated environment then that is used.  In effect we have replaced the call to the generic by a call to the method.  Any local"
msgstr ""

#. type: Plain text
#: R-lang.texi:2950
msgid "assignments in the frame of the generic will be carried forward into the call to the method.  Use of this @emph{feature} is discouraged.  It is important to realize that control will never return to the generic and hence any expressions after a call to @code{UseMethod} will never be executed."
msgstr ""

#. type: Plain text
#: R-lang.texi:2953
msgid "Any arguments to the generic that were evaluated prior to the call to @code{UseMethod} remain evaluated."
msgstr ""

#. type: Plain text
#: R-lang.texi:2964
msgid "If the first argument to @code{UseMethod} is not supplied it is assumed to be the name of the current function.  If two arguments are supplied to @code{UseMethod} then the first is the name of the method and the second is assumed to be the object that will be dispatched on.  It is evaluated so that the required method can be determined.  In this case the first argument in the call to the generic is not evaluated and is discarded.  There is no way to change the other arguments in the call to the method; these remain as they were in the call to the generic.  This is in contrast to @code{NextMethod} where the arguments in the call to the next method can be altered."
msgstr ""

#. type: Plain text
#: R-lang.texi:2970
msgid "@code{NextMethod} is used to provide a simple inheritance mechanism."
msgstr ""

#. type: Plain text
#: R-lang.texi:2979
msgid "Methods invoked as a result of a call to @code{NextMethod} behave as if they had been invoked from the previous method.  The arguments to the inherited method are in the same order and have the same names as the call to the current method.  This means that they are the same as for the call to the generic.  However, the expressions for the arguments are the names of the corresponding formal arguments of the current method.  Thus the arguments will have values that correspond to their value at the time NextMethod was invoked."
msgstr ""

#. type: Plain text
#: R-lang.texi:2982
msgid "Unevaluated arguments remain unevaluated.  Missing arguments remain missing."
msgstr ""

#. type: Plain text
#: R-lang.texi:2988
msgid "The syntax for a call to @code{NextMethod} is @code{NextMethod(generic, object, ...)}.  If the @code{generic} is not supplied the value of @code{.Generic} is used.  If the @code{object} is not supplied the first argument in the call to the current method is used.  Values in the @samp{...} argument are used to modify the arguments of the next method."
msgstr ""

#. type: Plain text
#: R-lang.texi:2994
msgid "It is important to realize that the choice of the next method depends on the current values of @code{.Generic} and @code{.Class} and not on the object.  So changing the object in a call to @code{NextMethod} affects the arguments received by the next method but does not affect the choice of the next method."
msgstr ""

#. type: Plain text
#: R-lang.texi:3003
msgid "Methods can be called directly.  If they are then there will be no @code{.Generic}, @code{.Class} or @code{.Method}.  In this case the @code{generic} argument of @code{NextMethod} must be specified.  The value of @code{.Class} is taken to be the class attribute of the object which is the first argument to the current function.  The value of @code{.Method} is the name of the current function.  These choices for default values ensure that the behaviour of a method doesn't change depending on whether it is called directly or via a call to a generic."
msgstr ""

#. type: Plain text
#: R-lang.texi:3008
msgid "An issue for discussion is the behaviour of the @samp{...} argument to @code{NextMethod}.  The White Book describes the behaviour as follows:"
msgstr ""

#. type: Plain text
#: R-lang.texi:3013
msgid "- named arguments replace the corresponding arguments in the call to the current method.  Unnamed arguments go at the start of the argument list."
msgstr ""

#. type: Plain text
#: R-lang.texi:3015
msgid "What I would like to do is:"
msgstr ""

#. type: Plain text
#: R-lang.texi:3021
msgid "-first do the argument matching for NextMethod; -if the object or generic are changed fine -first if a named list element matches an argument (named or not) the list value replaces the argument value.  - the first unnamed list element"
msgstr ""

#. type: Plain text
#: R-lang.texi:3025
msgid "Values for lookup: Class: comes first from .Class, second from the first argument to the method and last from the object specified in the call to NextMethod"
msgstr ""

#. type: Plain text
#: R-lang.texi:3029
msgid "Generic: comes first from .Generic, if nothing then from the first argument to the method and if it's still missing from the call to NextMethod"
msgstr ""

#. type: Plain text
#: R-lang.texi:3031
msgid "Method: this should just be the current function name."
msgstr ""

#. type: Plain text
#: R-lang.texi:3045
msgid "For several types of"
msgstr ""

#. type: Plain text
#: R-lang.texi:3053
msgid "internal functions @R{} provides a dispatching mechanism for operators.  This means that operators such as @code{==} or @code{<} can have their behaviour modified for members of special classes.  The functions and operators have been grouped into three categories and group methods can be written for each of these categories.  There is currently no mechanism to add groups.  It is possible to write methods specific to any function within a group."
msgstr ""

#. type: Plain text
#: R-lang.texi:3055
msgid "The following table lists the functions for the different Groups."
msgstr ""

#. type: item
#: R-lang.texi:3057
#, no-wrap
msgid "Math"
msgstr ""

#. type: table
#: R-lang.texi:3061
msgid "abs, acos, acosh, asin, asinh, atan, atanh, ceiling, cos, cosh, cospi, cumsum, exp, floor, gamma, lgamma, log, log10, round, signif, sin, sinh, sinpi, tan, tanh, tanpi, trunc"
msgstr ""

#. type: item
#: R-lang.texi:3062
#, no-wrap
msgid "Summary"
msgstr ""

#. type: table
#: R-lang.texi:3064
msgid "all, any, max, min, prod, range, sum"
msgstr ""

#. type: item
#: R-lang.texi:3065
#, no-wrap
msgid "Ops"
msgstr ""

#. type: table
#: R-lang.texi:3069
msgid "@code{+}, @code{-}, @code{*}, @code{/}, @code{^}, @code{<} , @code{>}, @code{<=}, @code{>=}, @code{!=}, @code{==}, @code{%%}, @code{%/%}, @code{&}, @code{|}, @code{!}"
msgstr ""

#. type: Plain text
#: R-lang.texi:3078
msgid "For operators in the Ops group a special method is invoked if the two operands taken together suggest a single method.  Specifically, if both operands correspond to the same method or if one operand corresponds to a method that takes precedence over that of the other operand.  If they do not suggest a single method then the default method is used.  Either a group method or a class method dominates if the other operand has no corresponding method.  A class method dominates a group method."
msgstr ""

#. type: Plain text
#: R-lang.texi:3085
msgid "When the group is Ops the special variable @code{.Method} is a string vector with two elements.  The elements of @code{.Method} are set to the name of the method if the corresponding argument is a member of the class that was used to determine the method.  Otherwise the corresponding element of @code{.Method} is set to the zero length string, @code{\"\"}."
msgstr ""

#. type: Plain text
#: R-lang.texi:3090
msgid "Users can easily write their own methods and generic functions.  A"
msgstr ""

#. type: Plain text
#: R-lang.texi:3095
msgid "generic function is simply a function with a call to @code{UseMethod}.  A method is simply a function that has been invoked via method dispatch.  This can be as a result of a call to either @code{UseMethod} or @code{NextMethod}."
msgstr ""

#. type: Plain text
#: R-lang.texi:3101
msgid "It is worth remembering that methods can be called directly.  That means that they can be entered without a call to @code{UseMethod} having been made and hence the special variables @code{.Generic}, @code{.Class} and @code{.Method} will not have been instantiated.  In that case the default rules detailed above will be used to determine these."
msgstr ""

#. type: Plain text
#: R-lang.texi:3103
msgid "The most common use of"
msgstr ""

#. type: Plain text
#: R-lang.texi:3111
msgid "generic functions is to provide @code{print} and @code{summary} methods for statistical objects, generally the output of some model fitting process.  To do this, each model attaches a class attribute to its output and then provides a special method that takes that output and provides a nice readable version of it.  The user then needs only remember that @code{print} or @code{summary} will provide nice output for the results of any analysis."
msgstr ""

#. type: Plain text
#: R-lang.texi:3135
msgid "@R{} belongs to a class of programming languages in which subroutines have the ability to modify or construct other subroutines and evaluate the result as an integral part of the language itself.  This is similar to Lisp and Scheme and other languages of the ``functional programming'' variety, but in contrast to FORTRAN and the ALGOL family.  The Lisp family takes this feature to the extreme by the ``everything is a list'' paradigm in which there is no distinction between programs and data."
msgstr ""

#. type: Plain text
#: R-lang.texi:3140
msgid "@R{} presents a friendlier interface to programming than Lisp does, at least to someone used to mathematical formulas and C-like control structures, but the engine is really very Lisp-like.  @R{} allows direct access to"
msgstr ""

#. type: Plain text
#: R-lang.texi:3144
msgid "parsed expressions and functions and allows you to alter and subsequently execute them, or create entirely new functions from scratch."
msgstr ""

#. type: Plain text
#: R-lang.texi:3157
msgid "There is a number of standard applications of this facility, such as calculation of analytical derivatives of expressions, or the generation of polynomial functions from a vector of coefficients.  However, there are also uses that are much more fundamental to the workings of the interpreted part of @R{}.  Some of these are essential to the reuse of functions as components in other functions, as the (admittedly not very pretty) calls to @code{model.frame} that are constructed in several modeling and plotting routines.  Other uses simply allow elegant interfaces to useful functionality.  As an example, consider the @code{curve} function, which allows you to draw the graph of a function given as an expression like @code{sin(x)} or the facilities for plotting mathematical expressions."
msgstr ""

#. type: Plain text
#: R-lang.texi:3160
msgid "In this chapter, we give an introduction to the set of facilities that are available for computing on the language."
msgstr ""

#. type: node
#: R-lang.texi:3168
#: R-lang.texi:3170
#: R-lang.texi:3171
#: R-lang.texi:3290
#, no-wrap
msgid "Direct manipulation of language objects"
msgstr ""

#. type: node
#: R-lang.texi:3168
#: R-lang.texi:3170
#: R-lang.texi:3290
#: R-lang.texi:3291
#: R-lang.texi:3441
#, no-wrap
msgid "Substitutions"
msgstr ""

#. type: node
#: R-lang.texi:3168
#: R-lang.texi:3290
#: R-lang.texi:3441
#: R-lang.texi:3442
#: R-lang.texi:3496
#, no-wrap
msgid "More on evaluation"
msgstr ""

#. type: node
#: R-lang.texi:3168
#: R-lang.texi:3441
#: R-lang.texi:3496
#: R-lang.texi:3497
#: R-lang.texi:3555
#, no-wrap
msgid "Evaluation of expression objects"
msgstr ""

#. type: node
#: R-lang.texi:3168
#: R-lang.texi:3496
#: R-lang.texi:3555
#: R-lang.texi:3556
#: R-lang.texi:3715
#, no-wrap
msgid "Manipulation of function calls"
msgstr ""

#. type: section
#: R-lang.texi:3168
#: R-lang.texi:3555
#: R-lang.texi:3715
#: R-lang.texi:3716
#, no-wrap
msgid "Manipulation of functions"
msgstr ""

#. type: Plain text
#: R-lang.texi:3179
msgid "There are three kinds of language objects that are available for modification, calls, expressions, and functions.  At this point, we shall concentrate on the call objects.  These are sometimes referred to as ``unevaluated expressions'', although this terminology is somewhat confusing.  The most direct method of obtaining a call object is to use @code{quote} with an expression argument, e.g.,"
msgstr ""

#. type: example
#: R-lang.texi:3183
#, no-wrap
msgid ""
"> e1 <- quote(2 + 2)\n"
"> e2 <- quote(plot(x, y))\n"
msgstr ""

#. type: Plain text
#: R-lang.texi:3193
msgid "The arguments are not evaluated, the result is simply the parsed argument.  The objects @code{e1} and @code{e2} may be evaluated later using @code{eval}, or simply manipulated as data.  It is perhaps most immediately obvious why the @code{e2} object has mode @code{\"call\"}, since it involves a call to the @code{plot} function with some arguments.  However, @code{e1} actually has exactly the same structure as a call to the binary operator @code{+} with two arguments, a fact that gets clearly displayed by the following"
msgstr ""

#. type: example
#: R-lang.texi:3197
#, no-wrap
msgid ""
"> quote(\"+\"(2, 2))\n"
"2 + 2\n"
msgstr ""

#. type: Plain text
#: R-lang.texi:3204
msgid "The components of a call object are accessed using a list-like syntax, and may in fact be converted to and from lists using @code{as.list} and @code{as.call}"
msgstr ""

#. type: example
#: R-lang.texi:3212
#, no-wrap
msgid ""
"> e2[[1]]\n"
"plot\n"
"> e2[[2]]\n"
"x\n"
"> e2[[3]]\n"
"y\n"
msgstr ""

#. type: Plain text
#: R-lang.texi:3216
msgid "When keyword argument matching is used, the keywords can be used as list tags:"
msgstr ""

#. type: example
#: R-lang.texi:3223
#, no-wrap
msgid ""
"> e3 <- quote(plot(x = age, y = weight))\n"
"> e3$x\n"
"age\n"
"> e3$y\n"
"weight\n"
msgstr ""

#. type: Plain text
#: R-lang.texi:3231
msgid "All the components of the call object have mode @code{\"name\"} in the preceding examples.  This is true for identifiers in calls, but the components of a call can also be constants---which can be of any type, although the first component had better be a function if the call is to be evaluated successfully---or other call objects, corresponding to subexpressions.  Objects of mode"
msgstr ""

#. type: Plain text
#: R-lang.texi:3235
msgid "name can be constructed from character strings using @code{as.name}, so one might modify the @code{e2} object as follows"
msgstr ""

#. type: example
#: R-lang.texi:3240
#, no-wrap
msgid ""
"> e2[[1]] <- as.name(\"+\")\n"
"> e2\n"
"x + y\n"
msgstr ""

#. type: Plain text
#: R-lang.texi:3244
msgid "To illustrate the fact that subexpressions are simply components that are themselves calls, consider"
msgstr ""

#. type: example
#: R-lang.texi:3249
#, no-wrap
msgid ""
"> e1[[2]] <- e2\n"
"> e1\n"
"x + y + 2\n"
msgstr ""

#. type: Plain text
#: R-lang.texi:3257
msgid "All grouping parentheses in input are preserved in parsed expressions.  They are represented as a function call with one argument, so that @code{4 - (2 - 2)} becomes @code{\"-\"(4, \"(\" (\"-\"(2, 2)))} in prefix notation.  In evaluations, the @samp{(} operator just returns its argument."
msgstr ""

#. type: Plain text
#: R-lang.texi:3259
msgid "This is a bit unfortunate, but it is not easy to write a"
msgstr ""

#. type: Plain text
#: R-lang.texi:3264
msgid "parser/deparser combination that both preserves user input, stores it in minimal form and ensures that parsing a deparsed expression gives the same expression back."
msgstr ""

#. type: Plain text
#: R-lang.texi:3267
msgid "As it happens, @R{}'s parser is not perfectly invertible, nor is its deparser, as the following examples show"
msgstr ""

#. type: example
#: R-lang.texi:3281
#, no-wrap
msgid ""
"> str(quote(c(1,2)))\n"
" language c(1, 2)\n"
"> str(c(1,2))\n"
" num [1:2] 1 2\n"
"> deparse(quote(c(1,2)))\n"
"[1] \"c(1, 2)\"\n"
"> deparse(c(1,2))\n"
"[1] \"c(1, 2)\"\n"
"> quote(\"-\"(2, 2))\n"
"2 - 2\n"
"> quote(2 - 2)\n"
"2 - 2\n"
msgstr ""

#. type: Plain text
#: R-lang.texi:3286
msgid "Deparsed expressions should, however, evaluate to an equivalent value to the original expression (up to rounding error)."
msgstr ""

#. type: Plain text
#: R-lang.texi:3289
msgid "...internal storage of flow control constructs...note Splus incompatibility..."
msgstr ""

#. type: Plain text
#: R-lang.texi:3298
msgid "It is in fact not often that one wants to modify the innards of an expression like in the previous section.  More frequently, one wants to simply get at an expression in order to deparse it and use it for labeling plots, for instance.  An example of this is seen at the beginning of @code{plot.default}:"
msgstr ""

#. type: findex
#: R-lang.texi:3298
#, no-wrap
msgid "substitute"
msgstr ""

#. type: example
#: R-lang.texi:3303
#, no-wrap
msgid ""
"xlabel <- if (!missing(x))\n"
"    deparse(substitute(x))\n"
msgstr ""

#. type: Plain text
#: R-lang.texi:3308
msgid "This causes the variable or expression given as the @code{x} argument to @code{plot} to be used for labeling the x-axis later on."
msgstr ""

#. type: Plain text
#: R-lang.texi:3314
msgid "The function used to achieve this is @code{substitute} which takes the expression @code{x} and substitutes the expression that was passed through the formal argument @code{x}.  Notice that for this to happen, @code{x} must carry information about the expression that creates its value.  This is related to the"
msgstr ""

#. type: Plain text
#: R-lang.texi:3323
msgid "lazy evaluation scheme of @R{} (@pxref{Promise objects}).  A formal argument is really a @emph{promise}, an object with three slots, one for the expression that defines it, one for the environment in which to evaluate that expression, and one for the value of that expression once evaluated. @code{substitute} will recognize a promise variable and substitute the value of its expression slot.  If @code{substitute} is invoked inside a function, the local variables of the function are also subject to substitution."
msgstr ""

#. type: Plain text
#: R-lang.texi:3329
msgid "The argument to @code{substitute} does not have to be a simple identifier, it can be an expression involving several variables and substitution will occur for each of these.  Also, @code{substitute} has an additional argument which can be an environment or a list in which the variables are looked up.  For example:"
msgstr ""

#. type: example
#: R-lang.texi:3333
#, no-wrap
msgid ""
"> substitute(a + b, list(a = 1, b = quote(x)))\n"
"1 + x\n"
msgstr ""

#. type: Plain text
#: R-lang.texi:3338
msgid "Notice that quoting was necessary to substitute the @code{x}.  This kind of construction comes in handy in connection with the facilities for putting math expression in graphs, as the following case shows"
msgstr ""

#. type: example
#: R-lang.texi:3344
#: R-lang.texi:3427
#, no-wrap
msgid ""
"> plot(0)\n"
"> for (i in 1:4)\n"
"+   text(1, 0.2 * i,\n"
"+        substitute(x[ix] == y, list(ix = i, y = pnorm(i))))\n"
msgstr ""

#. type: Plain text
#: R-lang.texi:3355
msgid "It is important to realize that the substitutions are purely lexical; there is no checking that the resulting call objects make sense if they are evaluated.  @code{substitute(x <- x + 1, list(x = 2))} will happily return @code{2 <- 2 + 1}.  However, some parts of @R{} make up their own rules for what makes sense and what does not and might actually have a use for such ill-formed expressions.  For example, using the ``math in graphs'' feature often involves constructions that are syntactically correct, but which would be meaningless to evaluate, like @samp{@{@}>=40*\" years\"}."
msgstr ""

#. type: Plain text
#: R-lang.texi:3359
msgid "Substitute will not evaluate its first argument.  This leads to the puzzle of how to do substitutions on an object that is contained in a variable.  The solution is to use @code{substitute} once more, like this"
msgstr ""

#. type: example
#: R-lang.texi:3366
#, no-wrap
msgid ""
"> expr <- quote(x + y)\n"
"> substitute(substitute(e, list(x = 3)), list(e = expr))\n"
"substitute(x + y, list(x = 3))\n"
"> eval(substitute(substitute(e, list(x = 3)), list(e = expr)))\n"
"3 + y\n"
msgstr ""

#. type: Plain text
#: R-lang.texi:3369
msgid "The exact rules for substitutions are as follows: Each"
msgstr ""

#. type: Plain text
#: R-lang.texi:3371
msgid "symbol in the"
msgstr ""

#. type: Plain text
#: R-lang.texi:3382
msgid "parse tree for the first is matched against the second argument, which can be a tagged list or an environment frame.  If it is a simple local object, its value is inserted, @emph{except} if matching against the global environment.  If it is a promise (usually a function argument), the promise expression is substituted.  If the symbol is not matched, it is left untouched.  The special exception for substituting at the top level is admittedly peculiar.  It has been inherited from @Sl{} and the rationale is most likely that there is no control over which variables might be bound at that level so that it would be better to just make substitute act as @code{quote}."
msgstr ""

#. type: Plain text
#: R-lang.texi:3390
msgid "The rule of promise substitution is slightly different from that of @Sl{} if the local variable is modified before @code{substitute} is used.  @R{} will then use the new value of the variable, whereas @Sl{} will unconditionally use the argument expression---unless it was a constant, which has the curious consequence that @code{f((1))} may be very different from @code{f(1)} in @Sl{}.  The @R{} rule is considerably cleaner, although it does have consequences in connection with"
msgstr ""

#. type: Plain text
#: R-lang.texi:3393
msgid "lazy evaluation that comes as a surprise to some.  Consider"
msgstr ""

#. type: example
#: R-lang.texi:3399
#, no-wrap
msgid ""
"logplot <- function(y, ylab = deparse(substitute(y))) @{\n"
"    y <- log(y)\n"
"    plot(y, ylab = ylab)\n"
"@}\n"
msgstr ""

#. type: Plain text
#: R-lang.texi:3406
msgid "This looks straightforward, but one will discover that the y label becomes an ugly @code{c(...)} expression.  It happens because the rules of lazy evaluation cause the evaluation of the @code{ylab} expression to happen @emph{after} @code{y} has been modified.  The solution is to force @code{ylab} to be evaluated first, i.e.,"
msgstr ""

#. type: example
#: R-lang.texi:3413
#, no-wrap
msgid ""
"logplot <- function(y, ylab = deparse(substitute(y))) @{\n"
"    ylab\n"
"    y <- log(y)\n"
"    plot(y, ylab = ylab)\n"
"@}\n"
msgstr ""

#. type: Plain text
#: R-lang.texi:3419
msgid "Notice that one should not use @code{eval(ylab)} in this situation.  If @code{ylab} is a language or expression object, then that would cause the object to be evaluated as well, which would not at all be desirable if a math expression like @code{quote(log[e](y))} was being passed."
msgstr ""

#. type: Plain text
#: R-lang.texi:3422
msgid "A variant on @code{substitute} is @code{bquote}, which is used to replace some subexpressions with their values.  The example from above"
msgstr ""

#. type: Plain text
#: R-lang.texi:3429
msgid "could be written more compactly as"
msgstr ""

#. type: example
#: R-lang.texi:3433
#, no-wrap
msgid ""
"plot(0)\n"
"for(i in 1:4)\n"
"   text(1, 0.2*i, bquote( x[.(i)] == .(pnorm(i)) ))\n"
msgstr ""

#. type: Plain text
#: R-lang.texi:3440
msgid "The expression is quoted except for the contents of @code{.()} subexpressions, which are replaced with their values. There is an optional argument to compute the values in a different environment. The syntax for @code{bquote} is borrowed from the LISP backquote macro."
msgstr ""

#. type: Plain text
#: R-lang.texi:3448
msgid "The @code{eval} function was introduced earlier in this chapter as a means of evaluating call objects.  However, this is not the full story.  It is also possible to specify the"
msgstr ""

#. type: Plain text
#: R-lang.texi:3453
msgid "environment in which the evaluation is to take place. By default this is the evaluation frame from which @code{eval} is called, but quite frequently it needs to be set to something else."
msgstr ""

#. type: findex
#: R-lang.texi:3453
#, no-wrap
msgid "eval"
msgstr ""

#. type: Plain text
#: R-lang.texi:3461
msgid "Very often, the relevant evaluation frame is that of the parent of the current frame (cf.@: ???).  In particular, when the object to evaluate is the result of a @code{substitute} operation of the function arguments, it will contain variables that make sense to the caller only (notice that there is no reason to expect that the variables of the caller are in the"
msgstr ""

#. type: Plain text
#: R-lang.texi:3465
msgid "lexical scope of the callee).  Since evaluation in the parent frame occurs frequently, an @code{eval.parent} function exists as a shorthand for @code{eval(expr, sys.frame(sys.parent()))}."
msgstr ""

#. type: Plain text
#: R-lang.texi:3476
msgid "Another case that occurs frequently is evaluation in a list or a data frame.  For instance, this happens in connection with the @code{model.frame} function when a @code{data} argument is given.  Generally, the terms of the model formula need to be evaluated in @code{data}, but they may occasionally also contain references to items in the caller of @code{model.frame}.  This is sometimes useful in connection with simulation studies.  So for this purpose one needs not only to evaluate an expression in a list, but also to specify an enclosure into which the search continues if the variable is not in the list.  Hence, the call has the form"
msgstr ""

#. type: example
#: R-lang.texi:3479
#, no-wrap
msgid "eval(expr, data, sys.frame(sys.parent()))\n"
msgstr ""

#. type: Plain text
#: R-lang.texi:3483
msgid "Notice that evaluation in a given environment may actually change that environment, most obviously in cases involving the"
msgstr ""

#. type: Plain text
#: R-lang.texi:3486
msgid "assignment operator, such as"
msgstr ""

#. type: example
#: R-lang.texi:3489
#, no-wrap
msgid "eval(quote(total <- 0), environment(robert$balance)) # @r{rob Rob}\n"
msgstr ""

#. type: Plain text
#: R-lang.texi:3494
msgid "This is also true when evaluating in lists, but the original list does not change because one is really working on a copy."
msgstr ""

#. type: Plain text
#: R-lang.texi:3501
msgid "Objects of mode @code{\"expression\"} are defined in @ref{Expression objects}.  They are very similar to lists of call objects."
msgstr ""

#. type: example
#: R-lang.texi:3510
#, no-wrap
msgid ""
"> ex <- expression(2 + 2, 3 + 4)\n"
"> ex[[1]]\n"
"2 + 2\n"
"> ex[[2]]\n"
"3 + 4\n"
"> eval(ex)\n"
"[1] 7\n"
msgstr ""

#. type: Plain text
#: R-lang.texi:3523
msgid "Notice that evaluating an expression object evaluates each call in turn, but the final value is that of the last call.  In this respect it behaves almost identically to the compound language object @code{quote(@{2 + 2; 3 + 4@})}.  However, there is a subtle difference: Call objects are indistinguishable from subexpressions in a parse tree.  This means that they are automatically evaluated in the same way a subexpression would be.  Expression objects can be recognized during evaluation and in a sense retain their quotedness.  The evaluator will not evaluate an expression object recursively, only when it is passed directly to @code{eval} function as above.  The difference can be seen like this:"
msgstr ""

#. type: example
#: R-lang.texi:3529
#, no-wrap
msgid ""
"> eval(substitute(mode(x), list(x = quote(2 + 2))))\n"
"[1] \"numeric\"\n"
"> eval(substitute(mode(x), list(x = expression(2 + 2))))\n"
"[1] \"expression\"\n"
msgstr ""

#. type: Plain text
#: R-lang.texi:3536
msgid "The deparser represents an expression object by the call that creates it.  This is similar to the way it handles numerical vectors and several other objects that do not have a specific external representation.  However, it does lead to the following bit of confusion:"
msgstr ""

#. type: example
#: R-lang.texi:3548
#, no-wrap
msgid ""
"> e <- quote(expression(2 + 2))\n"
"> e\n"
"expression(2 + 2)\n"
"> mode(e)\n"
"[1] \"call\"\n"
"> ee <- expression(2 + 2)\n"
"> ee\n"
"expression(2 + 2)\n"
"> mode(ee)\n"
"[1] \"expression\"\n"
msgstr ""

#. type: Plain text
#: R-lang.texi:3554
msgid "I.e., @code{e} and @code{ee} look identical when printed, but one is a call that generates an expression object and the other is the object itself."
msgstr ""

#. type: Plain text
#: R-lang.texi:3559
msgid "It is possible for a"
msgstr ""

#. type: Plain text
#: R-lang.texi:3563
msgid "function to find out how it has been called by looking at the result of @code{sys.call} as in the following example of a function that simply returns its own call:"
msgstr ""

#. type: example
#: R-lang.texi:3568
#, no-wrap
msgid ""
"> f <- function(x, y, ...) sys.call()\n"
"> f(y = 1, 2, z = 3, 4)\n"
"f(y = 1, 2, z = 3, 4)\n"
msgstr ""

#. type: Plain text
#: R-lang.texi:3575
msgid "However, this is not really useful except for debugging because it requires the function to keep track of argument matching in order to interpret the call.  For instance, it must be able to see that the 2nd actual argument gets matched to the first formal one (@code{x} in the above example)."
msgstr ""

#. type: Plain text
#: R-lang.texi:3580
msgid "More often one requires the call with all actual arguments bound to the corresponding formals.  To this end, the function @code{match.call} is used.  Here's a variant of the preceding example, a function that returns its own call with arguments matched"
msgstr ""

#. type: example
#: R-lang.texi:3585
#, no-wrap
msgid ""
"> f <- function(x, y, ...) match.call()\n"
"> f(y = 1, 2, z = 3, 4)\n"
"f(x = 2, y = 1, z = 3, 4)\n"
msgstr ""

#. type: Plain text
#: R-lang.texi:3589
msgid "Notice that the second argument now gets matched to @code{x} and appears in the corresponding position in the result."
msgstr ""

#. type: Plain text
#: R-lang.texi:3593
msgid "The primary use of this technique is to call another function with the same arguments, possibly deleting some and adding others.  A typical application is seen at the start of the @code{lm} function:"
msgstr ""

#. type: example
#: R-lang.texi:3601
#, no-wrap
msgid ""
"    mf <- cl <- match.call()\n"
"    mf$singular.ok <- mf$model <- mf$method <- NULL\n"
"    mf$x <- mf$y <- mf$qr <- mf$contrasts <- NULL\n"
"    mf$drop.unused.levels <- TRUE\n"
"    mf[[1]] <- as.name(\"model.frame\")\n"
"    mf <- eval(mf, sys.frame(sys.parent()))\n"
msgstr ""

#. type: Plain text
#: R-lang.texi:3604
msgid "Notice that the resulting call is"
msgstr ""

#. type: Plain text
#: R-lang.texi:3613
msgid "evaluated in the parent frame, in which one can be certain that the involved expressions make sense.  The call can be treated as a list object where the first element is the name of the function and the remaining elements are the actual argument expressions, with the corresponding formal argument names as tags.  Thus, the technique to eliminate undesired arguments is to assign @code{NULL}, as seen in lines 2 and 3, and to add an argument one uses tagged list"
msgstr ""

#. type: Plain text
#: R-lang.texi:3619
msgid "assignment (here to pass @code{drop.unused.levels = TRUE})  as in line 4.  To change the name of the function called, assign to the first element of the list and make sure that the value is a name, either using the @code{as.name(\"model.frame\")} construction here or @code{quote(model.frame)}."
msgstr ""

#. type: Plain text
#: R-lang.texi:3623
msgid "The @code{match.call} function has an @code{expand.dots} argument which is a switch which if set to @code{FALSE} lets all @samp{...} arguments be collected as a single argument with the tag @samp{...}."
msgstr ""

#. type: example
#: R-lang.texi:3629
#, no-wrap
msgid ""
"> f <- function(x, y, ...) match.call(expand.dots = FALSE)\n"
"> f(y = 1, 2, z = 3, 4)\n"
"f(x = 2, y = 1, ... = list(z = 3, 4))\n"
msgstr ""

#. type: Plain text
#: R-lang.texi:3633
msgid "The @samp{...} argument is a list (a pairlist to be precise), not a call to @code{list} like it is in @Sl{}:"
msgstr ""

#. type: example
#: R-lang.texi:3639
#, no-wrap
msgid ""
"> e1 <- f(y = 1, 2, z = 3, 4)$...\n"
"> e1\n"
"$z\n"
"[1] 3\n"
"\n"
msgstr ""

#. type: example
#: R-lang.texi:3642
#, no-wrap
msgid ""
"[[2]]\n"
"[1] 4\n"
msgstr ""

#. type: Plain text
#: R-lang.texi:3648
msgid "One reason for using this form of @code{match.call} is simply to get rid of any @samp{...} arguments in order not to be passing unspecified arguments on to functions that may not know them.  Here's an example paraphrased from @code{plot.formula}:"
msgstr ""

#. type: example
#: R-lang.texi:3653
#, no-wrap
msgid ""
"m <- match.call(expand.dots = FALSE)\n"
"m$... <- NULL\n"
"m[[1]] <- \"model.frame\"\n"
msgstr ""

#. type: Plain text
#: R-lang.texi:3658
msgid "A more elaborate application is in @code{update.default} where a set of optional extra arguments can add to, replace, or cancel those of the original call:"
msgstr ""

#. type: example
#: R-lang.texi:3669
#, no-wrap
msgid ""
"extras <- match.call(expand.dots = FALSE)$...\n"
"if (length(extras) > 0) @{\n"
"    existing <- !is.na(match(names(extras), names(call)))\n"
"    for (a in names(extras)[existing]) call[[a]] <- extras[[a]]\n"
"    if (any(!existing)) @{\n"
"        call <- c(as.list(call), extras[!existing])\n"
"        call <- as.call(call)\n"
"    @}\n"
"@}\n"
msgstr ""

#. type: Plain text
#: R-lang.texi:3674
msgid "Notice that care is taken to modify existing arguments individually in case @code{extras[[a]] == NULL}.  Concatenation does not work on call objects without the coercion as shown; this is arguably a bug."
msgstr ""

#. type: Plain text
#: R-lang.texi:3677
msgid "Two further functions exist for the construction of function calls, namely @code{call} and @code{do.call}."
msgstr ""

#. type: Plain text
#: R-lang.texi:3680
msgid "The function @code{call} allows creation of a call object from the function name and the list of arguments"
msgstr ""

#. type: example
#: R-lang.texi:3685
#, no-wrap
msgid ""
"> x <- 10.5\n"
"> call(\"round\", x)\n"
"round(10.5)\n"
msgstr ""

#. type: Plain text
#: R-lang.texi:3688
msgid "As seen, the value of @code{x} rather than the"
msgstr ""

#. type: Plain text
#: R-lang.texi:3693
msgid "symbol is inserted in the call, so it is distinctly different from @code{round(x)}.  The form is used rather rarely, but is occasionally useful where the name of a function is available as a character variable."
msgstr ""

#. type: Plain text
#: R-lang.texi:3698
msgid "The function @code{do.call} is related, but evaluates the call immediately and takes the arguments from an object of mode @code{\"list\"} containing all the arguments.  A natural use of this is when one wants to apply a function like @code{cbind} to all elements of a list or data frame."
msgstr ""

#. type: findex
#: R-lang.texi:3698
#, no-wrap
msgid "do.call"
msgstr ""

#. type: example
#: R-lang.texi:3706
#, no-wrap
msgid ""
"is.na.data.frame <- function (x) @{\n"
"    y <- do.call(\"cbind\", lapply(x, \"is.na\"))\n"
"    rownames(y) <- row.names(x)\n"
"    y\n"
"@}\n"
msgstr ""

#. type: Plain text
#: R-lang.texi:3713
msgid "Other uses include variations over constructions like @code{do.call(\"f\", list(...))}.  However, one should be aware that this involves evaluation of the arguments before the actual function call, which may defeat aspects of lazy evaluation and argument substitution in the function itself.  A similar remark applies to the @code{call} function."
msgstr ""

#. type: Plain text
#: R-lang.texi:3719
msgid "It is often useful to be able to manipulate the components of a"
msgstr ""

#. type: Plain text
#: R-lang.texi:3723
msgid "function or closure.  @R{} provides a set of interface functions for this purpose."
msgstr ""

#. type: Plain text
#: R-lang.texi:3725
msgid "@ftable @code"
msgstr ""

#. type: Plain text
#: R-lang.texi:3727
msgid "Returns the expression that is the body of the function."
msgstr ""

#. type: Plain text
#: R-lang.texi:3730
msgid "Returns a list of the formal arguments to the function.  This is a @code{pairlist}."
msgstr ""

#. type: Plain text
#: R-lang.texi:3733
msgid "Returns the environment associated with the function."
msgstr ""

#. type: item
#: R-lang.texi:3733
#, no-wrap
msgid "body<-"
msgstr ""

#. type: Plain text
#: R-lang.texi:3735
msgid "This sets the body of the function to the supplied expression."
msgstr ""

#. type: item
#: R-lang.texi:3735
#, no-wrap
msgid "formals<-"
msgstr ""

#. type: Plain text
#: R-lang.texi:3737
msgid "Sets the formal arguments of the function to the supplied list."
msgstr ""

#. type: item
#: R-lang.texi:3737
#, no-wrap
msgid "environment<-"
msgstr ""

#. type: Plain text
#: R-lang.texi:3739
msgid "Sets the environment of the function to the specified environment."
msgstr ""

#. type: Plain text
#: R-lang.texi:3744
msgid "It is also possible to alter the bindings of different variables in the environment of the function, using code along the lines of @code{evalq(x <- 5, environment(f))}."
msgstr ""

#. type: Plain text
#: R-lang.texi:3746
msgid "It is also possible to convert a"
msgstr ""

#. type: Plain text
#: R-lang.texi:3755
msgid "function to a list using @code{as.list}.  The result is the concatenation of the list of formal arguments with the function body.  Conversely such a list can be converted to a function using @code{as.function}.  This functionality is mainly included for @Sl{} compatibility.  Notice that environment information is lost when @code{as.list} is used, whereas @code{as.function} has an argument that allows the environment to be set."
msgstr ""

#. type: node
#: R-lang.texi:3763
#: R-lang.texi:3765
#: R-lang.texi:3766
#: R-lang.texi:3851
#, no-wrap
msgid "Operating system access"
msgstr ""

#. type: node
#: R-lang.texi:3763
#: R-lang.texi:3765
#: R-lang.texi:3851
#: R-lang.texi:3852
#: R-lang.texi:3871
#, no-wrap
msgid "Foreign language interfaces"
msgstr ""

#. type: section
#: R-lang.texi:3763
#: R-lang.texi:3851
#: R-lang.texi:3871
#: R-lang.texi:3872
#, no-wrap
msgid ".Internal and .Primitive"
msgstr ""

#. type: Plain text
#: R-lang.texi:3770
msgid "Access to the operating system shell is via the @R{} function @code{system}."
msgstr ""

#. type: findex
#: R-lang.texi:3770
#, no-wrap
msgid "system"
msgstr ""

#. type: Plain text
#: R-lang.texi:3777
msgid "The details will differ by platform (see the on-line help), and about all that can safely be assumed is that the first argument will be a string @code{command} that will be passed for execution (not necessarily by a shell) and the second argument will be @code{internal} which if true will collect the output of the command into an @R{} character vector."
msgstr ""

#. type: Plain text
#: R-lang.texi:3779
msgid "The functions @code{system.time}"
msgstr ""

#. type: findex
#: R-lang.texi:3779
#, no-wrap
msgid "system.time"
msgstr ""

#. type: Plain text
#: R-lang.texi:3781
msgid "and @code{proc.time}"
msgstr ""

#. type: findex
#: R-lang.texi:3781
#, no-wrap
msgid "proc.time"
msgstr ""

#. type: Plain text
#: R-lang.texi:3784
msgid "are available for timing (although the information available may be limited on non-Unix-like platforms)."
msgstr ""

#. type: Plain text
#: R-lang.texi:3786
msgid "Information from the operating system"
msgstr ""

#. type: Plain text
#: R-lang.texi:3788
msgid "environment can be accessed and manipulated with"
msgstr ""

#. type: item
#: R-lang.texi:3790
#, no-wrap
msgid "@code{Sys.getenv} @tab OS environment variables"
msgstr ""

#. type: findex
#: R-lang.texi:3791
#, no-wrap
msgid "Sys.getenv"
msgstr ""

#. type: findex
#: R-lang.texi:3792
#: R-lang.texi:3793
#, no-wrap
msgid "Sys.putenv"
msgstr ""

#. type: item
#: R-lang.texi:3794
#, no-wrap
msgid "@code{Sys.getlocale} @tab System locale"
msgstr ""

#. type: findex
#: R-lang.texi:3795
#, no-wrap
msgid "Sys.getlocale"
msgstr ""

#. type: findex
#: R-lang.texi:3796
#: R-lang.texi:3797
#, no-wrap
msgid "Sys.putlocale"
msgstr ""

#. type: findex
#: R-lang.texi:3798
#: R-lang.texi:3799
#, no-wrap
msgid "Sys.localeconv"
msgstr ""

#. type: item
#: R-lang.texi:3800
#, no-wrap
msgid "@code{Sys.time} @tab Current time"
msgstr ""

#. type: findex
#: R-lang.texi:3801
#, no-wrap
msgid "Sys.time"
msgstr ""

#. type: item
#: R-lang.texi:3802
#, no-wrap
msgid "@code{Sys.timezone} @tab Time zone"
msgstr ""

#. type: findex
#: R-lang.texi:3803
#, no-wrap
msgid "Sys.timezone"
msgstr ""

#. type: Plain text
#: R-lang.texi:3809
msgid "A uniform set of file access functions is provided on all platforms:"
msgstr ""

#. type: item
#: R-lang.texi:3811
#, no-wrap
msgid "@code{file.access} @tab Ascertain File Accessibility"
msgstr ""

#. type: findex
#: R-lang.texi:3812
#, no-wrap
msgid "file.access"
msgstr ""

#. type: item
#: R-lang.texi:3813
#, no-wrap
msgid "@code{file.append} @tab Concatenate files"
msgstr ""

#. type: findex
#: R-lang.texi:3814
#, no-wrap
msgid "file.append"
msgstr ""

#. type: item
#: R-lang.texi:3815
#, no-wrap
msgid "@code{file.choose} @tab Prompt user for file name"
msgstr ""

#. type: findex
#: R-lang.texi:3816
#, no-wrap
msgid "file.choose"
msgstr ""

#. type: item
#: R-lang.texi:3817
#, no-wrap
msgid "@code{file.copy}  @tab Copy files"
msgstr ""

#. type: findex
#: R-lang.texi:3818
#, no-wrap
msgid "file.copy"
msgstr ""

#. type: item
#: R-lang.texi:3819
#, no-wrap
msgid "@code{file.create} @tab Create or truncate a files"
msgstr ""

#. type: findex
#: R-lang.texi:3820
#, no-wrap
msgid "file.create"
msgstr ""

#. type: item
#: R-lang.texi:3821
#, no-wrap
msgid "@code{file.exists} @tab Test for existence"
msgstr ""

#. type: findex
#: R-lang.texi:3822
#, no-wrap
msgid "file.exists"
msgstr ""

#. type: item
#: R-lang.texi:3823
#, no-wrap
msgid "@code{file.info} @tab Miscellaneous file information"
msgstr ""

#. type: findex
#: R-lang.texi:3824
#, no-wrap
msgid "file.info"
msgstr ""

#. type: item
#: R-lang.texi:3825
#, no-wrap
msgid "@code{file.remove} @tab remove files"
msgstr ""

#. type: findex
#: R-lang.texi:3826
#, no-wrap
msgid "file.remove"
msgstr ""

#. type: item
#: R-lang.texi:3827
#, no-wrap
msgid "@code{file.rename} @tab rename files"
msgstr ""

#. type: findex
#: R-lang.texi:3828
#, no-wrap
msgid "file.rename"
msgstr ""

#. type: item
#: R-lang.texi:3829
#, no-wrap
msgid "@code{file.show} @tab Display a text file"
msgstr ""

#. type: findex
#: R-lang.texi:3830
#, no-wrap
msgid "file.show"
msgstr ""

#. type: item
#: R-lang.texi:3831
#, no-wrap
msgid "@code{unlink} @tab Remove files or directories."
msgstr ""

#. type: findex
#: R-lang.texi:3832
#, no-wrap
msgid "unlink"
msgstr ""

#. type: Plain text
#: R-lang.texi:3838
msgid "There are also functions for manipulating file names and paths in a platform-independent way."
msgstr ""

#. type: item
#: R-lang.texi:3840
#, no-wrap
msgid "@code{basename} @tab File name without directory"
msgstr ""

#. type: findex
#: R-lang.texi:3841
#, no-wrap
msgid "basename"
msgstr ""

#. type: item
#: R-lang.texi:3842
#, no-wrap
msgid "@code{dirname} @tab Directory name"
msgstr ""

#. type: findex
#: R-lang.texi:3843
#, no-wrap
msgid "dirname"
msgstr ""

#. type: item
#: R-lang.texi:3844
#, no-wrap
msgid "@code{file.path} @tab Construct path to file"
msgstr ""

#. type: findex
#: R-lang.texi:3845
#, no-wrap
msgid "file.path"
msgstr ""

#. type: item
#: R-lang.texi:3846
#, no-wrap
msgid "@code{path.expand} @tab Expand @code{~} in Unix path"
msgstr ""

#. type: findex
#: R-lang.texi:3847
#, no-wrap
msgid "path.expand"
msgstr ""

#. type: findex
#: R-lang.texi:3853
#, no-wrap
msgid ".C"
msgstr ""

#. type: findex
#: R-lang.texi:3854
#, no-wrap
msgid ".Fortran"
msgstr ""

#. type: findex
#: R-lang.texi:3855
#, no-wrap
msgid ".Call"
msgstr ""

#. type: findex
#: R-lang.texi:3856
#, no-wrap
msgid ".External"
msgstr ""

#. type: Plain text
#: R-lang.texi:3861
msgid "See @ref{System and foreign language interfaces, , , R-exts, Writing R Extensions} for the details of adding functionality to @R{} via compiled code."
msgstr ""

#. type: Plain text
#: R-lang.texi:3867
msgid "Functions @code{.C} and @code{.Fortran} provide a standard interface to compiled code that has been linked into @R{}, either at build time or via @code{dyn.load}.  They are primarily intended for compiled @C{} and FORTRAN code respectively, but the @code{.C} function can be used with other languages which can generate C interfaces, for example C++."
msgstr ""

#. type: Plain text
#: R-lang.texi:3870
msgid "Functions @code{.Call} and @code{.External} provide interfaces which allow compiled code (primarily compiled @C{} code) to manipulate @R{} objects."
msgstr ""

#. type: Plain text
#: R-lang.texi:3879
msgid "The @code{.Internal} and @code{.Primitive} interfaces are used to call @C{} code compiled into @R{} at build time.  @xref{.Internal vs .Primitive, , , R-ints, R Internals}."
msgstr ""

#. type: Plain text
#: R-lang.texi:3888
msgid "The exception handling facilities in @R{} are provided through two mechanisms.  Functions such as @code{stop} or @code{warning} can be called directly or options such as @code{\"warn\"} can be used to control the handling of problems."
msgstr ""

#. type: node
#: R-lang.texi:3894
#: R-lang.texi:3896
#: R-lang.texi:3897
#: R-lang.texi:3898
#: R-lang.texi:3903
#, no-wrap
msgid "stop"
msgstr ""

#. type: node
#: R-lang.texi:3894
#: R-lang.texi:3896
#: R-lang.texi:3903
#: R-lang.texi:3904
#: R-lang.texi:3905
#: R-lang.texi:3924
#, no-wrap
msgid "warning"
msgstr ""

#. type: node
#: R-lang.texi:3894
#: R-lang.texi:3903
#: R-lang.texi:3924
#: R-lang.texi:3925
#: R-lang.texi:3926
#: R-lang.texi:3969
#, no-wrap
msgid "on.exit"
msgstr ""

#. type: section
#: R-lang.texi:3894
#: R-lang.texi:3924
#: R-lang.texi:3969
#: R-lang.texi:3970
#, no-wrap
msgid "Error options"
msgstr ""

#. type: Plain text
#: R-lang.texi:3902
msgid "A call to @code{stop} halts the evaluation of the current expression, prints the message argument and returns execution to top-level."
msgstr ""

#. type: findex
#: R-lang.texi:3906
#, no-wrap
msgid "warnings"
msgstr ""

#. type: Plain text
#: R-lang.texi:3914
msgid "The function @code{warning} takes a single argument that is a character string.  The behaviour of a call to @code{warning} depends on the value of the option @code{\"warn\"}.  If @code{\"warn\"} is negative warnings are ignored.  If it is zero, they are stored and printed after the top-level function has completed.  If it is one, they are printed as they occur and if it is 2 (or larger) warnings are turned into errors."
msgstr ""

#. type: Plain text
#: R-lang.texi:3923
msgid "If @code{\"warn\"} is zero (the default), a variable @code{last.warning} is created and the messages associated with each call to @code{warning} are stored, sequentially, in this vector.  If there are fewer than 10 warnings they are printed after the function has finished evaluating.  If there are more than 10 then a message indicating how many warnings occurred is printed.  In either case @code{last.warning} contains the vector of messages, and @code{warnings} provides a way to access and print it."
msgstr ""

#. type: Plain text
#: R-lang.texi:3935
msgid "A function can insert a call to @code{on.exit} at any point in the body of a function.  The effect of a call to @code{on.exit} is to store the value of the body so that it will be executed when the function exits.  This allows the function to change some system parameters and to ensure that they are reset to appropriate values when the function is finished.  The @code{on.exit} is guaranteed to be executed when the function exits either directly or as the result of a warning."
msgstr ""

#. type: Plain text
#: R-lang.texi:3939
msgid "An error in the evaluation of the @code{on.exit} code causes an immediate jump to top-level without further processing of the @code{on.exit} code."
msgstr ""

#. type: Plain text
#: R-lang.texi:3942
msgid "@code{on.exit} takes a single argument which is an expression to be evaluated when the function is exited."
msgstr ""

#. type: Plain text
#: R-lang.texi:3975
msgid "There are a number of @code{options} variables that can be used to control how @R{} handles errors and warnings.  They are listed in the table below."
msgstr ""

#. type: item
#: R-lang.texi:3977
#, no-wrap
msgid "warn"
msgstr ""

#. type: table
#: R-lang.texi:3979
msgid "Controls the printing of warnings."
msgstr ""

#. type: item
#: R-lang.texi:3979
#, no-wrap
msgid "warning.expression"
msgstr ""

#. type: table
#: R-lang.texi:3982
msgid "Sets an expression that is to be evaluated when a warning occurs.  The normal printing of warnings is suppressed if this option is set."
msgstr ""

#. type: item
#: R-lang.texi:3982
#, no-wrap
msgid "error"
msgstr ""

#. type: table
#: R-lang.texi:3986
msgid "Installs an expression that will be evaluated when an error occurs.  The normal printing of error messages and warning messages precedes the evaluation of the expression."
msgstr ""

#. type: Plain text
#: R-lang.texi:3990
msgid "Expressions installed by @code{options(\"error\")} are evaluated before calls to @code{on.exit} are carried out."
msgstr ""

#. type: Plain text
#: R-lang.texi:3994
msgid "One can use @code{options(error = expression(q(\"yes\")))} to get @R{} to quit when an error has been signalled.  In this case an error will cause @R{} to shut down and the global environment will be saved."
msgstr ""

#. type: Plain text
#: R-lang.texi:4002
msgid "Debugging code has always been a bit of an art.  @R{} provides several tools that help users find problems in their code.  These tools halt execution at particular points in the code and the current state of the computation can be inspected."
msgstr ""

#. type: Plain text
#: R-lang.texi:4007
msgid "Most debugging takes place either through calls to @code{browser} or @code{debug}.  Both of these functions rely on the same internal mechanism and both provide the user with a special prompt.  Any command can be typed at the prompt.  The evaluation"
msgstr ""

#. type: Plain text
#: R-lang.texi:4011
msgid "environment for the command is the currently active environment.  This allows you to examine the current state of any variables etc."
msgstr ""

#. type: Plain text
#: R-lang.texi:4014
msgid "There are five special commands that @R{} interprets differently.  They are,"
msgstr ""

#. type: key{#1}
#: R-lang.texi:4016
#, no-wrap
msgid "RET"
msgstr ""

#. type: table
#: R-lang.texi:4019
msgid "Go to the next statement if the function is being debugged.  Continue execution if the browser was invoked."
msgstr ""

#. type: item
#: R-lang.texi:4019
#, no-wrap
msgid "c"
msgstr ""

#. type: itemx
#: R-lang.texi:4020
#, no-wrap
msgid "cont"
msgstr ""

#. type: table
#: R-lang.texi:4022
msgid "Continue the execution."
msgstr ""

#. type: item
#: R-lang.texi:4022
#, no-wrap
msgid "n"
msgstr ""

#. type: table
#: R-lang.texi:4025
msgid "Execute the next statement in the function.  This works from the browser as well."
msgstr ""

#. type: item
#: R-lang.texi:4025
#, no-wrap
msgid "where"
msgstr ""

#. type: table
#: R-lang.texi:4027
msgid "Show the call stack"
msgstr ""

#. type: item
#: R-lang.texi:4027
#, no-wrap
msgid "Q"
msgstr ""

#. type: table
#: R-lang.texi:4029
msgid "Halt execution and jump to the top-level immediately."
msgstr ""

#. type: Plain text
#: R-lang.texi:4036
msgid "If there is a local variable with the same name as one of the special commands listed above then its value can be accessed by using @code{get}.  A call to @code{get} with the name in quotes will retrieve the value in the current"
msgstr ""

#. type: Plain text
#: R-lang.texi:4038
msgid "environment."
msgstr ""

#. type: Plain text
#: R-lang.texi:4044
msgid "The debugger provides access only to interpreted expressions.  If a function calls a foreign language (such as @C{}) then no access to the statements in that language is provided.  Execution will halt on the next statement that is evaluated in @R{}. A symbolic debugger such as @code{gdb} can be used to debug compiled code."
msgstr ""

#. type: node
#: R-lang.texi:4050
#: R-lang.texi:4052
#: R-lang.texi:4053
#: R-lang.texi:4054
#: R-lang.texi:4074
#, no-wrap
msgid "browser"
msgstr ""

#. type: node
#: R-lang.texi:4050
#: R-lang.texi:4052
#: R-lang.texi:4074
#: R-lang.texi:4075
#: R-lang.texi:4120
#, no-wrap
msgid "debug/undebug"
msgstr ""

#. type: node
#: R-lang.texi:4050
#: R-lang.texi:4074
#: R-lang.texi:4120
#: R-lang.texi:4121
#: R-lang.texi:4142
#, no-wrap
msgid "trace/untrace"
msgstr ""

#. type: findex
#: R-lang.texi:4050
#: R-lang.texi:4120
#: R-lang.texi:4142
#: R-lang.texi:4143
#: R-lang.texi:4144
#, no-wrap
msgid "traceback"
msgstr ""

#. type: Plain text
#: R-lang.texi:4059
msgid "A call to the function @code{browser} causes @R{} to halt execution at that point and to provide the user with a special prompt.  Arguments to @code{browser} are ignored."
msgstr ""

#. type: example
#: R-lang.texi:4072
#, no-wrap
msgid ""
"> foo <- function(s) @{\n"
"+ c <- 3\n"
"+ browser()\n"
"+ @}\n"
"> foo(4)\n"
"Called from: foo(4)\n"
"Browse[1]> s\n"
"[1] 4\n"
"Browse[1]> get(\"c\")\n"
"[1] 3\n"
"Browse[1]>\n"
msgstr ""

#. type: findex
#: R-lang.texi:4076
#, no-wrap
msgid "debug"
msgstr ""

#. type: findex
#: R-lang.texi:4077
#, no-wrap
msgid "undebug"
msgstr ""

#. type: Plain text
#: R-lang.texi:4086
msgid "The debugger can be invoked on any function by using the command @code{debug(@var{fun})}.  Subsequently, each time that function is evaluated the debugger is invoked.  The debugger allows you to control the evaluation of the statements in the body of the function.  Before each statement is executed the statement is printed out and a special prompt provided.  Any command can be given, those in the table above have special meaning."
msgstr ""

#. type: Plain text
#: R-lang.texi:4089
msgid "Debugging is turned off by a call to @code{undebug} with the function as an argument."
msgstr ""

#. type: example
#: R-lang.texi:4118
#, no-wrap
msgid ""
"> debug(mean.default)\n"
"> mean(1:10)\n"
"debugging in: mean.default(1:10)\n"
"debug: @{\n"
"    if (na.rm)\n"
"        x <- x[!is.na(x)]\n"
"    trim <- trim[1]\n"
"    n <- length(c(x, recursive = TRUE))\n"
"    if (trim > 0) @{\n"
"        if (trim >= 0.5)\n"
"            return(median(x, na.rm = FALSE))\n"
"        lo <- floor(n * trim) + 1\n"
"        hi <- n + 1 - lo\n"
"        x <- sort(x, partial = unique(c(lo, hi)))[lo:hi]\n"
"        n <- hi - lo + 1\n"
"    @}\n"
"    sum(x)/n\n"
"@}\n"
"Browse[1]>\n"
"debug: if (na.rm) x <- x[!is.na(x)]\n"
"Browse[1]>\n"
"debug: trim <- trim[1]\n"
"Browse[1]>\n"
"debug: n <- length(c(x, recursive = TRUE))\n"
"Browse[1]> c\n"
"exiting from: mean.default(1:10)\n"
"[1] 5.5\n"
msgstr ""

#. type: findex
#: R-lang.texi:4122
#, no-wrap
msgid "trace"
msgstr ""

#. type: findex
#: R-lang.texi:4123
#, no-wrap
msgid "untrace"
msgstr ""

#. type: Plain text
#: R-lang.texi:4130
msgid "Another way of monitoring the behaviour of @R{} is through the @code{trace} mechanism.  @code{trace} is called with a single argument that is the name of the function you want to trace.  The name does not need to be quoted but for some functions you will need to quote the name in order to avoid a syntax error."
msgstr ""

#. type: Plain text
#: R-lang.texi:4134
msgid "When @code{trace} has been invoked on a function then every time that function is evaluated the call to it is printed out.  This mechanism is removed by calling @code{untrace} with the function as an argument."
msgstr ""

#. type: example
#: R-lang.texi:4140
#, no-wrap
msgid ""
"> trace(\"[<-\")\n"
"> x <- 1:10\n"
"> x[3] <- 4\n"
"trace: \"[<-\"(*tmp*, 3, value = 4)\n"
msgstr ""

#. type: Plain text
#: R-lang.texi:4151
msgid "When an error has caused a jump to top-level a special variable called @code{.Traceback} is placed into the base environment.  @code{.Traceback} is a character vector with one entry for each function call that was active at the time the error occurred.  An examination of @code{.Traceback} can be carried out by a call to @code{traceback}."
msgstr ""

#. type: Plain text
#: R-lang.texi:4161
msgid "The parser is what converts the textual representation of @R{} code into an internal form which may then be passed to the @R{} evaluator which causes the specified instructions to be carried out.  The internal form is itself an @R{} object and can be saved and otherwise manipulated within the @R{} system."
msgstr ""

#. type: node
#: R-lang.texi:4168
#: R-lang.texi:4170
#: R-lang.texi:4172
#: R-lang.texi:4180
#: R-lang.texi:4216
#: R-lang.texi:4234
#: R-lang.texi:4250
#, no-wrap
msgid "The parsing process"
msgstr ""

#. type: node
#: R-lang.texi:4168
#: R-lang.texi:4170
#: R-lang.texi:4250
#: R-lang.texi:4252
#: R-lang.texi:4266
#, no-wrap
msgid "Comments"
msgstr ""

#. type: node
#: R-lang.texi:4168
#: R-lang.texi:4250
#: R-lang.texi:4266
#: R-lang.texi:4268
#: R-lang.texi:4286
#: R-lang.texi:4407
#: R-lang.texi:4442
#: R-lang.texi:4455
#: R-lang.texi:4477
#: R-lang.texi:4507
#: R-lang.texi:4527
#: R-lang.texi:4537
#: R-lang.texi:4546
#, no-wrap
msgid "Tokens"
msgstr ""

#. type: node
#: R-lang.texi:4168
#: R-lang.texi:4266
#: R-lang.texi:4546
#: R-lang.texi:4547
#: R-lang.texi:4569
#: R-lang.texi:4606
#: R-lang.texi:4669
#: R-lang.texi:4707
#: R-lang.texi:4720
#: R-lang.texi:4753
#: R-lang.texi:4780
#, no-wrap
msgid "Expressions"
msgstr ""

#. type: section
#: R-lang.texi:4168
#: R-lang.texi:4546
#: R-lang.texi:4780
#: R-lang.texi:4781
#, no-wrap
msgid "Directives"
msgstr ""

#. type: node
#: R-lang.texi:4178
#: R-lang.texi:4180
#: R-lang.texi:4182
#: R-lang.texi:4216
#, no-wrap
msgid "Modes of parsing"
msgstr ""

#. type: node
#: R-lang.texi:4178
#: R-lang.texi:4180
#: R-lang.texi:4216
#: R-lang.texi:4218
#: R-lang.texi:4234
#, no-wrap
msgid "Internal representation"
msgstr ""

#. type: subsection
#: R-lang.texi:4178
#: R-lang.texi:4216
#: R-lang.texi:4234
#: R-lang.texi:4236
#, no-wrap
msgid "Deparsing"
msgstr ""

#. type: Plain text
#: R-lang.texi:4185
msgid "Parsing in @R{} occurs in three different variants:"
msgstr ""

#. type: item
#: R-lang.texi:4187
#, no-wrap
msgid "The read-eval-print loop"
msgstr ""

#. type: item
#: R-lang.texi:4188
#, no-wrap
msgid "Parsing of text files"
msgstr ""

#. type: item
#: R-lang.texi:4189
#, no-wrap
msgid "Parsing of character strings"
msgstr ""

#. type: Plain text
#: R-lang.texi:4204
msgid "The read-eval-print loop forms the basic command line interface to @R{}.  Textual input is read until a complete @R{} expression is available.  Expressions may be split over several input lines.  The primary prompt (by default @samp{> }) indicates that the parser is ready for a new expression, and a continuation prompt (by default @samp{+ }) indicates that the parser expects the remainder of an incomplete expression.  The expression is converted to internal form during input and the parsed expression is passed to the evaluator and the result is printed (unless specifically made invisible).  If the parser finds itself in a state which is incompatible with the language syntax, a ``Syntax Error'' is flagged and the parser resets itself and resumes input at the beginning of the next input line."
msgstr ""

#. type: Plain text
#: R-lang.texi:4211
msgid "Text files can be parsed using the @code{parse} function.  In particular, this is done during execution of the @code{source} function, which allows commands to be stored in an external file and executed as if they had been typed at the keyboard.  Note, though, that the entire file is parsed and syntax checked before any evaluation takes place."
msgstr ""

#. type: Plain text
#: R-lang.texi:4215
msgid "Character strings, or vectors thereof, can be parsed using the @code{text=} argument to @code{parse}.  The strings are treated exactly as if they were the lines of an input file."
msgstr ""

#. type: Plain text
#: R-lang.texi:4225
msgid "Parsed expressions are stored in an @R{} object containing the parse tree.  A fuller description of such objects can be found in @ref{Language objects} and @ref{Expression objects}.  Briefly, every elementary @R{} expression is stored in"
msgstr ""

#. type: Plain text
#: R-lang.texi:4233
msgid "function call form, as a list with the first element containing the function name and the remainder containing the arguments, which may in turn be further @R{} expressions.  The list elements can be named, corresponding to tagged matching of formal and actual arguments.  Note that @emph{all} @R{} syntax elements are treated in this way, e.g.@: the assignment @code{x <- 1} is encoded as @code{\"<-\"(x, 1)}."
msgstr ""

#. type: Plain text
#: R-lang.texi:4249
msgid "Any @R{} object can be converted to an @R{} expression using @code{deparse}.  This is frequently used in connection with output of results, e.g.@: for labeling plots.  Notice that only objects of mode @code{\"expression\"} can be expected to be unchanged by reparsing the output of deparsing.  For instance, the numeric vector @code{1:5} will deparse as @code{\"c(1, 2, 3, 4, 5)\"}, which will reparse as a call to the function @code{c}.  As far as possible, evaluating the deparsed and reparsed expression gives the same result as evaluating the original, but there are a couple of awkward exceptions, mostly involving expressions that weren't generated from a textual representation in the first place."
msgstr ""

#. type: cindex
#: R-lang.texi:4254
#, no-wrap
msgid "comments"
msgstr ""

#. type: Plain text
#: R-lang.texi:4256
msgid "Comments in @R{} are ignored by the parser.  Any text from a"
msgstr ""

#. type: findex
#: R-lang.texi:4256
#, no-wrap
msgid "#"
msgstr ""

#. type: Plain text
#: R-lang.texi:4260
msgid "@code{#} character to the end of the line is taken to be a comment, unless the @code{#} character is inside a quoted string. For example,"
msgstr ""

#. type: example
#: R-lang.texi:4264
#, no-wrap
msgid ""
"> x <- 1  # This is a comment...\n"
"> y <- \"  #... but this is not.\"\n"
msgstr ""

#. type: Plain text
#: R-lang.texi:4274
msgid "Tokens are the elementary building blocks of a programming language.  They are recognised during @emph{lexical analysis} which (conceptually, at least) takes place prior to the syntactic analysis performed by the parser itself."
msgstr ""

#. type: node
#: R-lang.texi:4284
#: R-lang.texi:4286
#: R-lang.texi:4407
#, no-wrap
msgid "Literal constants"
msgstr ""

#. type: node
#: R-lang.texi:4284
#: R-lang.texi:4286
#: R-lang.texi:4407
#: R-lang.texi:4408
#: R-lang.texi:4442
#, no-wrap
msgid "Identifiers"
msgstr ""

#. type: node
#: R-lang.texi:4284
#: R-lang.texi:4407
#: R-lang.texi:4442
#: R-lang.texi:4443
#: R-lang.texi:4455
#, no-wrap
msgid "Reserved words"
msgstr ""

#. type: node
#: R-lang.texi:4284
#: R-lang.texi:4442
#: R-lang.texi:4455
#: R-lang.texi:4456
#: R-lang.texi:4477
#, no-wrap
msgid "Special operators"
msgstr ""

#. type: node
#: R-lang.texi:4284
#: R-lang.texi:4455
#: R-lang.texi:4477
#: R-lang.texi:4478
#: R-lang.texi:4507
#, no-wrap
msgid "Separators"
msgstr ""

#. type: node
#: R-lang.texi:4284
#: R-lang.texi:4477
#: R-lang.texi:4507
#: R-lang.texi:4508
#: R-lang.texi:4527
#, no-wrap
msgid "Operator tokens"
msgstr ""

#. type: node
#: R-lang.texi:4284
#: R-lang.texi:4507
#: R-lang.texi:4527
#: R-lang.texi:4528
#: R-lang.texi:4537
#, no-wrap
msgid "Grouping"
msgstr ""

#. type: subsection
#: R-lang.texi:4284
#: R-lang.texi:4527
#: R-lang.texi:4537
#: R-lang.texi:4538
#, no-wrap
msgid "Indexing tokens"
msgstr ""

#. type: Plain text
#: R-lang.texi:4291
msgid "There are five types of constants: integer, logical, numeric, complex and string."
msgstr ""

#. type: Plain text
#: R-lang.texi:4294
msgid "In addition, there are four special constants, @code{NULL}, @code{NA}, @code{Inf}, and @code{NaN}."
msgstr ""

#. type: Plain text
#: R-lang.texi:4300
msgid "@code{NULL} is used to indicate the empty object.  @code{NA} is used for absent (``Not Available'') data values.  @code{Inf} denotes infinity and @code{NaN} is not-a-number in the @acronym{IEEE} floating point calculus (results of the operations respectively @math{1/0} and @math{0/0}, for instance)."
msgstr ""

#. type: Plain text
#: R-lang.texi:4302
msgid "Logical constants are either @code{TRUE} or @code{FALSE}."
msgstr ""

#. type: Plain text
#: R-lang.texi:4310
msgid "Numeric constants follow a similar syntax to that of the @C{} language.  They consist of an integer part consisting of zero or more digits, followed optionally by @samp{.} and a fractional part of zero or more digits optionally followed by an exponent part consisting of an @samp{E} or an @samp{e}, an optional sign and a string of one or more digits.  Either the fractional or the decimal part can be empty, but not both at once."
msgstr ""

#. type: example
#: R-lang.texi:4313
#, no-wrap
msgid "@r{Valid numeric constants:} 1 10 0.1 .2 1e-7 1.2e+7\n"
msgstr ""

#. type: Plain text
#: R-lang.texi:4319
msgid "Numeric constants can also be hexadecimal, starting with @samp{0x} or @samp{0x} followed by zero or more digits, @samp{a-f} or @samp{A-F}.  Hexadecimal floating point constants are supported using C99 syntax, e.g.  @samp{0x1.1p1}."
msgstr ""

#. type: Plain text
#: R-lang.texi:4330
msgid "There is now a separate class of integer constants.  They are created by using the qualifier @code{L} at the end of the number.  For example, @code{123L} gives an integer value rather than a numeric value.  The suffix @code{L} can be used to qualify any non-complex number with the intent of creating an integer.  So it can be used with numbers given by hexadecimal or scientific notation. However, if the value is not a valid integer, a warning is emitted and the numeric value created.  The following shows examples of valid integer constants, values which will generate a warning and give numeric constants and syntax errors."
msgstr ""

#. type: example
#: R-lang.texi:4335
#, no-wrap
msgid ""
"@r{Valid integer constants:}  1L, 0x10L, 1000000L, 1e6L\n"
"@r{Valid numeric constants:}  1.1L, 1e-3L, 0x1.1p-2\n"
"@r{Syntax error:}  12iL 0x1.1\n"
msgstr ""

#. type: Plain text
#: R-lang.texi:4340
msgid "A warning is emitted for decimal values that contain an unnecessary decimal point, e.g. @code{1.L}.  It is an error to have a decimal point in a hexadecimal constant without the binary exponent."
msgstr ""

#. type: Plain text
#: R-lang.texi:4343
msgid "Note also that a preceding sign (@code{+} or @code{-}) is treated as a unary operator, not as part of the constant."
msgstr ""

#. type: Plain text
#: R-lang.texi:4346
msgid "Up-to-date information on the currently accepted formats can be found by @code{?NumericConstants}."
msgstr ""

#. type: Plain text
#: R-lang.texi:4351
msgid "Complex constants have the form of a decimal numeric constant followed by @samp{i}.  Notice that only purely imaginary numbers are actual constants, other complex numbers are parsed a unary or binary operations on numeric and imaginary numbers."
msgstr ""

#. type: example
#: R-lang.texi:4354
#, no-wrap
msgid "@r{Valid complex constants:} 2i 4.1i 1e-2i\n"
msgstr ""

#. type: Plain text
#: R-lang.texi:4360
msgid "String constants are delimited by a pair of single (@samp{'}) or double (@samp{\"}) quotes and can contain all other printable characters.  Quotes and other special characters within strings are specified using @emph{escape sequences}:"
msgstr ""

#. type: item
#: R-lang.texi:4362
#, no-wrap
msgid "\\'"
msgstr ""

#. type: table
#: R-lang.texi:4364
msgid "single quote"
msgstr ""

#. type: item
#: R-lang.texi:4364
#, no-wrap
msgid "\\\""
msgstr ""

#. type: table
#: R-lang.texi:4366
msgid "double quote"
msgstr ""

#. type: item
#: R-lang.texi:4366
#, no-wrap
msgid "\\n"
msgstr ""

#. type: table
#: R-lang.texi:4368
msgid "newline"
msgstr ""

#. type: item
#: R-lang.texi:4368
#, no-wrap
msgid "\\r"
msgstr ""

#. type: table
#: R-lang.texi:4370
msgid "carriage return"
msgstr ""

#. type: item
#: R-lang.texi:4370
#, no-wrap
msgid "\\t"
msgstr ""

#. type: table
#: R-lang.texi:4372
msgid "tab character"
msgstr ""

#. type: item
#: R-lang.texi:4372
#, no-wrap
msgid "\\b"
msgstr ""

#. type: table
#: R-lang.texi:4374
msgid "backspace"
msgstr ""

#. type: item
#: R-lang.texi:4374
#, no-wrap
msgid "\\a"
msgstr ""

#. type: table
#: R-lang.texi:4376
msgid "bell"
msgstr ""

#. type: item
#: R-lang.texi:4376
#, no-wrap
msgid "\\f"
msgstr ""

#. type: table
#: R-lang.texi:4378
msgid "form feed"
msgstr ""

#. type: item
#: R-lang.texi:4378
#, no-wrap
msgid "\\v"
msgstr ""

#. type: table
#: R-lang.texi:4380
msgid "vertical tab"
msgstr ""

#. type: item
#: R-lang.texi:4380
#, no-wrap
msgid "\\\\"
msgstr ""

#. type: table
#: R-lang.texi:4382
msgid "backslash itself"
msgstr ""

#. type: item
#: R-lang.texi:4382
#, no-wrap
msgid "\\@var{nnn}"
msgstr ""

#. type: table
#: R-lang.texi:4385
msgid "character with given octal code -- sequences of one, two or three digits in the range @code{0 ... 7} are accepted."
msgstr ""

#. type: item
#: R-lang.texi:4385
#, no-wrap
msgid "\\x@var{nn}"
msgstr ""

#. type: table
#: R-lang.texi:4388
msgid "character with given hex code -- sequences of one or two hex digits (with entries @code{0 ... 9 A ... F a ... f})."
msgstr ""

#. type: item
#: R-lang.texi:4388
#, no-wrap
msgid "\\u@var{nnnn} \\u@{@var{nnnn}@}"
msgstr ""

#. type: table
#: R-lang.texi:4392
msgid "(where multibyte locales are supported, otherwise an error).  Unicode character with given hex code -- sequences of up to four hex digits. The character needs to be valid in the current locale."
msgstr ""

#. type: item
#: R-lang.texi:4392
#, no-wrap
msgid "\\U@var{nnnnnnnn} \\U@{@var{nnnnnnnn}@}"
msgstr ""

#. type: table
#: R-lang.texi:4396
msgid "(where multibyte locales are supported and not on Windows, otherwise an error).  Unicode character with given hex code -- sequences of up to eight hex digits."
msgstr ""

#. type: Plain text
#: R-lang.texi:4401
msgid "A single quote may also be embedded directly in a double-quote delimited string and vice versa."
msgstr ""

#. type: Plain text
#: R-lang.texi:4406
msgid "As from @R{} 2.8.0, a `nul' (@code{\\0}) is not allowed in a character string, so using @code{\\0} in a string constant terminates the constant (usually with a warning): further characters up to the closing quote are scanned but ignored."
msgstr ""

#. type: cindex
#: R-lang.texi:4410
#, no-wrap
msgid "identifier"
msgstr ""

#. type: Plain text
#: R-lang.texi:4414
msgid "Identifiers consist of a sequence of letters, digits, the period (@samp{.}) and the underscore.  They must not start with a digit or an underscore, or with a period followed by a digit."
msgstr ""

#. type: Plain text
#: R-lang.texi:4419
msgid "The definition of a letter depends on the current locale: the precise set of characters allowed is given by the C expression @code{(isalnum(c)  || c == '.' || c == '_')} and will include accented letters in many Western European locales."
msgstr ""

#. type: Plain text
#: R-lang.texi:4423
msgid "Notice that identifiers starting with a period are not by default listed by the @code{ls} function and that @samp{...} and @samp{..1}, @samp{..2}, etc.@: are special."
msgstr ""

#. type: Plain text
#: R-lang.texi:4431
msgid "Notice also that objects can have names that are not identifiers.  These are generally accessed via @code{get} and @code{assign}, although they can also be represented by text strings in some limited circumstances when there is no ambiguity (e.g.@: @code{\"x\" <- 1}). As @code{get} and @code{assign} are not restricted to names that are identifiers they do not recognise subscripting operators or replacement functions. The following pairs are @emph{not} equivalent"
msgstr ""

#. type: findex
#: R-lang.texi:4431
#, no-wrap
msgid "get"
msgstr ""

#. type: findex
#: R-lang.texi:4432
#, no-wrap
msgid "assign"
msgstr ""

#. type: item
#: R-lang.texi:4436
#, no-wrap
msgid "@code{x$a<-1} @tab @code{assign(\"x$a\",1)}"
msgstr ""

#. type: item
#: R-lang.texi:4437
#, no-wrap
msgid "@code{x[[1]]} @tab @code{get(\"x[[1]]\")}"
msgstr ""

#. type: item
#: R-lang.texi:4438
#, no-wrap
msgid "@code{names(x)<-nm} @tab @code{assign(\"names(x)\",nm)}"
msgstr ""

#. type: Plain text
#: R-lang.texi:4447
msgid "The following identifiers have a special meaning and cannot be used for object names"
msgstr ""

#. type: example
#: R-lang.texi:4453
#, no-wrap
msgid ""
"if else repeat while function for in next break\n"
"TRUE FALSE NULL Inf NaN\n"
"NA NA_integer_ NA_real_ NA_complex_ NA_character_\n"
"... ..1 ..2 @r{etc.}\n"
msgstr ""

#. type: Plain text
#: R-lang.texi:4462
msgid "@R{} allows user-defined infix operators.  These have the form of a string of characters delimited by the @samp{%} character.  The string can contain any printable character except @samp{%}.  The escape sequences for strings do not apply here."
msgstr ""

#. type: Plain text
#: R-lang.texi:4464
msgid "Note that the following operators are predefined"
msgstr ""

#. type: example
#: R-lang.texi:4467
#, no-wrap
msgid "%% %*% %/% %in% %o% %x%\n"
msgstr ""

#. type: Plain text
#: R-lang.texi:4485
msgid "Although not strictly tokens, stretches of whitespace characters (spaces, tabs and formfeeds, on Windows and UTF-8 locales other Unicode whitespace characters@footnote{such as @code{U+A0}, non-breaking space, and @code{U+3000}, ideographic space.}) serve to delimit tokens in case of ambiguity, (compare @code{x<-5} and @code{x < -5})."
msgstr ""

#. type: Plain text
#: R-lang.texi:4492
msgid "Newlines have a function which is a combination of token separator and expression terminator.  If an expression can terminate at the end of the line the parser will assume it does so, otherwise the newline is treated as whitespace.  Semicolons (@samp{;}) may be used to separate elementary"
msgstr ""

#. type: Plain text
#: R-lang.texi:4494
msgid "expressions on the same line."
msgstr ""

#. type: Plain text
#: R-lang.texi:4503
msgid "Special rules apply to the @code{else} keyword: inside a compound expression, a newline before @code{else} is discarded, whereas at the outermost level, the newline terminates the @code{if} construction and a subsequent @code{else} causes a syntax error.  This somewhat anomalous behaviour occurs because @R{} should be usable in interactive mode and then it must decide whether the input expression is complete, incomplete, or invalid as soon as the user presses @key{RET}."
msgstr ""

#. type: Plain text
#: R-lang.texi:4506
msgid "The comma (@samp{,}) is used to separate function arguments and multiple indices."
msgstr ""

#. type: Plain text
#: R-lang.texi:4511
msgid "@R{} uses the following operator tokens"
msgstr ""

#. type: item
#: R-lang.texi:4514
#, no-wrap
msgid "@code{+ - * / %% ^} @tab arithmetic"
msgstr ""

#. type: item
#: R-lang.texi:4515
#, no-wrap
msgid "@code{> >= < <= == !=} @tab relational"
msgstr ""

#. type: item
#: R-lang.texi:4516
#, no-wrap
msgid "@code{! & |} @tab logical"
msgstr ""

#. type: item
#: R-lang.texi:4517
#, no-wrap
msgid "@code{~} @tab model formulae"
msgstr ""

#. type: item
#: R-lang.texi:4518
#, no-wrap
msgid "@code{-> <-} @tab assignment"
msgstr ""

#. type: item
#: R-lang.texi:4519
#, no-wrap
msgid "@code{$} @tab list indexing"
msgstr ""

#. type: item
#: R-lang.texi:4520
#, no-wrap
msgid "@code{:} @tab sequence"
msgstr ""

#. type: Plain text
#: R-lang.texi:4526
msgid "(Several of the operators have different meaning inside model formulas)"
msgstr ""

#. type: Plain text
#: R-lang.texi:4533
msgid "Ordinary parentheses---@samp{(} and @samp{)}---are used for explicit grouping within expressions and to delimit the argument lists for function definitions and function calls."
msgstr ""

#. type: Plain text
#: R-lang.texi:4536
msgid "Braces---@samp{@{} and @samp{@}}---delimit blocks of expressions in function definitions, conditional expressions, and iterative constructs."
msgstr ""

#. type: Plain text
#: R-lang.texi:4543
msgid "Indexing of arrays and vectors is performed using the single and double brackets, @samp{[]} and @samp{[[]]}.  Also, indexing tagged lists may be done using the @samp{$} operator."
msgstr ""

#. type: Plain text
#: R-lang.texi:4553
msgid "An @R{} program consists of a sequence of @R{} expressions.  An expression can be a simple expression consisting of only a constant or an identifier, or it can be a compound expression constructed from other parts (which may themselves be expressions)."
msgstr ""

#. type: Plain text
#: R-lang.texi:4556
msgid "The following sections detail the various syntactical constructs that are available."
msgstr ""

#. type: node
#: R-lang.texi:4564
#: R-lang.texi:4569
#: R-lang.texi:4606
#, no-wrap
msgid "Function calls (expressions)"
msgstr ""

#. type: node
#: R-lang.texi:4564
#: R-lang.texi:4569
#: R-lang.texi:4606
#: R-lang.texi:4607
#: R-lang.texi:4669
#, no-wrap
msgid "Infix and prefix operators"
msgstr ""

#. type: node
#: R-lang.texi:4564
#: R-lang.texi:4606
#: R-lang.texi:4669
#: R-lang.texi:4670
#: R-lang.texi:4707
#, no-wrap
msgid "Index constructions"
msgstr ""

#. type: node
#: R-lang.texi:4564
#: R-lang.texi:4669
#: R-lang.texi:4707
#: R-lang.texi:4708
#: R-lang.texi:4720
#, no-wrap
msgid "Compound expressions"
msgstr ""

#. type: node
#: R-lang.texi:4564
#: R-lang.texi:4707
#: R-lang.texi:4720
#: R-lang.texi:4721
#: R-lang.texi:4753
#, no-wrap
msgid "Flow control elements"
msgstr ""

#. type: subsection
#: R-lang.texi:4564
#: R-lang.texi:4720
#: R-lang.texi:4753
#: R-lang.texi:4754
#, no-wrap
msgid "Function definitions"
msgstr ""

#. type: Plain text
#: R-lang.texi:4575
msgid "A function call takes the form of a function reference followed by a comma-separated list of arguments within a set of parentheses."
msgstr ""

#. type: example
#: R-lang.texi:4578
#, no-wrap
msgid "@var{function_reference} ( @var{arg1}, @var{arg2}, ...... , @var{argn} )\n"
msgstr ""

#. type: Plain text
#: R-lang.texi:4581
msgid "The function reference can be either"
msgstr ""

#. type: itemize
#: R-lang.texi:4584
msgid "an identifier (the name of the function)"
msgstr ""

#. type: itemize
#: R-lang.texi:4587
msgid "a text string (ditto, but handy if the function has a name which is not a valid identifier)"
msgstr ""

#. type: itemize
#: R-lang.texi:4589
msgid "an expression (which should evaluate to a function object)"
msgstr ""

#. type: Plain text
#: R-lang.texi:4594
msgid "Each argument can be tagged (@code{@var{tag}=@var{expr}}), or just be a simple expression.  It can also be empty or it can be one of the special tokens @samp{...}, @samp{..2}, etc."
msgstr ""

#. type: Plain text
#: R-lang.texi:4596
msgid "A tag can be an identifier or a text string."
msgstr ""

#. type: Plain text
#: R-lang.texi:4598
msgid "Examples:"
msgstr ""

#. type: example
#: R-lang.texi:4604
#, no-wrap
msgid ""
"f(x)\n"
"g(tag = value, , 5)\n"
"\"odd name\"(\"strange tag\" = 5, y)\n"
"(function(x) x^2)(5)\n"
msgstr ""

#. type: Plain text
#: R-lang.texi:4610
msgid "The order of precedence (highest first) of the operators is"
msgstr ""

#. type: example
#: R-lang.texi:4628
#, no-wrap
msgid ""
"::\n"
"$ @@\n"
"^\n"
"- +                @r{(unary)}\n"
":\n"
"%@var{xyz}%\n"
"* /\n"
"+ -                @r{(binary)}\n"
"> >= < <= == !=\n"
"!\n"
"& &&\n"
"| ||\n"
"~                  @r{(unary and binary)}\n"
"-> ->>\n"
"=                  @r{(as assignment)}\n"
"<- <<-\n"
msgstr ""

#. type: Plain text
#: R-lang.texi:4631
msgid "Note that @code{:} precedes binary +/-, but not @code{^}. Hence, @code{1:3-1} is @math{0 1 2}, but @code{1:2^3} is @code{1:8}."
msgstr ""

#. type: Plain text
#: R-lang.texi:4633
msgid "The exponentiation operator @samp{^} and the"
msgstr ""

#. type: Plain text
#: R-lang.texi:4638
msgid "left assignment plus minus operators @samp{<- - = <<-} group right to left, all other operators group left to right.  That is, @code{2 ^ 2 ^ 3} is @math{2 ^ 8}, not @math{4 ^ 3}, whereas @code{1 - 1 - 1} is @math{-1}, not 1."
msgstr ""

#. type: Plain text
#: R-lang.texi:4641
msgid "Notice that the operators @code{%%} and @code{%/%} for integer remainder and divide have higher precedence than multiply and divide."
msgstr ""

#. type: Plain text
#: R-lang.texi:4646
msgid "Although it is not strictly an operator, it also needs mentioning that the @samp{=} sign is used for tagging arguments in function calls and for assigning default values in function definitions."
msgstr ""

#. type: Plain text
#: R-lang.texi:4651
msgid "The @samp{$} sign is in some sense an operator, but does not allow arbitrary right hand sides and is discussed under @ref{Index constructions}.  It has higher precedence than any of the other operators."
msgstr ""

#. type: Plain text
#: R-lang.texi:4655
msgid "The parsed form of a unary or binary operation is completely equivalent to a function call with the operator as the function name and the operands as the function arguments."
msgstr ""

#. type: Plain text
#: R-lang.texi:4660
msgid "Parentheses are recorded as equivalent to a unary operator, with name @code{\"(\"}, even in cases where the parentheses could be inferred from operator precedence (e.g., @code{a * (b + c)})."
msgstr ""

#. type: Plain text
#: R-lang.texi:4662
msgid "Notice that the"
msgstr ""

#. type: Plain text
#: R-lang.texi:4668
msgid "assignment symbols are operators just like the arithmetic, relational, and logical ones.  Any expression is allowed also on the target side of an assignment, as far as the parser is concerned (@code{2 + 2 <- 5} is a valid expression as far as the parser is concerned.  The evaluator will object, though).  Similar comments apply to the model formula operator."
msgstr ""

#. type: Plain text
#: R-lang.texi:4674
msgid "@R{} has three indexing constructs, two of which are syntactically similar although with somewhat different semantics:"
msgstr ""

#. type: example
#: R-lang.texi:4678
#, no-wrap
msgid ""
"@var{object} [ @var{arg1}, ...... , @var{argn} ]\n"
"@var{object} [[ @var{arg1}, ...... , @var{argn} ]]\n"
msgstr ""

#. type: Plain text
#: R-lang.texi:4686
msgid "The @var{object} can formally be any valid expression, but it is understood to denote or evaluate to a subsettable object.  The arguments generally evaluate to numerical or character indices, but other kinds of arguments are possible (notably @code{drop = FALSE})."
msgstr ""

#. type: Plain text
#: R-lang.texi:4689
msgid "Internally, these index constructs are stored as function calls with function name @code{\"[\"} respectively @code{\"[[\"}."
msgstr ""

#. type: Plain text
#: R-lang.texi:4691
msgid "The third index construction is"
msgstr ""

#. type: example
#: R-lang.texi:4694
#, no-wrap
msgid "@var{object} $ @var{tag}\n"
msgstr ""

#. type: Plain text
#: R-lang.texi:4700
msgid "Here, @var{object} is as above, whereas @var{tag} is an identifier or a text string.  Internally, it is stored as a function call with name @code{\"$\"}"
msgstr ""

#. type: Plain text
#: R-lang.texi:4711
msgid "A compound expression is of the form"
msgstr ""

#. type: example
#: R-lang.texi:4714
#, no-wrap
msgid "@{ @var{expr1} ; @var{expr2} ; ...... ; @var{exprn} @}\n"
msgstr ""

#. type: Plain text
#: R-lang.texi:4719
msgid "The semicolons may be replaced by newlines.  Internally, this is stored as a function call with @code{\"@{\"} as the function name and the expressions as arguments."
msgstr ""

#. type: Plain text
#: R-lang.texi:4725
msgid "@R{} contains the following control structures as special syntactic constructs"
msgstr ""

#. type: example
#: R-lang.texi:4732
#, no-wrap
msgid ""
"if ( @var{cond} ) @var{expr}\n"
"if ( @var{cond} ) @var{expr1} else @var{expr2}\n"
"while ( @var{cond} ) @var{expr}\n"
"repeat @var{expr}\n"
"for ( @var{var} in @var{list} ) @var{expr}\n"
msgstr ""

#. type: Plain text
#: R-lang.texi:4736
msgid "The expressions in these constructs will typically be compound expressions."
msgstr ""

#. type: Plain text
#: R-lang.texi:4740
msgid "Within the loop constructs (@code{while}, @code{repeat}, @code{for}), one may use @code{break} (to terminate the loop) and @code{next} (to skip to the next iteration)."
msgstr ""

#. type: Plain text
#: R-lang.texi:4742
msgid "Internally, the constructs are stored as function calls:"
msgstr ""

#. type: example
#: R-lang.texi:4751
#, no-wrap
msgid ""
"\"if\"(@var{cond}, @var{expr})\n"
"\"if\"(@var{cond}, @var{expr1}, @var{expr2})\n"
"\"while\"(@var{cond}, @var{expr})\n"
"\"repeat\"(@var{expr})\n"
"\"for\"(@var{var}, @var{list}, @var{expr})\n"
"\"break\"()\n"
"\"next\"()\n"
msgstr ""

#. type: Plain text
#: R-lang.texi:4757
msgid "A"
msgstr ""

#. type: Plain text
#: R-lang.texi:4759
msgid "function definition is of the form"
msgstr ""

#. type: Plain text
#: R-lang.texi:4769
msgid "The function body is an expression, often a compound expression.  The @var{arglist} is a comma-separated list of items each of which can be an identifier, or of the form @samp{@var{identifier} = @var{default}}, or the special token @samp{...}.  The @var{default} can be any valid expression."
msgstr ""

#. type: Plain text
#: R-lang.texi:4773
msgid "Notice that function arguments unlike list tags, etc., cannot have ``strange names'' given as text strings."
msgstr ""

#. type: Plain text
#: R-lang.texi:4779
msgid "Internally, a function definition is stored as a function call with function name @code{function} and two arguments, the @var{arglist} and the @var{body}.  The @var{arglist} is stored as a tagged pairlist where the tags are the argument names and the values are the default expressions."
msgstr ""

#. type: cindex
#: R-lang.texi:4783
#, no-wrap
msgid "#line"
msgstr ""

#. type: Plain text
#: R-lang.texi:4788
msgid "The parser currently only supports one directive, @code{#line}.  This is similar to the C-preprocessor directive of the same name.  The syntax is"
msgstr ""

#. type: example
#: R-lang.texi:4791
#, no-wrap
msgid "@var{#line} @var{nn} [ @code{\"filename\"} ]\n"
msgstr ""

#. type: Plain text
#: R-lang.texi:4795
msgid "where @var{nn} is an integer line number, and the optional @var{filename} (in required double quotes) names the source file."
msgstr ""

#. type: Plain text
#: R-lang.texi:4800
msgid "Unlike the C directive, @code{#line} must appear as the first five characters on a line.  As in C, @var{nn} and @code{\"filename\"} entries may be separated from it by whitespace.  And unlike C, any following text on the line will be treated as a comment and ignored."
msgstr ""

#. type: Plain text
#: R-lang.texi:4806
msgid "This directive tells the parser that the following line should be assumed to be line @var{nn} of file @var{filename}.  (If the filename is not given, it is assumed to be the same as for the previous directive.)  This is not typically used by users, but may be used by preprocessors so that diagnostic messages refer to the original file."
msgstr ""

#. type: Plain text
#: R-lang.texi:4828
msgid "Richard A.@: Becker, John M.@: Chambers and Allan R.@: Wilks (1988), @emph{The New S Language.} Chapman & Hall, New York.  This book is often called the ``@emph{Blue Book}''."
msgstr ""
