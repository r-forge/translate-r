# Korean translation for translation.ko package
# doc/manual/R-data.texi
#
# Copyright (C) 2008-2015 Chel Hee Lee, and R Translation Teams
#
# This file is distributed under the same license as the R distribution.
# Chel Hee Lee <chl948@mail.usask.ca>, 2008-2015.
#
# Note that every single contributor listed on the Acknowledgement 
# assigns his or her contribution to Chel Hee Lee.
#
# Note also that your name may not be found because of incomplete 
# record keeping.  If you were overlooked, please let the maintainer 
# know and the list will be updated.  Please also contact the mainter 
# of this document in order to voluntarily participate in 
# or offer your help with this work. 
# 
msgid ""
msgstr ""
"Project-Id-Version: translation.ko_0.0.1.4\n"
"Report-Msgid-Bugs-To: chl948@mail.usask.ca\n"
"POT-Creation-Date: 2015-08-03 07:43-0600\n"
"PO-Revision-Date: 2015-07-20 22:49-0600\n"
"Last-Translator: Chel Hee Lee  <chl948@mail.usask.ca>\n"
"Language-Team: Chel Hee Lee  <chl948@mail.usask.ca>\n"
"Language: ko\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#
#. type: top
#: R-data.texi:4
#: R-data.texi:31
#: R-data.texi:49
#, no-wrap
msgid "R Data Import/Export"
msgstr "R Data Import/Export (translated in Korean)"

#
#. type: dircategory
#: R-data.texi:10
#, no-wrap
msgid "Programming"
msgstr ""

#
#. type: menuentry
#: R-data.texi:13
msgid "R Data: (R-data)"
msgstr ""

#
#. type: menuentry
#: R-data.texi:13
msgid "R Data Import/Export."
msgstr ""

#
#. type: include
#: R-data.texi:17
#, no-wrap
msgid "R-defs.texi"
msgstr ""

#
#. type: include
#: R-data.texi:18
#, no-wrap
msgid "version.texi"
msgstr ""

#
#. type: copying
#: R-data.texi:22
msgid "This manual is for R, version @value{VERSION}."
msgstr ""

#
#. type: copying
#: R-data.texi:24
msgid "@Rcopyright{2000}"
msgstr ""

#
#. type: quotation
#: R-data.texi:27
msgid "@permission{}"
msgstr ""

#
#. type: subtitle
#: R-data.texi:32
#, no-wrap
msgid "Version @value{VERSION}"
msgstr ""

#
#. type: author
#: R-data.texi:33
#, no-wrap
msgid "R Core Team"
msgstr ""

#
#. type: node
#: R-data.texi:48
#: R-data.texi:73
#: R-data.texi:112
#: R-data.texi:449
#: R-data.texi:983
#: R-data.texi:1106
#: R-data.texi:1727
#: R-data.texi:1799
#: R-data.texi:1840
#: R-data.texi:2206
#: R-data.texi:2248
#: R-data.texi:2328
#: R-data.texi:2373
#: R-data.texi:2378
#, no-wrap
msgid "Top"
msgstr ""

#
#. type: node
#: R-data.texi:48
#: R-data.texi:71
#: R-data.texi:73
#: R-data.texi:74
#: R-data.texi:112
#, no-wrap
msgid "Acknowledgements"
msgstr ""

#
#. type: node
#: R-data.texi:48
#, no-wrap
msgid "(dir)"
msgstr ""

#
#. type: ifnottex
#: R-data.texi:52
msgid "This is a guide to importing and exporting data to and from R."
msgstr "이 문서는 데이터를 R로 불러들이거나 R에서 내보내는 안내입니다. "

#
#. type: node
#: R-data.texi:71
#: R-data.texi:73
#: R-data.texi:112
#: R-data.texi:113
#: R-data.texi:163
#: R-data.texi:253
#: R-data.texi:407
#: R-data.texi:449
#, no-wrap
msgid "Introduction"
msgstr ""

#
#. type: node
#: R-data.texi:71
#: R-data.texi:112
#: R-data.texi:449
#: R-data.texi:450
#: R-data.texi:451
#: R-data.texi:467
#: R-data.texi:720
#: R-data.texi:743
#: R-data.texi:760
#: R-data.texi:848
#: R-data.texi:930
#: R-data.texi:983
#, no-wrap
msgid "Spreadsheet-like data"
msgstr ""

#
#. type: node
#: R-data.texi:71
#: R-data.texi:449
#: R-data.texi:983
#: R-data.texi:984
#: R-data.texi:985
#: R-data.texi:1001
#: R-data.texi:1092
#: R-data.texi:1106
#, no-wrap
msgid "Importing from other statistical systems"
msgstr ""

#
#. type: node
#: R-data.texi:71
#: R-data.texi:983
#: R-data.texi:1106
#: R-data.texi:1107
#: R-data.texi:1109
#: R-data.texi:1118
#: R-data.texi:1172
#: R-data.texi:1321
#: R-data.texi:1727
#, no-wrap
msgid "Relational databases"
msgstr ""

#
#. type: cindex
#: R-data.texi:71
#: R-data.texi:1106
#: R-data.texi:1727
#: R-data.texi:1728
#: R-data.texi:1729
#: R-data.texi:1741
#: R-data.texi:1770
#: R-data.texi:1799
#: R-data.texi:2110
#, no-wrap
msgid "Binary files"
msgstr ""

#
#. type: node
#: R-data.texi:71
#: R-data.texi:1727
#: R-data.texi:1799
#: R-data.texi:1800
#: R-data.texi:1840
#, no-wrap
msgid "Image files"
msgstr ""

#
#. type: node
#: R-data.texi:71
#: R-data.texi:1799
#: R-data.texi:1840
#: R-data.texi:1841
#: R-data.texi:1843
#: R-data.texi:1858
#: R-data.texi:1860
#: R-data.texi:1948
#: R-data.texi:1950
#: R-data.texi:2003
#: R-data.texi:2083
#: R-data.texi:2085
#: R-data.texi:2108
#: R-data.texi:2206
#, no-wrap
msgid "Connections"
msgstr ""

#
#. type: node
#: R-data.texi:71
#: R-data.texi:1840
#: R-data.texi:2206
#: R-data.texi:2207
#: R-data.texi:2217
#: R-data.texi:2237
#: R-data.texi:2248
#, no-wrap
msgid "Network interfaces"
msgstr ""

#
#. type: node
#: R-data.texi:71
#: R-data.texi:2206
#: R-data.texi:2248
#: R-data.texi:2249
#: R-data.texi:2328
#, no-wrap
msgid "Reading Excel spreadsheets"
msgstr ""

#
#. type: node
#: R-data.texi:71
#: R-data.texi:2248
#: R-data.texi:2328
#: R-data.texi:2329
#: R-data.texi:2373
#, no-wrap
msgid "References"
msgstr ""

#
#. type: node
#: R-data.texi:71
#: R-data.texi:2328
#: R-data.texi:2373
#: R-data.texi:2374
#: R-data.texi:2378
#, no-wrap
msgid "Function and variable index"
msgstr ""

#
#. type: unnumbered
#: R-data.texi:71
#: R-data.texi:2373
#: R-data.texi:2378
#: R-data.texi:2379
#, no-wrap
msgid "Concept index"
msgstr ""

#
#. type: Plain text
#: R-data.texi:79
msgid "The relational databases part of this manual is based in part on an earlier manual by Douglas Bates and Saikat DebRoy.  The principal author of this manual was Brian Ripley."
msgstr "이 매뉴얼의 관계형데이터베이스 부분은 부분적으로 Douglas Bates와 Saikat DebRoy의 이전 버전에 기초하고 있습니다. 이 매뉴얼의 주저자는 Brian Ripley입니다."

#
#. type: Plain text
#: R-data.texi:82
msgid "Many volunteers have contributed to the packages used here.  The principal authors of the packages mentioned are"
msgstr "많은 자원자들이 여기에 사용된 팩키지에 공헌하였습니다. 여기에 언급된 팩키지들의 주요 저자는 아래와 같습니다."

#
#. type: item
#: R-data.texi:85
#, no-wrap
msgid "@CRANpkg{DBI} @tab David A. James"
msgstr ""

#
#. type: item
#: R-data.texi:86
#, no-wrap
msgid "@CRANpkg{dataframes2xls} @tab Guido van Steen"
msgstr ""

#
#. type: item
#: R-data.texi:87
#, no-wrap
msgid "@CRANpkg{foreign} @tab Thomas Lumley, Saikat DebRoy, Douglas Bates, Duncan Murdoch and Roger Bivand"
msgstr ""

#
#. type: item
#: R-data.texi:88
#, no-wrap
msgid "@CRANpkg{gdata} @tab Gregory R. Warnes"
msgstr ""

#
#. type: item
#: R-data.texi:89
#, no-wrap
msgid "@CRANpkg{hdf5} @tab Marcus Daniels"
msgstr ""

#
#. type: item
#: R-data.texi:90
#, no-wrap
msgid "@CRANpkg{ncdf}, @CRANpkg{ncdf4} @tab David Pierce"
msgstr ""

#
#. type: item
#: R-data.texi:91
#, no-wrap
msgid "@CRANpkg{rJava} @tab Simon Urbanek"
msgstr ""

#
#. type: item
#: R-data.texi:92
#, no-wrap
msgid "@CRANpkg{RJDBC} @tab Simon Urbanek"
msgstr ""

#
#. type: item
#: R-data.texi:93
#, no-wrap
msgid "@CRANpkg{RMySQL} @tab David James and Saikat DebRoy"
msgstr ""

#
#. type: item
#: R-data.texi:94
#, no-wrap
msgid "@CRANpkg{RNetCDF} @tab Pavel Michna"
msgstr ""

#
#. type: item
#: R-data.texi:95
#, no-wrap
msgid "@CRANpkg{RODBC} @tab Michael Lapsley and Brian Ripley"
msgstr ""

#
#. type: item
#: R-data.texi:96
#, no-wrap
msgid "@CRANpkg{ROracle} @tab David A, James"
msgstr ""

#
#. type: item
#: R-data.texi:97
#, no-wrap
msgid "@CRANpkg{RPostgreSQL} @tab Sameer Kumar Prayaga and Tomoaki Nishiyama"
msgstr ""

#
#. type: item
#: R-data.texi:98
#, no-wrap
msgid "@pkg{RSPerl} @tab Duncan Temple Lang"
msgstr ""

#
#. type: item
#: R-data.texi:99
#, no-wrap
msgid "@pkg{RSPython} @tab Duncan Temple Lang"
msgstr ""

#
#. type: item
#: R-data.texi:100
#, no-wrap
msgid "@CRANpkg{RSQLite} @tab David A, James"
msgstr ""

#
#. type: item
#: R-data.texi:101
#, no-wrap
msgid "@pkg{SJava} @tab John Chambers and Duncan Temple Lang"
msgstr ""

#
#. type: item
#: R-data.texi:102
#, no-wrap
msgid "@CRANpkg{WriteXLS} @tab Marc Schwartz"
msgstr ""

#
#. type: item
#: R-data.texi:103
#, no-wrap
msgid "@CRANpkg{XLConnect} @tab Mirai Solutions GmbH"
msgstr ""

#
#. type: item
#: R-data.texi:104
#, no-wrap
msgid "@CRANpkg{xlsReadWrite} @tab Hans-Peter Suter"
msgstr ""

#
#. type: item
#: R-data.texi:105
#, no-wrap
msgid "@CRANpkg{XML} @tab Duncan Temple Lang"
msgstr ""

#
#. type: Plain text
#: R-data.texi:110
msgid "Brian Ripley is the author of the support for connections."
msgstr "Brian Ripley는 connection 지원의 저자입니다."

#
#. type: Plain text
#: R-data.texi:119
msgid "Reading data into a statistical system for analysis and exporting the results to some other system for report writing can be frustrating tasks that can take far more time than the statistical analysis itself, even though most readers will find the latter far more appealing."
msgstr "분석을 위해 통계 시스템으로 데이터를 불러들이는 것(Importing)과 보고서 작성을 위해 다른 시스템으로 결과들을 내보내는 것(Exporting)은 대부분의 독자들에게 훨씬 더 흥미로운 부분이지만 통계적 분석 그 자체 보다 더 많은 시간이 걸릴 수도 있는 매우 지루한 과정이기도 합니다"

#
#. type: Plain text
#: R-data.texi:123
msgid "This manual describes the import and export facilities available either in @R{} itself or via packages which are available from @acronym{CRAN} or elsewhere."
msgstr "이 매뉴얼에서는 R에 내장되어 있거나 CRAN에서 구할 수 있는 다양한 패키지들(packages)을 통한 데이터의 입력 및 결과 출력 장치들(facilities)에 대해 기술할 것입니다.기술된 패키지들 중 일부는 계속 개발 중이지만, 이미 충분히 유용한 기능을 제공합니다."

#
#. type: Plain text
#: R-data.texi:126
msgid "Unless otherwise stated, everything described in this manual is (at least in principle) available on all platforms running @R{}."
msgstr "따로 언급하지 않는 한, 이 매뉴얼에 기술된 모든 장치들(facilities)은 R을 구현하는 모든 플랫폼(platform)에서 사용 가능합니다."

#
#. type: Plain text
#: R-data.texi:137
msgid "In general, statistical systems like @R{} are not particularly well suited to manipulations of large-scale data.  Some other systems are better than @R{} at this, and part of the thrust of this manual is to suggest that rather than duplicating functionality in @R{} we can make another system do the work! (For example Therneau & Grambsch (2000)  commented that they preferred to do data manipulation in SAS and then use package @CRANpkg{survival} in @Sl{} for the analysis.)  Database manipulation systems are often very suitable for manipulating and extracting data: several packages to interact with DBMSs are discussed here."
msgstr "일반적으로 R과 같은 통계 시스템들은 특히 대용량 데이터(large-scale data)의 조작에 적절하지 않습니다. 이 점에 있어서는 다른 시스템들이 @R{} 보다 더 나을 수 있기 때문에, 이 매뉴얼 주제의 일부문은 R 안에서 그 같은 기능을 반복하기 보다는 우리가 다른 시스템을 사용해서 이 작업을 할 수 있다는 것을 보여주는 데 있습니다(예를 들면, Therneau & Grambsch (2000)의 저서에서 그들은 데이터 조작은 SAS로 그리고 생존분석@CRANpkg{survival} in @Sl{}로 하는 것을 선호한다고 말했습니다). 데이터베이스 조작 시스템은 종종 데이터의 조작과 추출에 보다 적합하고 DBMSs와 상호작용하는 여러 팩키지들이 여기에서 논의됩니다."

#
#. type: Plain text
#: R-data.texi:144
msgid "There are packages to allow functionality developed in languages such as @code{Java}, @code{perl} and @code{python} to be directly integrated with @R{} code, making the use of facilities in these languages even more appropriate.  (See the @CRANpkg{rJava} package from @acronym{CRAN} and the @pkg{SJava}, @pkg{RSPerl} and @pkg{RSPython} packages from the Omegahat project, @uref{http://www.omegahat.org}.)"
msgstr "직접적으로 @R{} 코드와 통합하기 위한 @code{Java}, @code{perl} 그리고 @code{python}과 같은 언어에서 개발된 기능을 허용하는 팩키지들이 있는데 보다 더 적절하게 이들 언어에서 도구들을 사용할 수 있도록 합니다(@acronym{CRAN}로부터 팩키지 @CRANpkg{rJava}와 Omegahat 프로젝트 @uref{http://www.omegahat.org}로부터  팩키지 @pkg{SJava}, @pkg{RSPerl} 그리고 @pkg{RSPython} 참고하십시오.)"

#
#. type: cindex
#: R-data.texi:146
#, no-wrap
msgid "Unix tools"
msgstr ""

#
#. type: cindex
#: R-data.texi:147
#, no-wrap
msgid "AWK"
msgstr ""

#
#. type: cindex
#: R-data.texi:148
#: R-data.texi:736
#, no-wrap
msgid "perl"
msgstr ""

#
#. type: Plain text
#: R-data.texi:156
msgid "It is also worth remembering that @R{} like @Sl{} comes from the Unix tradition of small re-usable tools, and it can be rewarding to use tools such as @code{awk} and @code{perl} to manipulate data before import or after export.  The case study in Becker, Chambers & Wilks (1988, Chapter 9) is an example of this, where Unix tools were used to check and manipulate the data before input to @Sl{}. The traditional Unix tools are now much more widely available, including for Windows."
msgstr "또한, @R{}도 @Sl{}처럼 작지만 재사용 가능한 여러 개의 도구(tools)를 이용하는 Unix 전통에서 출발했다는 점을 상기해 보았을 때, 데이터를 불러오기 하기 전이나 내보내기 한 후에 데이터를 조작하기 위하여 @code{awk}과 @code{perl} 같은 도구들을 사용해 볼만 합니다. Becker, Chambers & Wilks (1988, Chapter 9)에 있는 사례 연구에서 @Sl{}에 데이터를 입력하기 전에 여러 Unix 도구(tool)들을 데이터를 검증하고 조작하는 데 사용한 것이 그 예가 될 수 있을 것입니다. 전통적인 Unix 도구(tool)들이 이제는 Windows를 포함한 다양한 시스템에서 더욱 많이 사용되고 있습니다."

#
#. type: node
#: R-data.texi:161
#: R-data.texi:163
#: R-data.texi:164
#: R-data.texi:205
#: R-data.texi:253
#, no-wrap
msgid "Imports"
msgstr ""

#
#. type: node
#: R-data.texi:161
#: R-data.texi:163
#: R-data.texi:253
#: R-data.texi:254
#: R-data.texi:407
#, no-wrap
msgid "Export to text files"
msgstr ""

#
#. type: cindex
#: R-data.texi:161
#: R-data.texi:253
#: R-data.texi:407
#: R-data.texi:408
#: R-data.texi:409
#, no-wrap
msgid "XML"
msgstr ""

#
#. type: findex
#: R-data.texi:165
#: R-data.texi:762
#: R-data.texi:2006
#, no-wrap
msgid "scan"
msgstr ""

#
#. type: cindex
#: R-data.texi:169
#: R-data.texi:205
#: R-data.texi:206
#: R-data.texi:207
#: R-data.texi:366
#: R-data.texi:367
#, no-wrap
msgid "Encodings"
msgstr ""

#
#. type: Plain text
#: R-data.texi:176
msgid "The easiest form of data to import into @R{} is a simple text file, and this will often be acceptable for problems of small or medium scale.  The primary function to import from a text file is @code{scan}, and this underlies most of the more convenient functions discussed in @ref{Spreadsheet-like data}."
msgstr "R 에 입력하기 가장 쉬운 파일형태는 단순한 text 파일인데 이것은 주로 작거나 중간 정도 크기의 문제를 해결하는데 적합합니다. Text 파일을 읽어 들이기 위해 가장 많이 사용하는 기능은 @code{scan} 이며, 이것은 @ref{Spreadsheet-like data}에 설명되어 있는 더욱 편리한 대부분의 함수(functions)의 기초가 됩니다."

#
#. type: Plain text
#: R-data.texi:191
msgid "However, all statistical consultants are familiar with being presented by a client with a memory stick (formerly, a floppy disc or CD-R) of data in some proprietary binary format, for example `an Excel spreadsheet' or `an SPSS file'.  Often the simplest thing to do is to use the originating application to export the data as a text file (and statistical consultants will have copies of the most common applications on their computers for that purpose).  However, this is not always possible, and @ref{Importing from other statistical systems} discusses what facilities are available to access such files directly from @R{}.  For Excel spreadsheets, the available methods are summarized in @ref{Reading Excel spreadsheets}.  For ODS spreadsheets from Open Office, see the Omegahat package@footnote{Currently not available from that repository but as a source package for download from @url{http://www.omegahat.org/ROpenOffice/}.} @pkg{ROpenOffice}."
msgstr "하지만, 모든 통계 컨설턴트들은 의뢰인이 Excel 스프레드 시트나 SPSS 파일처럼 특정 binary 포맷을 가진 데이터를 플로피 디스크나 CD 에 저장한 것을 받는 경우가 대부분입니다. 일을 하는데 있어서 흔히 가장 쉬운 경우가 데이터를 text 파일 형태로 내보내는 application 을 사용해서 그 결과물을 출력하는 것입니다(그리고 통계 컨설턴트들은 이러한 작업을 하기 위해 널리 통용되고 있는 여러 개의 application 들을 그들의 컴퓨터 안에 두고 사용하기도 합니다). 그렇지만, 이렇게 application 을 이용하는 것이 언제나 가능한 것은 아니며, @ref{Importing from other statistical systems} 에서 어떠한 장치들이 R 에서 이러한 파일들을 직접 사용하는 것이 가능한지 설명하고 있습니다.Excel 스프레드 시트(spreadsheet)를 이용하기 위해 사용 가능한 방법들은 @ref{Reading Excel spreadsheets}에 요약되어 있습니다. 오픈오피스의 ODS 스프레드시트의 경우에는 the Omegahat package@footnote{Currently not available from that repository but as a source package for download from @url{http://www.omegahat.org/ROpenOffice/}.} @pkg{ROpenOffice}를 참고하시기 바랍니다."

#
#. type: Plain text
#: R-data.texi:197
msgid "In a few cases, data have been stored in a binary form for compactness and speed of access.  One application of this that we have seen several times is imaging data, which is normally stored as a stream of bytes as represented in memory, possibly preceded by a header.  Such data formats are discussed in @ref{Binary files} and @ref{Binary connections}."
msgstr "적지 않은 경우 데이터는 그 크기를 줄이고(compactness) 접근 속도를 높이기 위해(speed of access) binary 포맷으로 저장됩니다. 여기에 대한 한 가지 사례는 이미지 데이터(imaging data)를 저장하는 데서 찾을 수 있는데, 보통 엄청난 사이즈의 메모리를 차지하기 때문에 헤더(header)를 앞에 붙이기도 합니다. 이러한 형태의 데이터 포맷에 대해서는 @ref{Binary files}와 @ref{Binary connections}에서 더 찾아볼 수 있습니다."

#
#. type: Plain text
#: R-data.texi:204
msgid "For much larger databases it is common to handle the data using a database management system (DBMS).  There is once again the option of using the DBMS to extract a plain file, but for many such DBMSs the extraction operation can be done directly from an @R{} package: @xref{Relational databases}.  Importing data via network connections is discussed in @ref{Network interfaces}."
msgstr "좀 더 큰 데이터베이스에 대해서는 database management system (DBMS)을 사용해서 데이터를 처리하는 것이 일반적입니다. 또한, DBMS를 사용해서 특정한 포맷이 없는(plain) 파일을 추출해내는 것도 가능합니다. 그렇지만 DBMS와 같은 시스템들을 이용한 결과 추출 작업을 R 패키지를 사용해서 직접하는 것도 가능합니다. 이에 관하여는 @ref{Relational databases}를 참고하십시오. 네트워크 연결을 통해 데이터를 입력하는 방법은 @ref{Network interfaces}에서 찾을 수 있습니다."

#
#. type: Plain text
#: R-data.texi:214
msgid "Unless the file to be imported from is entirely in @acronym{ASCII}, it is usually necessary to know how it was encoded.  For text files, a good way to find out something about its structure is the @command{file} command-line tool (for Windows, included in @code{Rtools}).  This reports something like"
msgstr ""

#
#. type: example
#: R-data.texi:222
#, no-wrap
msgid ""
"text.Rd: UTF-8 Unicode English text\n"
"text2.dat: ISO-8859 English text\n"
"text3.dat: Little-endian UTF-16 Unicode English character data,\n"
"   with CRLF line terminators\n"
"intro.dat: UTF-8 Unicode text\n"
"intro.dat: UTF-8 Unicode (with BOM) text\n"
msgstr ""

#. type: Plain text
#: R-data.texi:237
msgid "Modern Unix-alike systems, including OS X, are likely to produce UTF-8 files.  Windows may produce what it calls `Unicode' files (@code{UCS-2LE} or just possibly @code{UTF-16LE}@footnote{the distinction is subtle, @uref{https://en.wikipedia.org/@/wiki/@/UTF-16/UCS-2}, and the use of surrogate pairs is very rare.}).  Otherwise most files will be in a 8-bit encoding unless from a Chinese/Japanese/Korean locale (which have a wide range of encodings in common use).  It is not possible to automatically detect with certainty which 8-bit encoding (although guesses may be possible and @command{file} may guess as it did in the example above), so you may simply have to ask the originator for some clues (e.g.@: `Russian on Windows')."
msgstr ""

#. type: Plain text
#: R-data.texi:248
msgid "`BOMs' (Byte Order Marks, @uref{https://en.wikipedia.org/wiki/Byte_order_mark}) cause problems for Unicode files.  In the Unix world BOMs are rarely used, whereas in the Windows world they almost always are for UCS-2/UTF-16 files, and often are for UTF-8 files.  The @command{file} utility will not even recognize UCS-2 files without a BOM, but many other utilities will refuse to read files with a BOM and the @acronym{IANA} standards for @code{UTF-16LE} and @code{UTF-16BE} prohibit it.  We have too often been reduced to looking at the file with the command-line utility @command{od} or a hex editor to work out its encoding."
msgstr ""

#
#. type: Plain text
#: R-data.texi:252
msgid "Note that @code{utf8} is not a valid encoding name (@code{UTF-8} is), and @code{macintosh} is the most portable name for what is sometimes called `Mac Roman' encoding."
msgstr ""

#
#. type: cindex
#: R-data.texi:255
#, no-wrap
msgid "Exporting to a text file"
msgstr ""

#
#. type: Plain text
#: R-data.texi:262
msgid "Exporting results from @R{} is usually a less contentious task, but there are still a number of pitfalls.  There will be a target application in mind, and normally a text file will be the most convenient interchange vehicle.  (If a binary file is required, see @ref{Binary files}.)"
msgstr "R에서 결과를 내보내는 과정은 대체로 다소 단순한 작업이지만, 여전히 많은 문제점을 안고 있습니다. 아무래도 이 작업에 사용하고자 하는 특정 어플리케이션이 있기 마련이고, 보통의 경우 text 파일이 가장 편리하게 변환할 수 있는 수단이라고 할 수 있습니다(만약 binary 파일이 필요하면, @ref{Binary files}을 참조하십시오)."

#
#. type: findex
#: R-data.texi:263
#: R-data.texi:1952
#, no-wrap
msgid "cat"
msgstr ""

#
#. type: Plain text
#: R-data.texi:270
msgid "Function @code{cat} underlies the functions for exporting data.  It takes a @code{file} argument, and the @code{append} argument allows a text file to be written via successive calls to @code{cat}.  Better, especially if this is to be done many times, is to open a @code{file} connection for writing or appending, and @code{cat} to that connection, then @code{close} it."
msgstr "함수 cat은 데이터를 추출해내는 여러 함수들 중 가장 기본이 됩니다. 이것은 하나의 파일을 인자(argument)로 하며, 인자 append는 cat 어떤 텍스트 파일이 연속적인 호출(call)을 통해 cat에 쓰여질 수 있도록 해줍니다. 만약 이런 작업이 여러 번에 걸쳐 발생한다면, file connection을 열어서 쓰기(writing), 첨가하기(appending), 그리고 cat을 connection에 연결하고 close로 file을 종료하면 됩니다."

#
#. type: findex
#: R-data.texi:271
#: R-data.texi:1953
#, no-wrap
msgid "write"
msgstr ""

#
#. type: findex
#: R-data.texi:272
#: R-data.texi:1954
#, no-wrap
msgid "write.table"
msgstr ""

#
#. type: Plain text
#: R-data.texi:281
msgid "The most common task is to write a matrix or data frame to file as a rectangular grid of numbers, possibly with row and column labels.  This can be done by the functions @code{write.table} and @code{write}.  Function @code{write} just writes out a matrix or vector in a specified number of columns (and transposes a matrix).  Function @code{write.table} is more convenient, and writes out a data frame (or an object that can be coerced to a data frame) with row and column labels."
msgstr "가장 흔히 하는 작업은 하나의 행렬 혹은 데이터 프레임을 숫자들의 열이나 행에 label을 붙인 사각형의 격자(grid) 형태로 입력하는 것입니다. 이 작업은 @code{write.table}과 @code{write} 함수로 실행될 수 있습니다. 함수 @code{write}은 단순히 정해진 숫자의 열들로 하나의 행렬이나 벡터(그리고 전치 행렬(transpose) 까지도)를 표현할 수 있습니다. 함수 @code{write.table}은 더욱 사용하기 편리하며, 행과 열의 이름과 함께 데이터 프레임(혹은 데이터 프레임이라고 정의할 수 있는 하나의 객체)을 정의할 수 있습니다."

#
#. type: Plain text
#: R-data.texi:284
msgid "There are a number of issues that need to be considered in writing out a data frame to a text file."
msgstr "하나의 데이터 프레임을 하나의 text 파일로 정의하기 위해서는 많은 부분에서 고민해 볼 필요가 있습니다."

#
#. type: findex
#: R-data.texi:286
#, no-wrap
msgid "format"
msgstr ""

#
#. type: strong{#1}
#: R-data.texi:287
#, no-wrap
msgid "Precision"
msgstr ""

#
#. type: enumerate
#: R-data.texi:293
msgid "Most of the conversions of real/complex numbers done by these functions is to full precision, but those by @code{write} are governed by the current setting of @code{options(digits)}.  For more control, use @code{format} on a data frame, possibly column-by-column."
msgstr "이러한 함수들에 의한 대부분의 실수/복소수 간 전환(conversion)은 가능한 모든 자릿수를 다 이용하지만(full precision), @code{write}에 의한 그러한 결과는 @code{options(digits)}에 의해 현재 세팅 된 자릿수(digits option)에 의해 결정됩니다. 그 이상의 컨트롤은 데이터 프레임에 @code{format)을 이용하여 열(column-by-column) 별로도 가능합니다."

#
#. type: strong{#1}
#: R-data.texi:294
#: R-data.texi:497
#, no-wrap
msgid "Header line"
msgstr ""

#
#. type: enumerate
#: R-data.texi:298
msgid "@R{} prefers the header line to have no entry for the row names, so the file looks like"
msgstr "@c R은 행 이름을 입력하지 않아도 되도록 header line을 사용하는 방식을 택하며, 그렇기 때문에 파일의 형태는 @c 다음과 같습니다."

#
#. type: example
#: R-data.texi:303
#, no-wrap
msgid ""
"                dist    climb   time\n"
"Greenmantle     2.5     650     16.083\n"
"   ...\n"
msgstr ""

#
#. type: enumerate
#: R-data.texi:309
msgid "Some other systems require a (possibly empty) entry for the row names, which is what @code{write.table} will provide if argument @code{col.names = NA} is specified.  Excel is one such system."
msgstr "몇몇 다른 시스템들은 (입력하지 않아도 되긴 하지만) 행 이름을 입력하도록 하며, 이것은 인자가 @code{col.names = NA}라고 지정되어 있을 때, @code{write.table}이 보여주는 결과와 같습니다. 엑셀이 그러한 시스템 중 하나입니다."

#
#. type: strong{#1}
#: R-data.texi:310
#: R-data.texi:513
#, no-wrap
msgid "Separator"
msgstr ""

#
#. type: cindex
#: R-data.texi:311
#: R-data.texi:679
#, no-wrap
msgid "CSV files"
msgstr ""

#
#. type: cindex
#: R-data.texi:312
#, no-wrap
msgid "comma separated values"
msgstr ""

#
#. type: findex
#: R-data.texi:313
#, no-wrap
msgid "write.csv"
msgstr ""

#
#. type: findex
#: R-data.texi:314
#, no-wrap
msgid "write.csv2"
msgstr ""

#. type: enumerate
#: R-data.texi:328
msgid "A common field separator to use in the file is a comma, as that is unlikely to appear in any of the fields in English-speaking countries.  Such files are known as CSV (comma separated values) files, and wrapper function @code{write.csv} provides appropriate defaults.  In some locales the comma is used as the decimal point (set this in @code{write.table} by @code{dec = \",\"}) and there CSV files use the semicolon as the field separator: use @code{write.csv2} for appropriate defaults.  There is an IETF standard for CSV files (which mandates commas and CRLF line endings, for which use @code{eol = \"\\r\\n\"}), RFC4180 (see @uref{https://tools.ietf.org/html/rfc4180}), but what is more important in practice is that the file is readable by the application it is targeted at."
msgstr ""

#
#. type: enumerate
#: R-data.texi:331
msgid "Using a semicolon or tab (@code{sep = \"\\t\"}) are probably the safest options."
msgstr "따라서, 세미콜론을 사용하거나 탭(@code{sep = \"\\t\"})을 사용하는 것이 가장 안전한 선택이 될 수 있습니다."

#
#. type: cindex
#: R-data.texi:332
#: R-data.texi:333
#: R-data.texi:556
#: R-data.texi:557
#, no-wrap
msgid "Missing values"
msgstr ""

#
#. type: enumerate
#: R-data.texi:338
msgid "By default missing values are output as @code{NA}, but this may be changed by argument @code{na}.  Note that @code{NaN}s are treated as @code{NA} by @code{write.table}, but not by @code{cat} nor @code{write}."
msgstr "디폴트로 결측값들을 NA로 출력(output)되게 지정한다고 해도, 이것은 인수 na에 의해 달라질 수 있습니다. NaN는 write.table에서는 NA와 똑같이 취급되지만, cat이나 write에서는 그렇지 않다는 점을 주의해야 합니다."

#
#. type: cindex
#: R-data.texi:339
#: R-data.texi:340
#: R-data.texi:526
#, no-wrap
msgid "Quoting strings"
msgstr ""

#
#. type: enumerate
#: R-data.texi:346
msgid "By default strings are quoted (including the row and column names).  Argument @code{quote} controls if character and factor variables are quoted: some programs, for example @pkg{Mondrian}, do not accept quoted strings (which are the default)."
msgstr "문자열(string, 그것이 행 이름이던 열 이름이던)은 기본값으로 인용(quote)됩니다. 문자(character)와 요인(factor) 변수들이 인용된다면 인자 @code{quote}가 제어합니다. 예를 들어 @pkg{Mondrian} 같은 어떤 프로그램들은 인용된 문자열을 받아들이지 않고 기본값을 적용합니다."

#
#. type: enumerate
#: R-data.texi:349
msgid "Some care is needed if the strings contain embedded quotes.  Three useful forms are"
msgstr "만약에 문자열(strings)이 임베디드 인용문(embedded quotes)을 포함하고 있다면 특별히 더 조심해야 합니다. 유용한 세 가지 형태는 다음과 같습니다."

#
#. type: example
#: R-data.texi:361
#, no-wrap
msgid ""
"> df <- data.frame(a = I(\"a \\\" quote\"))\n"
"> write.table(df)\n"
"\"a\"\n"
"\"1\" \"a \\\" quote\"\n"
"> write.table(df, qmethod = \"double\")\n"
"\"a\"\n"
"\"1\" \"a \"\" quote\"\n"
"> write.table(df, quote = FALSE, sep = \",\")\n"
"a\n"
"1,a \" quote\n"
msgstr ""

#
#. type: enumerate
#: R-data.texi:365
msgid "The second is the form of escape commonly used by spreadsheets."
msgstr "두번째 방법은 명령을 중단(escape)하기 위한 형태인데 주로 스프레드 시트 형태 에서 많이 사용됩니다."

#
#. type: enumerate
#: R-data.texi:375
msgid "Text files do not contain metadata on their encodings, so for non-@acronym{ASCII} data the file needs to be targetted to the application intended to read it.  All of these functions can write to a @emph{connection} which allows an encoding to be specified for the file, and @code{write.table} has a @code{fileEncoding} argument to make this easier."
msgstr ""

#
#. type: enumerate
#: R-data.texi:387
msgid "The hard part is to know what file encoding to use.  For use on Windows, it is best to use what Windows calls `Unicode'@footnote{Even then, Windows applications may expect a Byte Order Mark which the implementation of @code{iconv} used by @R{} may or may not add depending on the platform.}, that is @code{\"UTF-16LE\"}.  Using UTF-8 is a good way to make portable files that will not easily be confused with any other encoding, but even OS X applications (where UTF-8 is the system encoding) may not recognize them, and Windows applications are most unlikely to.  Apparently Excel:mac 2004/8 expects @code{.csv} files in @code{\"macroman\"} encoding (the encoding used in much earlier versions of Mac OS)."
msgstr ""

#
#. type: findex
#: R-data.texi:390
#, no-wrap
msgid "write.matrix"
msgstr ""

#
#. type: Plain text
#: R-data.texi:394
msgid "Function @code{write.matrix} in package @CRANpkg{MASS} provides a specialized interface for writing matrices, with the option of writing them in blocks and thereby reducing memory usage."
msgstr ""

#
#. type: findex
#: R-data.texi:395
#: R-data.texi:1955
#, no-wrap
msgid "sink"
msgstr ""

#
#. type: Plain text
#: R-data.texi:400
msgid "It is possible to use @code{sink} to divert the standard @R{} output to a file, and thereby capture the output of (possibly implicit)  @code{print} statements.  This is not usually the most efficient route, and the @code{options(width)} setting may need to be increased."
msgstr ""

#
#. type: findex
#: R-data.texi:401
#, no-wrap
msgid "write.foreign"
msgstr ""

#
#. type: Plain text
#: R-data.texi:406
msgid "Function @code{write.foreign} in package @CRANpkg{foreign} uses @code{write.table} to produce a text file and also writes a code file that will read this text file into another statistical package. There is currently support for export to @code{SAS}, @code{SPSS} and @code{Stata}."
msgstr ""

#
#. type: Plain text
#: R-data.texi:419
msgid "When reading data from text files, it is the responsibility of the user to know and to specify the conventions used to create that file, e.g. the comment character, whether a header line is present, the value separator, the representation for missing values (and so on) described in @ref{Export to text files}.  A markup language which can be used to describe not only content but also the structure of the content can make a file self-describing, so that one need not provide these details to the software reading the data."
msgstr "text 파일들에서 데이터를 읽어 들일 때, 그 파일을 생성하는 데 사용한 규정(convention)들을 알고 표기하는 것은 사용자의 책임입니다. 예를 들어, 주석문자(comment character)나 헤더의 존재 여부, 값 구분자(the value separator), 결측치의 재표현 등은 @ref{Export to text files}에 기술되어 있습니다.  데이터의 내용뿐 아니라 그 내용의 구조까지 기록하는 마크업 언어(markup language)는 하나의 파일이 그 안에서 완전히 설명 가능하도록(self-describing) 해주며, 그렇기 때문에 누군가가 데이터를 읽을 때 소프트웨어에 이러한 세부 사항들을 알려줄 필요가 없습니다."

#
#. type: Plain text
#: R-data.texi:427
msgid "The eXtensible Markup Language -- more commonly known simply as @acronym{XML} -- can be used to provide such structure, not only for standard datasets but also more complex data structures.  @acronym{XML} is becoming extremely popular and is emerging as a standard for general data markup and exchange.  It is being used by different communities to describe geographical data such as maps, graphical displays, mathematics and so on."
msgstr "확장형 마크업 언어(좀 더 일반적으로는 @acronym{XML}로 알려져 있는 eXtensible Markup Language)는 표준 형태의 데이터 세트뿐 아니라 좀 더 복잡한 형태의 데이터 구조까지도 표현이 가능합니다. @acronym{XML}은 점점 더 엄청난 인기를 얻고 있으며, 모든 형태의 데이터 마크업과 그 교환에 대한 하나의 기준이 되어가고 있습니다. XML은 서로 다른 커뮤니티들에서 지도, 그래픽, 수학식 등의 지리학적 데이터를 묘사하는데 사용되고 있습니다."

#
#. type: Plain text
#: R-data.texi:429
msgid "@acronym{XML} provides a way to specify the file's encoding, e.g.@:"
msgstr ""

#
#. type: example
#: R-data.texi:432
#, no-wrap
msgid "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n"
msgstr ""

#
#. type: Plain text
#: R-data.texi:436
msgid "although it does not require it."
msgstr ""

#
#. type: Plain text
#: R-data.texi:444
msgid "The @CRANpkg{XML} package provides general facilities for reading and writing @acronym{XML} documents within @R{}.  A description of the facilities of the @CRANpkg{XML} package is outside the scope of this document: see the package's Web page at @uref{http://www.omegahat.org/RSXML} for details and examples.  Package @CRANpkg{StatDataML} on @acronym{CRAN} is one example building on @CRANpkg{XML}."
msgstr "패키지  @CRANpkg{XML}은 R에서 @acronym{XML} 문서를 읽고 쓸 수 있도록 다양한 기능을 제공합니다. 팩키지  @CRANpkg{XML}의 기능에 대한 설명서는 이 문서의 범위를 벗어나므로 세부적 사항들과 예제에 대하여는 웹페이지(@uref{http://www.omegahat.org/RSXML})를 참고하기 바랍니다. @acronym{CRAN}에서 패키지 @CRANpkg{StatDataML}은  @CRANpkg{XML}에서 구축된 하나의 사례입니다.: Plain text"

#
#. type: Plain text
#: R-data.texi:448
msgid "NB: @CRANpkg{XML} is available as a binary package for Windows, normally from the `CRAN extras' repository (which is selected by default on Windows)."
msgstr "주의: @CRANpkg{XML}은 일반적으로 'CRAN extras' 저장소(리포지토리: repository)로부터 윈도우즈 운영체제에 바이너리 패키지 형태(윈도우즈에 기본값으로 선택되어 지게 되어있습니다)로 사용가능합니다. "

#
#. type: node
#: R-data.texi:460
#: R-data.texi:467
#: R-data.texi:720
#, no-wrap
msgid "Variations on read.table"
msgstr ""

#
#. type: node
#: R-data.texi:460
#: R-data.texi:467
#: R-data.texi:720
#: R-data.texi:721
#: R-data.texi:722
#: R-data.texi:743
#, no-wrap
msgid "Fixed-width-format files"
msgstr ""

#
#. type: node
#: R-data.texi:460
#: R-data.texi:720
#: R-data.texi:743
#: R-data.texi:744
#: R-data.texi:745
#: R-data.texi:760
#, no-wrap
msgid "Data Interchange Format (DIF)"
msgstr ""

#
#. type: node
#: R-data.texi:460
#: R-data.texi:743
#: R-data.texi:760
#: R-data.texi:848
#, no-wrap
msgid "Using scan directly"
msgstr ""

#
#. type: node
#: R-data.texi:460
#: R-data.texi:760
#: R-data.texi:848
#: R-data.texi:849
#: R-data.texi:850
#: R-data.texi:930
#, no-wrap
msgid "Re-shaping data"
msgstr ""

#
#. type: cindex
#: R-data.texi:460
#: R-data.texi:848
#: R-data.texi:930
#: R-data.texi:931
#: R-data.texi:932
#, no-wrap
msgid "Flat contingency tables"
msgstr ""

#
#. type: Plain text
#: R-data.texi:466
msgid "In @ref{Export to text files} we saw a number of variations on the format of a spreadsheet-like text file, in which the data are presented in a rectangular grid, possibly with row and column labels.  In this section we consider importing such files into @R{}."
msgstr "@ref{Export to text files}에서 우리는 행과 열 이름이 달려 있고 사각의 격자 형태로 표현된 다양한 스프레드 시트 형태의 text 파일 포맷을 확인할 수 있었습니다. 이번에는 이와 같은 형태의 파일들을 R로 읽어 들이는 방법을 다룹니다."

#
#. type: section
#: R-data.texi:468
#, no-wrap
msgid "Variations on @code{read.table}"
msgstr ""

#
#. type: findex
#: R-data.texi:469
#: R-data.texi:2007
#: R-data.texi:2259
#, no-wrap
msgid "read.table"
msgstr ""

#
#. type: Plain text
#: R-data.texi:475
msgid "The function @code{read.table} is the most convenient way to read in a rectangular grid of data.  Because of the many possibilities, there are several other functions that call @code{read.table} but change a group of default arguments."
msgstr "@code{read.table}은 사각형 격자 형태의 데이터를 읽기 위한 가장 편리한 방법입니다. 다양한 가능성 때문에, @code{read.table}을 호출하는 다른 다양한 함수들이 존재하지만, 이러한 함수들은 단지 몇 개의 디폴트 지정만 달리한 것입니다. "

#
#. type: Plain text
#: R-data.texi:478
msgid "Beware that @code{read.table} is an inefficient way to read in very large numerical matrices: see @code{scan} below."
msgstr "주의할 점은 read.table은 대용량 수치 행렬을 읽기에는 비효율적인 방법이라는 점입니다. 보다 자세한 내용은 다음에 나올 @code{scan}을 참고하십시오."

#
#. type: Plain text
#: R-data.texi:480
msgid "Some of the issues to consider are:"
msgstr "몇 개의 중요한 사항은 다음과 같습니다."

#
#. type: strong{#1}
#: R-data.texi:482
#: R-data.texi:633
#, no-wrap
msgid "Encoding"
msgstr ""

#
#. type: enumerate
#: R-data.texi:487
msgid "If the file contains non-@acronym{ASCII} character fields, ensure that it is read in the correct encoding.  This is mainly an issue for reading Latin-1 files in a UTF-8 locale, which can be done by something like"
msgstr "만약 파일에 ASCII 형태가 아닌 문자 변수들이 포함되어 있다면, 그것이 제대로 부호화 되어 읽어졌는지 반드시 확인해야 합니다. 이것은 주로 UTF-8 locale에서 Latin-1 파일을 읽는 것과 관련된 문제인데, 이것은 아래와 같은 방법으로 해결할 수 있습니다."

#
#. type: example
#: R-data.texi:490
#, no-wrap
msgid "read.table(\"file.dat\", fileEncoding=\"latin1\")\n"
msgstr ""

#
#. type: enumerate
#: R-data.texi:495
msgid "Note that this will work in any locale which can represent Latin-1 strings, but not many Greek/Russian/Chinese/Japanese @dots{} locales."
msgstr "중요한 것은 그리스/러시아/중국/일본 @dots{} locales를 제외하고 Latin-1으로 표현된 모든 locale에 대해 이 방법을 사용할 수 있다는 점입니다."

#
#. type: enumerate
#: R-data.texi:505
msgid "We recommend that you specify the @code{header} argument explicitly, Conventionally the header line has entries only for the columns and not for the row labels, so is one field shorter than the remaining lines.  (If @R{} sees this, it sets @code{header = TRUE}.)  If presented with a file that has a (possibly empty) header field for the row labels, read it in by something like"
msgstr "우리는 여러분들에게 헤더를 분명하게 표기하라고 권하고 싶습니다. 전통적으로 헤더에는 행 이름 대신 열 이름들만 들어가 있었는데, 그래서 하나의 변수가 다른 것들에 비해 길이가 짧습니다(만약 R이 이것을 판단할 수 있으면, header = TRUE로 세팅 할 것입니다). 만약에, 어떤 파일이 행 이름에 대한(입력이 되지 않았을 수 있는) 헤더 변수를 포함한다면, 아래와 같은 방법으로 이 파일을 읽을 수 있습니다."

#
#. type: example
#: R-data.texi:508
#, no-wrap
msgid "read.table(\"file.dat\", header = TRUE, row.names = 1)\n"
msgstr ""

#
#. type: enumerate
#: R-data.texi:512
msgid "Column names can be given explicitly via the @code{col.names}; explicit names override the header line (if present)."
msgstr "열 이름들은 @code{col.names}을 사용해서 따로 정의될 수 있으며, 따로 정의된 이름은 헤더(만약 존재한다면)에 대해 우선합니다."

#
#. type: enumerate
#: R-data.texi:520
msgid "Normally looking at the file will determine the field separator to be used, but with white-space separated files there may be a choice between the default @code{sep = \"\"} which uses any white space (spaces, tabs or newlines) as a separator, @code{sep = \" \"} and @code{sep = \"\\t\"}.  Note that the choice of separator affects the input of quoted strings."
msgstr "보통은 파일을 보면 파일에 사용된 변수 구분자가 무엇인지 알 수 있지만, 공백으로 파일이 구분된 경우, 우리는 구분자로 어떤 종류의 공백이든(단순 여백, 탭, 혹은 새로운 행) 다 사용할 수 있는 디폴트 @code{sep = }과 @code{sep = }, @code{sep = \"＼\t\"} 중에서 하나를 구분자로 선택할 수 있습니다. 구분자의 선택이 인용된 문자열의 입력에 영향을 줄 수도 있다는 점을 주의해야 합니다."

#
#. type: enumerate
#: R-data.texi:523
msgid "If you have a tab-delimited file containing empty fields be sure to use @code{sep = \"\\t\"}."
msgstr "만약 여러분이 여백을 포함하고 있는 탭을 구분자로 지정한(tab-delimited) 파일을 가지고 있다면, @code{sep = \"＼\t\"}을 사용해야만 합니다."

#
#. type: strong{#1}
#: R-data.texi:525
#, no-wrap
msgid "Quoting"
msgstr ""

#
#. type: enumerate
#: R-data.texi:534
msgid "By default character strings can be quoted by either @samp{\"} or @samp{'}, and in each case all the characters up to a matching quote are taken as part of the character string.  The set of valid quoting characters (which might be none) is controlled by the @code{quote} argument.  For @code{sep = \"\\n\"} the default is changed to @code{quote = \"\"}."
msgstr ""
"디폴트에 의해 문자형 문자열이 @samp{\"} 또는 @samp{'}에 의해 인용되면, 각각의 경우에 그 인용부호(quote)가 나타나기 전의 모든 문자들이 문자형 문자열의 한 덩어리로 간주됩니다. 유효한 인용부호 문자들의 조합(만약 인용부호 지정이 없다면)은 @code{quote} 인수(argument)로 통제할 수 있습니다. @code{sep =\"＼\n"
"\"}에 대해서, 디폴트는 @code{quote = \"\"}로 변경되어야 합니다."

#
#. type: enumerate
#: R-data.texi:537
msgid "If no separator character is specified, quotes can be escaped within quoted strings by immediately preceding them by @samp{\\}, C-style."
msgstr "아무런 구분자가 지정되지 않은 경우, C에서 그런 것처럼, 인용된 문자열 안에 든 인접한 바로 앞의 „＼‟에 의해 인용 작업이 중단될 수 있습니다. "

#
#. type: enumerate
#: R-data.texi:541
msgid "If a separator character is specified, quotes can be escaped within quoted strings by doubling them as is conventional in spreadsheets.  For example"
msgstr "특정 구분 문자가 지정된 경우에는 인용된 문자열 내에서 중복된 구분 문자에 의한 인용 작업의 중단이 발생할 수도 있습니다. 예를 들면, "

#
#. type: example
#: R-data.texi:544
#, no-wrap
msgid "'One string isn''t two',\"one more\"\n"
msgstr ""

#
#. type: enumerate
#: R-data.texi:548
msgid "can be read by"
msgstr ""

#
#. type: example
#: R-data.texi:551
#, no-wrap
msgid "read.table(\"testfile\", sep = \",\")\n"
msgstr "read.table(\"testfile\", sep = \",\")을 사용해야 합니다. "

#
#. type: enumerate
#: R-data.texi:555
msgid "This does not work with the default separator."
msgstr "이렇게 하면 디폴트 구분자에 대해 작동하지 않습니다"

#
#. type: enumerate
#: R-data.texi:563
msgid "By default the file is assumed to contain the character string @code{NA} to represent missing values, but this can be changed by the argument @code{na.strings}, which is a vector of one or more character representations of missing values."
msgstr "파일 안에 든 결측값들을 표기하기 위해 문자열 @code{NA}를 사용하도록 디폴트가 지정되어 있지만, 결측값을 표현하기 위한 한 개 이상의 문자 벡터를 지정하는 @code{na.strings}에 의해 이 표현은 달라질 수 있습니다. "

#
#. type: enumerate
#: R-data.texi:565
msgid "Empty fields in numeric columns are also regarded as missing values."
msgstr "또한 수치화된 열들 중에서 비워진 열들도 결측치로 간주됩니다. "

#
#. type: enumerate
#: R-data.texi:568
msgid "In numeric columns, the values @code{NaN}, @code{Inf} and @code{-Inf} are accepted."
msgstr "숫자로 된 열에서는 @code{NaN}과 @code{Inf}, @code{-Inf}이 채워진 것으로 인정됩니다."

#
#. type: strong{#1}
#: R-data.texi:569
#, no-wrap
msgid "Unfilled lines"
msgstr ""

#
#. type: enumerate
#: R-data.texi:574
msgid "It is quite common for a file exported from a spreadsheet to have all trailing empty fields (and their separators) omitted.  To read such files set @code{fill = TRUE}."
msgstr "스프레드 시트로부터 나온 파일이 줄줄 이어지는 빈 칸이 있는 열 들을 포함했거나 구분자가 빠져있는 경우는 매우 흔합니다. 이러한 파일을 읽기 위해서는 @code{fill = TRUE} 옵션을 사용합니다."

#
#. type: strong{#1}
#: R-data.texi:575
#, no-wrap
msgid "White space in character fields"
msgstr ""

#
#. type: enumerate
#: R-data.texi:580
msgid "If a separator is specified, leading and trailing white space in character fields is regarded as part of the field.  To strip the space, use argument @code{strip.white = TRUE}."
msgstr "구분자가 지정되어 있는 경우에는, 문자열들 앞에 연속된 여백이 그 열의 일부로 인식됩니다. 그 여백을 제거하기 위해서는, @code{strip.white = TRUE} 옵션을 사용합니다."

#
#. type: strong{#1}
#: R-data.texi:581
#, no-wrap
msgid "Blank lines"
msgstr ""

#
#. type: enumerate
#: R-data.texi:587
msgid "By default, @code{read.table} ignores empty lines.  This can be changed by setting @code{blank.lines.skip = FALSE}, which will only be useful in conjunction with @code{fill = TRUE}, perhaps to use blank rows to indicate missing cases in a regular layout."
msgstr "기본적으로 @code{read.table}는 빈 행들을 무시합니다. 이것은 @code{blank.lines.skip = FALSE} 세팅으로  바꿀 수 있는데, 이 옵션은 @code{fill = TRUE}와 함께 사용될 때만 작동합니다. 이것은 일반적으로 비어 있는 행들이 결측된 개체들을 나타내는데 사용되기 때문입니다."

#
#. type: strong{#1}
#: R-data.texi:588
#, no-wrap
msgid "Classes for the variables"
msgstr ""

#
#. type: enumerate
#: R-data.texi:597
msgid "Unless you take any special action, @code{read.table} reads all the columns as character vectors and then tries to select a suitable class for each variable in the data frame.  It tries in turn @code{logical}, @code{integer}, @code{numeric} and @code{complex}, moving on if any entry is not missing and cannot be converted.@footnote{This is normally fast as looking at the first entry rules out most of the possibilities.} If all of these fail, the variable is converted to a factor."
msgstr "특별한 조치를 따로 하지 않는다면, @code{read.table}은 모든 열을 문자 벡터로 읽은 후 데이터 프레임 내에 포함된 각각의 변수들에 적당한 클래스(class)를 선택하려 합니다. 어떤 입력 값이 결측치가 아니고 특별히 해당 class로 전환 될 수 없다면, 이 문장은 차례로 logical, integer, numeric 그리고 complex로 움직여가며 class 할당을 시도합니다.1 만약 이러한 시도가 모두 실패하면, 그 변수는 factor 변수로 변환됩니다."

#
#. type: enumerate
#: R-data.texi:603
msgid "Arguments @code{colClasses} and @code{as.is} provide greater control.  Specifying @code{as.is = TRUE} suppresses conversion of character vectors to factors (only).  Using @code{colClasses} allows the desired class to be set for each column in the input: it will be faster and use less memory."
msgstr "인자(argument) @code{colClasses}와 @code{as.is}는 더 많은 것을 통제할 수 있게 합니다. @code{as.is = TRUE}로 설정하는 것은 문자열들이 factor로 전환되는 일이 없도록 합니다(주로 이 용도로만 쓰입니다). @code{colClasses}를 사용하는 것은 원하는 클래스(class)가 입력할 때 각각의 열에 할당하도록 합니다. 그리고 이러한 방법은 보다 빠르고 메모리를 적게 차지합니다."

#
#. type: enumerate
#: R-data.texi:607
msgid "Note that @code{colClasses} and @code{as.is} are specified @emph{per} column, not @emph{per} variable, and so include the column of row names (if any)."
msgstr "중요한 것은 @code{colClasses}와 @code{as.is}이 @emph{각각의} 변수가 아니라, @emph{각각의} 열에 대해 기술한다는 것입니다. 그래서 이들은 행 이름들이 포함된 열도 (만약 그런 열이 있다면) 포함합니다."

#
#. type: strong{#1}
#: R-data.texi:608
#, no-wrap
msgid "Comments"
msgstr ""

#
#. type: enumerate
#: R-data.texi:614
msgid "By default, @code{read.table} uses @samp{#} as a comment character, and if this is encountered (except in quoted strings) the rest of the line is ignored. Lines containing only white space and a comment are treated as blank lines."
msgstr "@code{read.table}은 기본값으로 @samp{#}을 주석 문자로 사용하고 있습니다. 만약, 이 문자가 나타난다면 (인용되고 있는 부분에서 나타난 것이 아니라면) 그 줄의 나머지 부분은 무시됩니다. 즉, 오직 여백(white space)과 주석을 포함한 줄들 만이 공백(blank line)으로 처리됩니다."

#
#. type: enumerate
#: R-data.texi:617
msgid "If it is known that there will be no comments in the data file, it is safer (and may be faster) to use @code{comment.char = \"\"}."
msgstr "만약 데이터 파일 안에 주석이 없는 것이 확실하다면, @code{comment.char = }을 사용하는 편이 더 안전할 것입니다(어쩌면 처리도 더 빠를 것입니다.)"

#
#. type: strong{#1}
#: R-data.texi:618
#, no-wrap
msgid "Escapes"
msgstr ""

#
#. type: enumerate
#: R-data.texi:623
msgid "Many OSes have conventions for using backslash as an escape character in text files, but Windows does not (and uses backslash in path names).  It is optional in @R{} whether such conventions are applied to data files."
msgstr "많은 OS들은 관습적으로 text 파일에서 역슬래쉬(＼)를 마침(또는 종료: escape) 문자로 사용하고 있지만, Windows에서는 그렇지 않습니다(역슬래쉬(＼)를 경로 이름을 표시하는 데 사용하고 있습니다). @R{}에서 이 문제는 데이터 파일에 적용하는데 있어 관습을 따를 것인지 아닌지의 선택의 문제입니다."

#
#. type: enumerate
#: R-data.texi:632
msgid "Both @code{read.table} and @code{scan} have a logical argument @code{allowEscapes}.  This is false by default, and backslashes are then only interpreted as (under circumstances described above) escaping quotes.  If this set to be true, C-style escapes are interpreted, namely the control characters @code{\\a, \\b, \\f, \\n, \\r, \\t, \\v} and octal and hexadecimal representations like @code{\\040} and @code{\\0x2A}.  Any other escaped character is treated as itself, including backslash.  Note that Unicode escapes such as @code{\\u@var{xxxx}} are never interpreted."
msgstr "@code{read.table}과 @code{scan} 모두 @code{allowEscapes}라는 논리 인자(logical argument)를 사용합니다. false가 기본값으로 설정되어 있으며, 그래서 (앞서 설명한 환경에서는) 역슬래쉬(\\)들은 오직 마침(또는 종료: escaping)으로 해석됩니다. 만약 이것이 true로 설정되어 있다면, C-스타일 @code{\\a, \\b, \\f, \\n, \\r, \\t, \\v}와 @code{\\040} 및 @code{\\0x2A}와 같이 표현된 8진수나 16진수 통제 문자가 종료로 인식됩니다. 역슬래쉬를 포함한 어떤 다른 종료 문자도 그것과 같이 다루어 집니다. @code{\\u@var{xxxx}}와 같은 유니코드 종료문자(Unicode escapes)는 인식되지 않는 점에 유의하십시오."

#
#. type: enumerate
#: R-data.texi:636
msgid "This can be specified by the @code{fileEncoding} argument, for example"
msgstr "이것은 다음의 예와 같이 @code{fileEncoding} 인자로 설정할 수 있습니다."

#
#. type: example
#: R-data.texi:640
#, no-wrap
msgid ""
"fileEncoding = \"UCS-2LE\"    # Windows 'Unicode' files\n"
"fileEncoding = \"UTF-8\"\n"
msgstr ""

#
#. type: enumerate
#: R-data.texi:648
msgid "If you know (correctly) the file's encoding this will almost always work.  However, we know of one exception, UTF-8 files with a BOM.  Some people claim that UTF-8 files should never have a BOM, but some software (apparently including Excel:mac) uses them, and many Unix-alike OSes do not accept them.  So faced with a file which @command{file} reports as"
msgstr "여러분이 (올바로) 파일의 인코딩을 알고 있다면 이것은 거의 항상 작동합니다. 그러나 우리는 한 가지 예외를 알고 있는데 그것은 BOM 있는 UTF-8 파일입니다. 어떤 사람들은 UTF-8 파일이 BOM을 가지면 안된다고 주장하지만 (명백하게 엑셀:mac은 포함하는) 어떤 소프트웨어는 그것을 사용하고 많은 유닉스 계열의 OS들은 그것을 허용하지 않습니다. 그래서 다음과 같은 @command{file} 보고를 하는 파일을 보게 됩니다. "

#
#. type: example
#: R-data.texi:651
#, no-wrap
msgid "intro.dat: UTF-8 Unicode (with BOM) text\n"
msgstr ""

#
#. type: enumerate
#: R-data.texi:655
msgid "it can be read on Windows by"
msgstr "이것은 윈도우즈에서 다음과 같이 읽힐 수 있습니다."

#
#. type: example
#: R-data.texi:658
#, no-wrap
msgid "read.table(\"intro.dat\", fileEncoding = \"UTF-8\")\n"
msgstr ""

#
#. type: enumerate
#: R-data.texi:662
msgid "but on a Unix-alike might need"
msgstr "그러나 유닉스 계열의 UTF-8 locale은 다음이 필요할 것입니다."

#
#. type: example
#: R-data.texi:665
#, no-wrap
msgid "read.table(\"intro.dat\", fileEncoding = \"UTF-8-BOM\")\n"
msgstr ""

#
#. type: enumerate
#: R-data.texi:669
msgid "(This would most likely work without specifying an encoding in a UTF-8 locale.)"
msgstr ""

#
#. type: enumerate
#: R-data.texi:673
msgid "Another problem with this (real-life) example is that whereas @command{file-5.03} reported the BOM, @command{file-4.17} found on OS 10.5 (Leopard) did not."
msgstr "이러한 (실제의) 사례에 따른 또 다른 문제는 @command{file-5.03}은 BOM을 보고하는 반면에 MAC OS 10.5(레오파드) 에서 @command{file-4.17}는 그렇지 않다는 점입니다. "

#
#. type: findex
#: R-data.texi:675
#: R-data.texi:2256
#, no-wrap
msgid "read.csv"
msgstr ""

#
#. type: findex
#: R-data.texi:676
#, no-wrap
msgid "read.csv2"
msgstr ""

#
#. type: findex
#: R-data.texi:677
#: R-data.texi:2257
#, no-wrap
msgid "read.delim"
msgstr ""

#
#. type: findex
#: R-data.texi:678
#, no-wrap
msgid "read.delim2"
msgstr ""

#
#. type: findex
#: R-data.texi:680
#, no-wrap
msgid "Sys.localeconv"
msgstr ""

#
#. type: cindex
#: R-data.texi:681
#, no-wrap
msgid "locales"
msgstr ""

#
#. type: Plain text
#: R-data.texi:689
msgid "Convenience functions @code{read.csv} and @code{read.delim} provide arguments to @code{read.table} appropriate for CSV and tab-delimited files exported from spreadsheets in English-speaking locales.  The variations @code{read.csv2} and @code{read.delim2} are appropriate for use in those locales where the comma is used for the decimal point and (for @code{read.csv2}) for spreadsheets which use semicolons to separate fields."
msgstr "편리한 함수인 @code{read.csv}와 @code{read.table}은 영어권에서 스프레드시트로부터 추출된 CSV와 탭으로 구분된 파일들에 적절한 @code{read.table}의 인자(arguments)를 제공합니다. @code{read.csv2} 와 @code{read.delim2}와 같은 변형은 구분자로 콤마(,)를 사용하거나 (@code{read.csv2}의 경우) 세미콜론이 스프레트시트의 필드구분자로 사용되는 지역에 적절합니다."

#
#. type: Plain text
#: R-data.texi:692
msgid "If the options to @code{read.table} are specified incorrectly, the error message will usually be of the form"
msgstr "read.table에 옵션을 부적절하게 지정하면, 보통 다음과 같은 형태의 에러 메시지가 나타납니다."

#
#. type: example
#: R-data.texi:696
#, no-wrap
msgid ""
"Error in scan(file = file, what = what, sep = sep, : \n"
"        line 1 did not have 5 elements\n"
msgstr ""

#
#. type: Plain text
#: R-data.texi:700
msgid "or"
msgstr ""

#
#. type: example
#: R-data.texi:704
#, no-wrap
msgid ""
"Error in read.table(\"files.dat\", header = TRUE) : \n"
"        more columns than column names\n"
msgstr ""

#
#. type: findex
#: R-data.texi:706
#, no-wrap
msgid "count.fields"
msgstr ""

#
#. type: Plain text
#: R-data.texi:711
msgid "This may give enough information to find the problem, but the auxiliary function @code{count.fields} can be useful to investigate further."
msgstr "이 메세지가 무엇이 문제인지 충분한 정보를 제공하지 못한다면 보조적으로 @code{count.fields}가 문제를 보다 더 자세하게 찾아내는데 유용하게 사용될 수 있습니다."

#
#. type: Plain text
#: R-data.texi:718
msgid "Efficiency can be important when reading large data grids.  It will help to specify @code{comment.char = \"\"}, @code{colClasses} as one of the atomic vector types (logical, integer, numeric, complex, character or perhaps raw) for each column, and to give @code{nrows}, the number of rows to be read (and a mild over-estimate is better than not specifying this at all).  See the examples in later sections."
msgstr "효율성은 큰 데이터 그리드(grid)를 읽는데 중요합니다. 각 열에 대하여 (논리, 정수, 분수, 복소수, 문자 또는 미가공 된) atomic 벡터 유형들 중 하나인 @code{colClasses}인 @code{comment.char = }를 특정하고 읽어야 할 행의 수인 @code{nrows}를 (다소 과대 추정하는 것이 특정하지 않는 것보다 더 좋습니다) 부여하는 것이 도움이 될 것입니다. 아래의 예제들을 참조하십시오."

#
#. type: Plain text
#: R-data.texi:727
msgid "Sometimes data files have no field delimiters but have fields in pre-specified columns.  This was very common in the days of punched cards, and is still sometimes used to save file space."
msgstr "종종 데이터 파일은 필드 구분자가 없이 사전에 정해진 열에 필드를 가집니다. 이것은 천공카드가 사용되던 때에 매우 일반적이었고 파일 공간을 절약하는데 여전히 종종 쓰입니다."

#
#. type: findex
#: R-data.texi:728
#, no-wrap
msgid "read.fwf"
msgstr ""

#
#. type: Plain text
#: R-data.texi:736
msgid "Function @code{read.fwf} provides a simple way to read such files, specifying a vector of field widths.  The function reads the file into memory as whole lines, splits the resulting character strings, writes out a temporary tab-separated file and then calls @code{read.table}.  This is adequate for small files, but for anything more complicated we recommend using the facilities of a language like @code{perl} to pre-process the file."
msgstr "함수 @code{read.fwf}는 필드 넓이의 벡터를 특정지음으로써, 그러한 파일들을 읽는데 단순한 방법을 제공합니다. @code{read.fwf} 함수는 파일의 전체 줄을 메모리로 읽고, 결과 문자열을 분할하고, 탭으로 분리된 임시 파일을 작성하여 @code{read.table}을 호출(call)합니다. 이것은 작은 파일에 적당하지만 어떤 더 복잡한 것에 대해서는 파일 전처리를 위해 @code{perl}과 같은 언어의 도구를 사용하는 것을 권장합니다."

#
#. type: findex
#: R-data.texi:739
#, no-wrap
msgid "read.fortran"
msgstr ""

#
#. type: Plain text
#: R-data.texi:742
msgid "Function @code{read.fortran} is a similar function for fixed-format files, using Fortran-style column specifications."
msgstr "함수 @code{read.fortran}은 포트란(Fortran) 유형의 열을 지정함으로써 고정된 포맷 파일에 대해 유사한 함수입니다."

#
#. type: Plain text
#: R-data.texi:749
msgid "An old format sometimes used for spreadsheet-like data is DIF, or Data Interchange format."
msgstr "스프레드시트와 같은 데이터에 때때로 사용되는 오래된 방식은 DIF(Data Interchange Format)입니다."

#
#. type: findex
#: R-data.texi:750
#: R-data.texi:2258
#, no-wrap
msgid "read.DIF"
msgstr ""

#
#. type: Plain text
#: R-data.texi:753
msgid "Function @code{read.DIF} provides a simple way to read such files.  It takes arguments similar to @code{read.table} for assigning types to each of the columns."
msgstr ""

#
#. type: Plain text
#: R-data.texi:759
msgid "On Windows, spreadsheet programs often store spreadsheet data copied to the clipboard in this format; @code{read.DIF(\"clipboard\")} can read it from there directly.  It is slightly more robust than @code{read.table(\"clipboard\")} in handling spreadsheets with empty cells."
msgstr ""

#
#. type: section
#: R-data.texi:761
#, no-wrap
msgid "Using @code{scan} directly"
msgstr ""

#
#. type: Plain text
#: R-data.texi:767
msgid "Both @code{read.table} and @code{read.fwf} use @code{scan} to read the file, and then process the results of @code{scan}.  They are very convenient, but sometimes it is better to use @code{scan} directly."
msgstr "@code{read.table} 와 @code{read.fwf} 둘은 파일을 읽는데 @code{scan} 을 이용하고 @code{scan} 의 결과를 처리합니다. 그것들은 매우 편리하지만 종종 @code{scan} 을 직접 사용하는 것이 더 낳을 때도 있습니다."

#
#. type: Plain text
#: R-data.texi:775
msgid "Function @code{scan} has many arguments, most of which we have already covered under @code{read.table}.  The most crucial argument is @code{what}, which specifies a list of modes of variables to be read from the file.  If the list is named, the names are used for the components of the returned list.  Modes can be numeric, character or complex, and are usually specified by an example, e.g. @code{0}, @code{\"\"} or @code{0i}.  For example"
msgstr "함수 scan 은 많은 인수(argument)를 가지고 있고 그것들 중 대부분은 이미 read.table 에 속해있습니다. 가장 중요한 인수(argument)는 what 으로 이것은 어느 것이 파일로부터 읽혀질 변수의 모드(mode) 목록인지 특정하는 것입니다. 만약 이 목록에 이름이 붙여져 있으면, 그 이름은 반환되는 목록의 성분을 위해 사용됩니다. 모드(mode)는 수, 문자 또는 복소수가 될 수 있고, 보통 @code{0}, @code{} or @code{0i} 와 같은 사례에 의해 특정됩니다. 예를 들면 아래와 같습니다."

#
#. type: example
#: R-data.texi:779
#, no-wrap
msgid ""
"cat(\"2 3 5 7\", \"11 13 17 19\", file=\"ex.dat\", sep=\"\\n\")\n"
"scan(file=\"ex.dat\", what=list(x=0, y=\"\", z=0), flush=TRUE)\n"
msgstr ""

#
#. type: Plain text
#: R-data.texi:784
msgid "returns a list with three components and discards the fourth column in the file."
msgstr "이것은 세 가지 구성요소와 목록을 출력하고 파일의 네 번째 열을 버립니다"

#
#. type: findex
#: R-data.texi:785
#: R-data.texi:2008
#, no-wrap
msgid "readLines"
msgstr ""

#
#. type: Plain text
#: R-data.texi:788
msgid "There is a function @code{readLines} which will be more convenient if all you want is to read whole lines into @R{} for further processing."
msgstr "@code{readLines} 라는 함수는 원하는 모든 것이 앞으로의 작업진행을 위해 모든 라인(line)을 읽는 것이라면 보다 편리할 것입니다."

#
#. type: Plain text
#: R-data.texi:793
msgid "One common use of @code{scan} is to read in a large matrix.  Suppose file @file{matrix.dat} just contains the numbers for a 200 x 2000 matrix. Then we can use"
msgstr "@code{scan} 의 일반적인 용법 중 하나는 큰 행렬의 데이터를 읽는 것입니다.행과 열이 각각 200 과 2000 인 행렬 데이터 @file{matrix.dat} 이 있다고 가정하고 이것을 읽어 들이는데 다음과 같이 하면"

#
#. type: example
#: R-data.texi:796
#, no-wrap
msgid "A <- matrix(scan(\"matrix.dat\", n = 200*2000), 200, 2000, byrow = TRUE)\n"
msgstr ""

#
#. type: Plain text
#: R-data.texi:801
msgid "On one test this took 1 second (under Linux, 3 seconds under Windows on the same machine) whereas"
msgstr "유닉스 체제에서는 1 초 이하(같은 컴퓨터에서 윈도우 체제를 사용하면 3 초 이하)의 시간 밖에 걸리지 않습니다."

#
#. type: example
#: R-data.texi:804
#, no-wrap
msgid "A <- as.matrix(read.table(\"matrix.dat\"))\n"
msgstr ""

#
#. type: Plain text
#: R-data.texi:808
msgid "took 10 seconds (and more memory), and"
msgstr ""

#
#. type: example
#: R-data.texi:812
#, no-wrap
msgid ""
"A <- as.matrix(read.table(\"matrix.dat\", header = FALSE, nrows = 200,\n"
"                          comment.char = \"\", colClasses = \"numeric\"))\n"
msgstr ""

#
#. type: Plain text
#: R-data.texi:820
msgid "took 7 seconds.  The difference is almost entirely due to the overhead of reading 2000 separate short columns: were they of length 2000, @code{scan} took 9 seconds whereas @code{read.table} took 18 if used efficiently (in particular, specifying @code{colClasses}) and 125 if used naively."
msgstr "반면, 아래와 같이 하면 더 많은 메모리와 시간(10 초)이 걸리고 마지막 세 번째 방법으로 하면 7 초가 걸립니다.이 같은 차이는 거의 모두 2000 개의 분리된 짧은 열 전체 때문입니다. 그것들의 길이가 200 이면, @code{scan} 은 9 초가 걸리는 반면 @code{read.table} 은 특별히 @code{colClasses} 를 사용하여 효율적으로 사용한 경우 18 초, 특별한 처리 없이 그냥 사용할 경우 125 초가 소요됩니다."

#
#. type: Plain text
#: R-data.texi:824
msgid "Note that timings can depend on the type read and the data.  Consider reading a million distinct integers:"
msgstr "결국 소요되는 시간은 읽기 유형과 데이터에 따라서 달라질 수 있음에 주의하십시오. 백만개의 별개의 정수를 읽는 것을 가정하여 보면 다음과 같습니다."

#
#. type: example
#: R-data.texi:831
#, no-wrap
msgid ""
"writeLines(as.character((1+1e6):2e6), \"ints.dat\")\n"
"xi <- scan(\"ints.dat\", what=integer(0), n=1e6)   # 0.77s\n"
"xn <- scan(\"ints.dat\", what=numeric(0), n=1e6)   # 0.93s\n"
"xc <- scan(\"ints.dat\", what=character(0), n=1e6) # 0.85s\n"
"xf <- as.factor(xc)                              # 2.2s\n"
"DF <- read.table(\"ints.dat\")                     # 4.5s\n"
msgstr ""

#
#. type: Plain text
#: R-data.texi:834
msgid "and a million examples of a small set of codes:"
msgstr "그리고 백만개의 작은 코드 집합의 예는 다음과 같습니다."

#
#. type: example
#: R-data.texi:841
#, no-wrap
msgid ""
"code <- c(\"LMH\", \"SJC\", \"CHCH\", \"SPC\", \"SOM\")\n"
"writeLines(sample(code, 1e6, replace=TRUE), \"code.dat\")\n"
"y <- scan(\"code.dat\", what=character(0), n=1e6)  # 0.44s\n"
"yf <- as.factor(y)                               # 0.21s\n"
"DF <- read.table(\"code.dat\")                     # 4.9s\n"
"DF <- read.table(\"code.dat\", nrows=1e6)          # 3.6s\n"
msgstr ""

#
#. type: Plain text
#: R-data.texi:846
msgid "Note that these timings depend heavily on the operating system (the basic reads in Windows take at least as twice as long as these Linux times) and on the precise state of the garbage collector."
msgstr "이러한 소요시간은 운영체제(기본적인 읽기 기능도 윈도우 운영체제에서는 유닉스 운영체제보다 최소한 두 배의 시간이 소요됩니다)와 garbage collector(불필요한 정보를 정리하여 정리된 공간을 만드는 것)의 정확한 상태에 따라 영향을 매우 많이 받습니다."

#
#. type: Plain text
#: R-data.texi:857
msgid "Sometimes spreadsheet data is in a compact format that gives the covariates for each subject followed by all the observations on that subject.  @R{}'s modelling functions need observations in a single column.  Consider the following sample of data from repeated MRI brain measurements"
msgstr "때때로 스프레드시트 형태의 데이터는 목적에 따른 모든 관측치들에 의해 그 각각의 목적에 따른 공변량을 부여하는 단순한 포맷으로 되어 있습니다. @R{} 의 모델링 함수들은 하나의 열에 있는 관측치를 필요로 합니다. 다음과 같은 반복적으로 측정한 뇌 MRI 측정값으로부터 얻은 표본 데이터를 고려해 보십시오."

#
#. type: example
#: R-data.texi:867
#, no-wrap
msgid ""
" Status   Age    V1     V2     V3    V4\n"
"      P 23646 45190  50333  55166 56271\n"
"     CC 26174 35535  38227  37911 41184\n"
"     CC 27723 25691  25712  26144 26398\n"
"     CC 27193 30949  29693  29754 30772\n"
"     CC 24370 50542  51966  54341 54273\n"
"     CC 28359 58591  58803  59435 61292\n"
"     CC 25136 45801  45389  47197 47126\n"
msgstr ""

#
#. type: Plain text
#: R-data.texi:872
msgid "There are two covariates and up to four measurements on each subject.  The data were exported from Excel as a file @file{mr.csv}."
msgstr "여기엔 두 개의 공변량이 있고 각각의 목적에 네 개의 관측치가 추가되어 있습니다. 이 데이터는 @file{mr.csv} 과 같은 엑셀파일로부터 읽어 들인 것입니다. "

#
#. type: findex
#: R-data.texi:873
#, no-wrap
msgid "stack"
msgstr ""

#
#. type: Plain text
#: R-data.texi:876
msgid "We can use @code{stack} to help manipulate these data to give a single response."
msgstr "다음과 같이 @code{stack} 을 이용하면 데이터를 단순한 형태의 출력결과를 보일 수 있도록 하는데 도움이 됩니다."

#
#. type: example
#: R-data.texi:880
#, no-wrap
msgid ""
"zz <- read.csv(\"mr.csv\", strip.white = TRUE)\n"
"zzz <- cbind(zz[gl(nrow(zz), 1, 4*nrow(zz)), 1:2], stack(zz[, 3:6]))\n"
msgstr ""

#
#. type: Plain text
#: R-data.texi:884
msgid "with result"
msgstr "이의 출력형태는 아래와 같습니다."

#
#. type: example
#: R-data.texi:896
#, no-wrap
msgid ""
"      Status   Age values ind\n"
"X1         P 23646  45190  V1\n"
"X2        CC 26174  35535  V1\n"
"X3        CC 27723  25691  V1\n"
"X4        CC 27193  30949  V1\n"
"X5        CC 24370  50542  V1\n"
"X6        CC 28359  58591  V1\n"
"X7        CC 25136  45801  V1\n"
"X11        P 23646  50333  V2\n"
"...\n"
msgstr ""

#
#. type: findex
#: R-data.texi:898
#, no-wrap
msgid "unstack."
msgstr ""

#
#. type: Plain text
#: R-data.texi:901
msgid "Function @code{unstack} goes in the opposite direction, and may be useful for exporting data."
msgstr "함수 @code{unstack} 는 반대 방향으로 작동하는데 데이터 내보내기에 유용합니다. 이러한 작업을 하는"

#
#. type: findex
#: R-data.texi:902
#, no-wrap
msgid "reshape"
msgstr ""

#
#. type: Plain text
#: R-data.texi:905
msgid "Another way to do this is to use the function @code{reshape}, by"
msgstr "다른 방법은 아래와 같이 함수 @code{reshape} 를 사용하는 것입니다."

#
#. type: example
#: R-data.texi:920
#, no-wrap
msgid ""
"> reshape(zz, idvar=\"id\",timevar=\"var\",\n"
"  varying=list(c(\"V1\",\"V2\",\"V3\",\"V4\")),direction=\"long\")\n"
"    Status   Age var    V1 id\n"
"1.1      P 23646   1 45190  1\n"
"2.1     CC 26174   1 35535  2\n"
"3.1     CC 27723   1 25691  3\n"
"4.1     CC 27193   1 30949  4\n"
"5.1     CC 24370   1 50542  5\n"
"6.1     CC 28359   1 58591  6\n"
"7.1     CC 25136   1 45801  7\n"
"1.2      P 23646   2 50333  1\n"
"2.2     CC 26174   2 38227  2\n"
"...\n"
msgstr ""

#
#. type: Plain text
#: R-data.texi:926
msgid "The @code{reshape} function has a more complicated syntax than @code{stack} but can be used for data where the `long' form has more than the one column in this example. With @code{direction=\"wide\"}, @code{reshape} can also perform the opposite transformation."
msgstr "@code{reshape} 는 @code{stack} 보다 더 복잡한 구문을 사용해야 하지만 사례에서의 한 열보다 더 긴 형태를 가지는 데이터를 다루는 데 사용될 수 있습니다. @code{direction=”wide”}과 함께 @code{reshape} 또한 반대 방향으로 데이터를 전환하는 기능을 수행할 수 있습니다."

#
#. type: Plain text
#: R-data.texi:929
msgid "Some people prefer the tools in packages @CRANpkg{reshape}, @CRANpkg{reshape2} and @CRANpkg{plyr}."
msgstr "몇몇 사람들은 @CRANpkg{reshape}, @CRANpkg{reshape2}, 그리고 @CRANpkg{plyr} 패키지 안의 툴을 선호합니다."

#
#. type: Plain text
#: R-data.texi:943
msgid "Displaying higher-dimensional contingency tables in array form typically is rather inconvenient.  In categorical data analysis, such information is often represented in the form of bordered two-dimensional arrays with leading rows and columns specifying the combination of factor levels corresponding to the cell counts.  These rows and columns are typically ``ragged'' in the sense that labels are only displayed when they change, with the obvious convention that rows are read from top to bottom and columns are read from left to right.  In @R{}, such ``flat'' contingency tables can be created using @code{ftable},"
msgstr "다차원의 수렴된 표를 표현하기 위해서 배열의 형태는 오히려 불편합니다. 범주형 데이터 분석의 경우 그러한 정보는 종종 셀의 수에 따라 factor 의 수준 조합을 특정하여 첫번째 열과 행과 함께 확장된 이차원 배열로 표현합니다. 행은 위에서부터 아래로 읽고 열은 왼쪽에서 오른쪽으로 읽는 명백한 관습처럼 이러한 행과 열들은 라벨이 단지 그것이 변할 때만 표시된다는 의미에서 구식입니다(ragged). "

#
#. type: findex
#: R-data.texi:943
#, no-wrap
msgid "ftable"
msgstr ""

#
#. type: Plain text
#: R-data.texi:946
msgid "which creates objects of class @code{\"ftable\"} with an appropriate print method."
msgstr "@R{} 에서 그러한 평벙한 형태의 수렴된 표는 @code{ftable} 를 이용하여 생성할 수 있으며 그것은 적절한 출력 방법과 함께 “ftable” 클래스 대상을 생성합니다."

#
#. type: Plain text
#: R-data.texi:951
msgid "As a simple example, consider the @R{} standard data set @code{UCBAdmissions} which is a 3-dimensional contingency table resulting from classifying applicants to graduate school at UC Berkeley for the six largest departments in 1973 classified by admission and sex."
msgstr "@code{UCBAdmissions} 이라는 @R{} 의 표준적인 데이터 셋을 예로 하나 들어보면, 입학허가와 성별로 구분된 1973 년 가장 큰 여섯 부문에 대한 UC Berkeley 대학원에 지원한 지원자들을 분류한 결과를 담고 있는 3 차원의 수렴된 표를 고려해 볼 수 있습니다."

#
#. type: example
#: R-data.texi:961
#, no-wrap
msgid ""
"> data(UCBAdmissions)\n"
"> ftable(UCBAdmissions)\n"
"                Dept   A   B   C   D   E   F\n"
"Admit    Gender                             \n"
"Admitted Male        512 353 120 138  53  22\n"
"         Female       89  17 202 131  94  24\n"
"Rejected Male        313 207 205 279 138 351\n"
"         Female       19   8 391 244 299 317\n"
msgstr ""

#
#. type: Plain text
#: R-data.texi:966
msgid "The printed representation is clearly more useful than displaying the data as a 3-dimensional array."
msgstr "출력된 모양은 명백히 3 차원 배열로 나타내어진 데이터보다 더 유용합니다."

#
#. type: Plain text
#: R-data.texi:969
msgid "There is also a function @code{read.ftable} for reading in flat-like contingency tables from files."
msgstr "파일에 있는 평범한 표(flat-like contingency tables)를 읽기위한 @code{read.ftable} 이라는 함수도 있습니다."

#
#. type: findex
#: R-data.texi:969
#, no-wrap
msgid "read.ftable"
msgstr ""

#
#. type: Plain text
#: R-data.texi:975
msgid "This has additional arguments for dealing with variants on how exactly the information on row and column variables names and levels is represented.  The help page for @code{read.ftable} has some useful examples.  The flat tables can be converted to standard contingency tables in array form using @code{as.table}."
msgstr "이 함수는 행과 열이 담고있는 변수명과 값을 표현하는데 있어 표가 담고있는 다양한 정보를 정확하게 다루는데 사용되는 추가적인 인수(argument)도 추가적으로 가지고 있습니다. read.ftable 을 위한 도움말은 다수의 유용한 예들을 가지고 있습니다. @code{flat.table} 은 @code{as.table} 을 사용하여 배열형태(array form)에서 standard contingency table 로 전환할 수 있습니다."

#
#. type: Plain text
#: R-data.texi:981
msgid "Note that flat tables are characterized by their ``ragged'' display of row (and maybe also column) labels.  If the full grid of levels of the row variables is given, one should instead use @code{read.table} to read in the data, and create the contingency table from this using @code{xtabs}."
msgstr "@code{flat.table} 은 그것의 행(또는 열)의 \"ragged\" display 로 특징지어집니다. 만약 행 변수값의 모든 격자(full grid)가 주어진다면 어떤 사람은 데이터를 읽기 위해 @code{read.table} 을 대신 사용하고 @code{xtabs} 를 사용하여 이것으로부터 contingency table 을 생성하여야 합니다."

#
#. type: Plain text
#: R-data.texi:990
msgid "In this chapter we consider the problem of reading a binary data file written by another statistical system.  This is often best avoided, but may be unavoidable if the originating system is not available."
msgstr "이 장에서는 다른 통계시스템에 의해 작성된 바이너리 데이터 파일을 읽는데 따르는 문제에 대하여 설명합니다.이것은 대부분의 경우 문제를 피하는 가장 좋은 방법이지만 기본 시스템이 지원하지 않을 경우 해결되지 않을 수도 있습니다."

#
#. type: Plain text
#: R-data.texi:995
msgid "In all cases the facilities described were written for data files from specific versions of the other system (often in the early 2000s), and have not necessarily been updated for the most recent versions of the other system."
msgstr ""

#
#. type: node
#: R-data.texi:999
#: R-data.texi:1001
#: R-data.texi:1092
#, no-wrap
msgid "EpiInfo Minitab SAS S-PLUS SPSS Stata Systat"
msgstr ""

#
#. type: cindex
#: R-data.texi:999
#: R-data.texi:1001
#: R-data.texi:1092
#: R-data.texi:1093
#: R-data.texi:1094
#, no-wrap
msgid "Octave"
msgstr ""

#
#. type: section
#: R-data.texi:1002
#, no-wrap
msgid "EpiInfo, Minitab, S-PLUS, SAS, SPSS, Stata, Systat"
msgstr ""

#
#. type: Plain text
#: R-data.texi:1010
msgid "The recommended package @CRANpkg{foreign} provides import facilities for files produced by these statistical systems, and for export to Stata. In some cases these functions may require substantially less memory than @code{read.table} would. @code{write.foreign} (See @ref{Export to text files}) provides an export mechanism with support currently for @code{SAS}, @code{SPSS} and @code{Stata}."
msgstr "추천할만한 다른 외부의 패키지@CRANpkg{foreign}는 이런 통계시스템에 의해 마들어진 파일을 불러오거나 내보내는 기능을 제공합니다. 몇몇의 경우 이러한 함수는 @code{read.table} 이 필요로 하는 것에 비해 실질적으로 적은 메모리를 필요로 할 것입니다. @code{write.foreign} 은 현재 @code{SPSS} 와 @code{STATA} 로 내보내기 기능을 제공합니다."

#
#. type: cindex
#: R-data.texi:1011
#, no-wrap
msgid "EpiInfo"
msgstr ""

#
#. type: cindex
#: R-data.texi:1012
#, no-wrap
msgid "EpiData"
msgstr ""

#
#. type: findex
#: R-data.texi:1013
#, no-wrap
msgid "read.epiinfo"
msgstr ""

#
#. type: Plain text
#: R-data.texi:1017
msgid "EpiInfo versions 5 and 6 stored data in a self-describing fixed-width text format. @code{read.epiinfo} will read these @file{.REC} files into an @R{} data frame. EpiData also produces data in this format."
msgstr "EpiInfo version 5 와 6 은 자체적으로 고정된 길이의 텍스트 포맷으로 데이터를 저장했습니다. @code{read.epiinfo} 는 @file{.REC} 류의 파일을 @R{} 데이터 프레임으로 읽어들일 것입니다. EpiData 또한 이러한 포맷의 데이터를 생성합니다."

#
#. type: cindex
#: R-data.texi:1018
#, no-wrap
msgid "Minitab"
msgstr ""

#
#. type: findex
#: R-data.texi:1019
#, no-wrap
msgid "read.mtp"
msgstr ""

#
#. type: Plain text
#: R-data.texi:1022
msgid "Function @code{read.mtp} imports a `Minitab Portable Worksheet'.  This returns the components of the worksheet as an @R{} list."
msgstr "함수 @code{read.mtp} 는 Minitab Portable Worksheet 를 불러오기 합니다. 이것은 @R{} list 처럼 워크시트의 구상요소를 반환합니다."

#
#. type: cindex
#: R-data.texi:1023
#, no-wrap
msgid "SAS"
msgstr ""

#
#. type: findex
#: R-data.texi:1024
#, no-wrap
msgid "read.xport"
msgstr ""

#
#. type: Plain text
#: R-data.texi:1034
msgid "Function @code{read.xport} reads a file in SAS Transport (XPORT) format and return a list of data frames.  If SAS is available on your system, function @code{read.ssd} can be used to create and run a SAS script that saves a SAS permanent dataset (@file{.ssd} or @file{.sas7bdat}) in Transport format.  It then calls @code{read.xport} to read the resulting file.  (Package @CRANpkg{Hmisc} has a similar function @code{sas.get}, also running SAS.)  For those without access to SAS but running on Windows, the SAS System Viewer (a zero-cost download) can be used to open SAS datasets and export them to e.g.@: @file{.csv} format."
msgstr "함수 @code{read.xport} 는 SAS Transport (XPORT) 포맷의 파일을 읽고 데이터 프레임 목록(a list of data frame)을 반환합니다. 만약 SAS 가 당신의 컴퓨터에서 사용가능하다면, 함수 @code{read.ssd} 가 변환포맷에서(in Transport format) SAS 영구 데이터셋('@file{.ssd}' 또는 '@file{.sas7bdat}')으로 저장되어 있는 SAS 스크립트를 생성하고 실행하는데 사용될 수 있습니다.그러고 난 후 결과 파일을 읽기위해 @code{read.xport} 를 호출할 수 있습니다. (패키지 @CRANpkg{Hmisc} 는 유사한 함수인 @code{sas.get} 을 가지고 있으며 SAS 를 실행합니다.) SAS 접속없이 윈도우즈에서 실행하는 경우 무료로 구할 수 있는 SAS System Viewer 는 SAS 데이터셋을 열고 그것을 '@file{.csv}'와 같은 포맷으로 내보내기하는데 사용할 수 있습니다."

#
#. type: cindex
#: R-data.texi:1035
#, no-wrap
msgid "S-PLUS"
msgstr ""

#
#. type: findex
#: R-data.texi:1036
#, no-wrap
msgid "read.S"
msgstr ""

#
#. type: findex
#: R-data.texi:1037
#, no-wrap
msgid "data.restore"
msgstr ""

#
#. type: Plain text
#: R-data.texi:1044
msgid "Function @code{read.S} which can read binary objects produced by S-PLUS 3.x, 4.x or 2000 on (32-bit) Unix or Windows (and can read them on a different OS).  This is able to read many but not all @Sl{} objects: in particular it can read vectors, matrices and data frames and lists containing those."
msgstr "함수 @code{read.S}v 는 S-PLUS 3.x, 4.x 또는 Unix 나 Windows 2000 (32-bit)에 의해 생성된 바이너리 object 들을 읽을 수 있고 그것들을 다른 OS 에서도 읽을 수 있습니다. 이것은 많이 읽을 수 있는데다 모두 @Sl{} object 일 필요도 없습니다. 특히 그것은 벡터, 행렬 그리고 테이터 프레임과 그것들을 담고있는 list 들도 읽을 수 있습니다."

#
#. type: Plain text
#: R-data.texi:1049
msgid "Function @code{data.restore} reads S-PLUS data dumps (created by @code{data.dump}) with the same restrictions (except that dumps from the Alpha platform can also be read).  It should be possible to read data dumps from S-PLUS 5.x and later written with @code{data.dump(oldStyle=T)}."
msgstr "함수 @code{data.restore} 는 (Alpha 플랫폼에서 dump 된 것을 제외하면 또한 읽을 수 있습니다) (data.dump 에 의해 생성된) S-PLUS 데이터 덤프 (dara dump) 같은 제약하에 읽어 들입니다. 그것은 S-PLUS 5.x 과 그 이후의 버전에서 @code{data.dump(oldStyle=T)}로 생성된 데이터 덤프를 읽도록 될 것입니다."

#
#. type: Plain text
#: R-data.texi:1055
msgid "If you have access to S-PLUS, it is usually more reliable to @code{dump} the object(s) in S-PLUS and @code{source} the dump file in @R{}.  For S-PLUS 5.x and later you may need to use @code{dump(..., oldStyle=T)}, and to read in very large objects it may be preferable to use the dump file as a batch script rather than use the @code{source} function."
msgstr "만약 당신이 S-PLUS 에 접근할 수 있다면, S-PLUS 에서 object(들)과 @R{} 에서 생성된 덤프파일 소스(@code{source})를 덤프(@code{dump})하는 것이 보통의 경우 보다 더 신뢰할만 합니다. S-PLUS 5.x 와 6.x 의 경우 당신은 아마도 @code{dump(..., oldStyle=T)}를 사용할 필요가 생길 것이고 매우 큰 object 를 읽으면 소스함수(@code{source} function)의 사용보다 배치 스크립트(batch script)로서 덤프파일을 사용하는 것을 선호한할 수 있습니다."

#
#. type: cindex
#: R-data.texi:1056
#, no-wrap
msgid "SPSS"
msgstr ""

#
#. type: cindex
#: R-data.texi:1057
#, no-wrap
msgid "SPSS Data Entry"
msgstr ""

#
#. type: findex
#: R-data.texi:1058
#, no-wrap
msgid "read.spss"
msgstr ""

#
#. type: Plain text
#: R-data.texi:1063
msgid "Function @code{read.spss} can read files created by the `save' and `export' commands in @acronym{SPSS}.  It returns a list with one component for each variable in the saved data set. @acronym{SPSS} variables with value labels are optionally converted to @R{} factors."
msgstr "함수 @code{read.spss} 는 @acronym{SPSS} 에서 '저장하기(save)'와 '내보내기(export)' 명령문에 의해 생성된 파일을 읽을 수 있습니다. 그리고 저장된 데이터셋의 각 변수에 따른 하나의 구성요소와 함께 그 목록(list)를 반환합니다. @acronym{SPSS} 의 변수명(value label)변수들은 선택적으로 @R{} 요소(R factor)로 변환됩니다."

#
#. type: Plain text
#: R-data.texi:1068
msgid "@acronym{SPSS} Data Entry is an application for creating data entry forms.  By default it creates data files with extra formatting information that @code{read.spss} cannot handle, but it is possible to export the data in an ordinary @acronym{SPSS} format."
msgstr "@acronym{SPSS} Data Entry 는 데이터 엔트리 형태(entry forms)를 생성하는 어플리케이션의 하나입니다. 디폴트로 @code{read.spss} 는 다룰 수 없지만 원래의 @acronym{SPSS} 포맷의 데이터를 추가적 포맷 정보를 담아 생성할 수 있습니다."

#
#. type: Plain text
#: R-data.texi:1072
msgid "Some third-party applications claim to produce data `in SPSS format' but with differences in the formats: @code{read.spss} may or may not be able to handle these."
msgstr ""

#
#. type: cindex
#: R-data.texi:1073
#, no-wrap
msgid "Stata"
msgstr ""

#
#. type: findex
#: R-data.texi:1074
#, no-wrap
msgid "read.dta"
msgstr ""

#
#. type: findex
#: R-data.texi:1075
#, no-wrap
msgid "write.dta"
msgstr ""

#
#. type: Plain text
#: R-data.texi:1082
msgid "Stata @file{.dta} files are a binary file format. Files from versions 5 up to 11 of Stata can be read and written by functions @code{read.dta} and @code{write.dta}.  Stata variables with value labels are optionally converted to (and from) @R{} factors.  Stata version 12 by default writes `format-115 datasets': @code{read.dta} currently may not be able to read those."
msgstr "Stata '@file{.dta}'파일은 바이너리 포맷의 파일 중 하나입니다. Stata 의 버전 5, 6, 7/SE 그리고 8 의 파일은 함수 @code{read.dta} 와 @code{write.dta} 에 의해 읽고 쓸 수 이씁니다. Stata 변수는 변수명과 함께 @R{} 요소 (R factor)로 변환시키거나 @R{} 요소 (R factor)로부터 변환될 수 있습니다."

#
#. type: cindex
#: R-data.texi:1084
#, no-wrap
msgid "Systat"
msgstr ""

#
#. type: findex
#: R-data.texi:1085
#, no-wrap
msgid "read.systat"
msgstr ""

#
#. type: Plain text
#: R-data.texi:1090
msgid "@code{read.systat} reads those Systat @code{SAVE} files that are rectangular data files (@code{mtype = 1}) written on little-endian machines (such as from Windows).  These have extension @file{.sys} or (more recently) @file{.syd}."
msgstr "@code{read.systat} 는 (Windows 와 같은) little-endian machines 에 쓰여진 장방형의 데이터 파일 (@code{mtype=1})인 Systat @code{SAVE} 파일을 읽습니다. 이것들은 '@file{.sys}' 또는 (보다 최근에는) '@file{.syd}'의 확장자를 가지고 있습니다"

#
#. type: findex
#: R-data.texi:1095
#, no-wrap
msgid "read.octave"
msgstr ""

#
#. type: Plain text
#: R-data.texi:1105
msgid "Octave is a numerical linear algebra system (@uref{http://www.octave.org}), and function @code{read.octave} in package @CRANpkg{foreign} can read in files in Octave text data format created using the Octave command @command{save -ascii}, with support for most of the common types of variables, including the standard atomic (real and complex scalars, matrices, and @math{N}-d arrays, strings, ranges, and boolean scalars and matrices) and recursive (structs, cells, and lists) ones."
msgstr "Octave 는 수치선형대수시스템(numerical linear algebra system)입니다. 외부패키지@CRANpkg{foreign} 내의 함수 @code{read.octave} 는 Octave 명령어인 @command{save-ascii} 를 이용하여 생성된 Octave 텍스트 데이터 포맷의 파일을 읽을 수 있습니다. 이 함수는 일반적인 형태의 대부분의 변수, 표준 atomic(실수, 복소수, 행렬, 그리고 @math{N} 차원의 배열(array), 끈(string), 범위(range) 및 boolean 수와 행렬)과 가역적인 것들(structs, cells, 그리고 목록(lists))을 다룰 수 있습니다."

#
#. type: cindex
#: R-data.texi:1110
#, no-wrap
msgid "DBMS"
msgstr ""

#
#. type: node
#: R-data.texi:1116
#: R-data.texi:1118
#: R-data.texi:1119
#: R-data.texi:1172
#, no-wrap
msgid "Why use a database?"
msgstr ""

#
#. type: node
#: R-data.texi:1116
#: R-data.texi:1118
#: R-data.texi:1172
#: R-data.texi:1173
#: R-data.texi:1211
#: R-data.texi:1282
#: R-data.texi:1321
#, no-wrap
msgid "Overview of RDBMSs"
msgstr ""

#
#. type: node
#: R-data.texi:1116
#: R-data.texi:1172
#: R-data.texi:1321
#: R-data.texi:1322
#: R-data.texi:1360
#: R-data.texi:1451
#, no-wrap
msgid "R interface packages"
msgstr ""

#
#. type: Plain text
#: R-data.texi:1127
msgid "There are limitations on the types of data that @R{} handles well.  Since all data being manipulated by @R{} are resident in memory, and several copies of the data can be created during execution of a function, @R{} is not well suited to extremely large data sets.  Data objects that are more than a (few) hundred megabytes in size can cause @R{} to run out of memory, particularly on a 32-bit operating system."
msgstr "@R{} 이 잘 다룰 수 있는 데이터 형태에는 제한이 있습니다. @R{} 에 의해 조작된 모든 데이터는 메모리 상에 존재하고 데이터의 여러 복제본이 함수를 실행하는 동안 생성될 수 있기 때문에 @R{} 은 아주 큰 테이터셋에는 적합하지 않습니다. 크기가 몇 백 메가바이트 이상인 데이터 object 는 @R{} 구동시 메모리 용량초과문제를 야기할 수 있습니다."

#
#. type: Plain text
#: R-data.texi:1131
msgid "@R{} does not easily support concurrent access to data.  That is, if more than one user is accessing, and perhaps updating, the same data, the changes made by one user will not be visible to the others."
msgstr "@R{} 은 데이터 동시접속이 쉽게 지원되지 않습니다. 즉 한 명 이상의 사용자가 동시에 동일한 데이터에 접속하거나 업데이트 하면 한 사용자가 만든 변화가 다른 사용자에게 보이지 않을 수 있습니다."

#
#. type: Plain text
#: R-data.texi:1136
msgid "@R{} does support persistence of data, in that you can save a data object or an entire worksheet from one session and restore it at the subsequent session, but the format of the stored data is specific to @R{} and not easily manipulated by other systems."
msgstr "@R{} 은 영구데이터를 지원하므로 한 세션에서 데이터 object 나 전체 워크시트를 저장할 수 있고 이어지는 세션에 담을 수 있습니다. 그러나 저장된 데이터 포맷은 @R{} 에 특유한 것으로서 다른 시스템에 의해 쉽게 조작되지 않습니다."

#
#. type: Plain text
#: R-data.texi:1140
msgid "Database management systems (DBMSs) and, in particular, relational DBMSs (RDBMSs) @emph{are} designed to do all of these things well.  Their strengths are"
msgstr "데이터관리시스템(DBMSs)와 특히 관련 DBMSs(RDBMSs)는 위의 모든 것들을 잘 처리할 수 있도록 고안되었습니다. 이것의 장점은 다음과 같습니다."

#
#. type: enumerate
#: R-data.texi:1144
msgid "To provide fast access to selected parts of large databases."
msgstr "큰 데이터베이스에서 선택한 부분에 빠르게 접근할 수 있습니다."

#
#. type: enumerate
#: R-data.texi:1147
msgid "Powerful ways to summarize and cross-tabulate columns in databases."
msgstr "테이터베이스에서 요약하거나 열간 교차표를 만드는 강력한 방법을 제공합니다"

#
#. type: enumerate
#: R-data.texi:1151
msgid "Store data in more organized ways than the rectangular grid model of spreadsheets and @R{} data frames."
msgstr "스프레드시트의 격자모양의 장방형 모형이나 R 데이터 프레임보다 더 조직화된 형태로 데이터를 저장합니다."

#
#. type: enumerate
#: R-data.texi:1155
msgid "Concurrent access from multiple clients running on multiple hosts while enforcing security constraints on access to the data."
msgstr "데이터 접속에 보안제약을 강화하면서 복수의 호스트에서 작업을 하는 다수의 클라이언트가 동시접속 할 수 있습니다."

#
#. type: enumerate
#: R-data.texi:1158
msgid "Ability to act as a server to a wide range of clients."
msgstr "넓은 범위의 클라이어트를 지원하는 서버로서 운용할 수 있습니다."

#
#. type: Plain text
#: R-data.texi:1164
msgid "The sort of statistical applications for which DBMS might be used are to extract a 10% sample of the data, to cross-tabulate data to produce a multi-dimensional contingency table, and to extract data group by group from a database for separate analysis."
msgstr "다차원의 contingency 표를 만들어 내기 위해서 DBMS 가 쓰일 수도 있는 통계적 어플리케이션 부류들은 데이터의 10%를 교차표를 만들기 위해서 표본으로 추출할 수도 있습니다. 그리고 분리된 분석에 사용할 데이터를 데이터베이스에서 그룹별로 추출할 것입니다."

#. type: Plain text
#: R-data.texi:1171
msgid "Increasingly OSes are themselves making use of DBMSs for these reasons, so it is nowadays likely that one will be already installed on your (non-Windows) OS.  @uref{https://en.wikipedia.org/wiki/Akonadi, Akonadi} is used by KDE4 to store personal information.  Several OS X applications, including Mail and Address Book, use SQLite."
msgstr ""

#. type: Plain text
#: R-data.texi:1186
msgid "Traditionally there had been large (and expensive) commercial RDBMSs (@uref{http://www.informix.com, Informix}; @uref{https://www.oracle.com, Oracle}; @uref{http://www.sybase.com, Sybase}; @uref{http://www.ibm.com/db2, IBM's DB2}; @uref{https://www.microsoft.com/SQL/default.mspx, Microsoft @acronym{SQL} Server} on Windows) and academic and small-system databases (such as MySQL@footnote{and forks, notably MariaDB.}, PostgreSQL, Microsoft Access, @dots{}), the former marked out by much greater emphasis on data security features.  The line is blurring, with MySQL and PostgreSQL having more and more high-end features, and free `express' versions being made available for the commercial DBMSs."
msgstr ""

#
#. type: cindex
#: R-data.texi:1187
#: R-data.texi:1453
#, no-wrap
msgid "ODBC"
msgstr ""

#
#. type: cindex
#: R-data.texi:1188
#: R-data.texi:1454
#, no-wrap
msgid "Open Database Connectivity"
msgstr ""

#. type: Plain text
#: R-data.texi:1195
msgid "There are other commonly used data sources, including spreadsheets, non-relational databases and even text files (possibly compressed).  Open Database Connectivity (@acronym{ODBC}) is a standard to use all of these data sources.  It originated on Windows (see @uref{https://msdn.microsoft.com/@/en-us/@/library/@/ms710252%28v=vs.85%29.aspx})  but is also implemented on Linux/Unix/OS X."
msgstr ""

#
#. type: Plain text
#: R-data.texi:1204
msgid "All of the packages described later in this chapter provide clients to client/server databases.  The database can reside on the same machine or (more often) remotely.  There is an @acronym{ISO} standard (in fact several: @acronym{SQL}92 is @acronym{ISO}/IEC 9075, also known as @acronym{ANSI} X3.135-1992, and @acronym{SQL}99 is coming into use) for an interface language called @acronym{SQL} (Structured Query Language, sometimes pronounced `sequel': see Bowman @emph{et al.@:} 1996 and Kline and Kline 2001) which these DBMSs support to varying degrees."
msgstr "데이터베이스는 같은 machine 또는 (보다 자주) 원격적으로 같이 존재할 수 있습니다. 여러 DBMSs 를 지원하는 @acronym{SQL}(Structured Query Language, 종종 'sequel'이라 불리기도 합니다; Bowman et al. 1996 과 Kline 과 Kline 2001 을 참고하십시오) 인터페이스 언어에 대한 @acronym{ISO} 표준이 있습니다(실제로는 @acronym{SQL}92 는 @acronym{ISO}/IEC 9075 또는 @acronym{ANSI} X3.135-1992 라고 알려져 있고 @acronym{SQL}99 가 곧 사용될 것입니다)."

#
#. type: node
#: R-data.texi:1209
#: R-data.texi:1211
#: R-data.texi:1213
#: R-data.texi:1282
#, no-wrap
msgid "SQL queries"
msgstr ""

#
#. type: subsection
#: R-data.texi:1209
#: R-data.texi:1211
#: R-data.texi:1282
#: R-data.texi:1283
#, no-wrap
msgid "Data types"
msgstr ""

#
#. type: subsection
#: R-data.texi:1212
#, no-wrap
msgid "@acronym{SQL} queries"
msgstr ""

#
#. type: Plain text
#: R-data.texi:1220
msgid "The more comprehensive @R{} interfaces generate @acronym{SQL} behind the scenes for common operations, but direct use of @acronym{SQL} is needed for complex operations in all.  Conventionally @acronym{SQL} is written in upper case, but many users will find it more convenient to use lower case in the @R{} interface functions."
msgstr "보다 포괄적인 @R{} 인터페이스들은 일상적인 운용 뒤의 @acronym{SQL} 을 생성하지만 @acronym{SQL} 의 직접적인 사용이 복잡한 운용에 있어 필요합니다. 전통적으로 @acronym{SQL} 은 대문자로 쓰여졌지만 많은 이용자들이 @R{} 인터페이스 함수에서 소문자로 쓰는 것이 더 편리함을 느낄 것입니다."

#
#. type: Plain text
#: R-data.texi:1226
msgid "A relational DBMS stores data as a database of @emph{tables} (or @emph{relations}) which are rather similar to @R{} data frames, in that they are made up of @emph{columns} or @emph{fields} of one type (numeric, character, date, currency, @dots{}) and @emph{rows} or @emph{records} containing the observations for one entity."
msgstr "관련된 DBMS 는 그것들이 하나의 실체에 대한 관측치를 담고 있는 @emph{열}들 또는 @emph{필드}의 한 종류(수치, 문자, 날짜, 등)과 @emph{행} 또는 @emph{레코드}로 만들어진 점에서 데이터를 @R{} 데이터 프레임과 비슷한 @emph{표}들(또는 @emph{관계}들)의 데이터베이스 처럼 저장합니다."

#
#. type: Plain text
#: R-data.texi:1229
msgid "@acronym{SQL} `queries' are quite general operations on a relational database.  The classical query is a SELECT statement of the type"
msgstr "@acronym{SQL} 쿼리(query)는 관련 데이터베이스에서 아주 일반적으로 운용되는 것입니다. 전통적인 쿼리는 다음과 같은 유형의 SELECT 구문입니다."

#
#. type: example
#: R-data.texi:1232
#, no-wrap
msgid ""
"SELECT State, Murder FROM USArrests WHERE Rape > 30 ORDER BY Murder\n"
"\n"
msgstr ""

#
#. type: example
#: R-data.texi:1235
#, no-wrap
msgid ""
"SELECT t.sch, c.meanses, t.sex, t.achieve\n"
"  FROM student as t, school as c WHERE t.sch = c.id\n"
"\n"
msgstr ""

#
#. type: example
#: R-data.texi:1237
#, no-wrap
msgid ""
"SELECT sex, COUNT(*) FROM student GROUP BY sex\n"
"\n"
msgstr ""

#
#. type: example
#: R-data.texi:1239
#, no-wrap
msgid "SELECT sch, AVG(sestat) FROM student GROUP BY sch LIMIT 10\n"
msgstr ""

#
#. type: Plain text
#: R-data.texi:1250
msgid "The first of these selects two columns from the @R{} data frame @code{USArrests} that has been copied across to a database table, subsets on a third column and asks the results be sorted.  The second performs a database @emph{join} on two tables @code{student} and @code{school} and returns four columns.  The third and fourth queries do some cross-tabulation and return counts or averages.  (The five aggregation functions are COUNT(*) and SUM, MAX, MIN and AVG, each applied to a single column.)"
msgstr "이들 중 첫번째는 데이터베이스 표에 교차로 복사된 @R{} 데이터 프레임 @code{USArrest} 로부터 두 열을 선택합니다. 그리고 세 번째 열에서 결과가 정렬되도록 합니다. 두 번째는 @code{학생}과 @code{학교}의 두 표를 네 번째 열에 반환하도록 데이터베이스 @emph{결합} 기능을 수행합니다. 세 번째와 네 번째 쿼리는 교차표를 작성하고 회수와 평균을 반환합니다(다섯 개 총 함수는 COUNT(*)와 SUM, MAX, MAX, MIN 그리고 AVG 이고 각 함수는 하나의 컬럼씩에 적용됩니다)."

#
#. type: Plain text
#: R-data.texi:1259
msgid "SELECT queries use FROM to select the table, WHERE to specify a condition for inclusion (or more than one condition separated by AND or OR), and ORDER BY to sort the result.  Unlike data frames, rows in RDBMS tables are best thought of as unordered, and without an ORDER BY statement the ordering is indeterminate.  You can sort (in lexicographical order) on more than one column by separating them by commas.  Placing DESC after an ORDER BY puts the sort in descending order."
msgstr "SELECT 쿼리는 표를 선택하는데 FROM 을, 포함(또는 AND 또는 OR 로 구분된 하나 이상의 조건)에 대한 조건을 특정하기 위해서 WHERE 를, 그리고 결과를 정렬하기 위해 ORDER BY 를 사용합니다. 데이터 프레임과는 다르게 RDBMS 표에서 행들은 마치 ORDER BY 명령어 없이 순서가 정해져 있지 않은 경우들에 가장 최선의 방법입니다. 여러분은 콤마(,)로 구분하여 하나 이상의 열을 정렬(사전편찬식의 순서로)할 수 있습니다."

#
#. type: Plain text
#: R-data.texi:1262
msgid "SELECT DISTINCT queries will only return one copy of each distinct row in the selected table."
msgstr "SELECT DISTINCT 쿼리는 선택된 표에서 각각 구분된 행의 하나의 사본을 반환합니다."

#
#. type: Plain text
#: R-data.texi:1268
msgid "The GROUP BY clause selects subgroups of the rows according to the criterion.  If more than one column is specified (separated by commas)  then multi-way cross-classifications can be summarized by one of the five aggregation functions.  A HAVING clause allows the select to include or exclude groups depending on the aggregated value."
msgstr "GROUP BY 구문은 기준에 따라 행들의 하위 그룹을 선택합니다. 하나 이상의 열이 콤마(,)에 의해 구분되어 특정되면 다중교차분류(multi-way cross classifications)가 다섯개의 결합함수 중 하나에 의해 요약될 수 있습니다.HAVING 구문은 결합된 값에 따라 포함/제외 그룹을 선택학게 할 수 있습니다."

#
#. type: Plain text
#: R-data.texi:1274
msgid "If the SELECT statement contains an ORDER BY statement that produces a unique ordering, a LIMIT clause can be added to select (by number) a contiguous block of output rows.  This can be useful to retrieve rows a block at a time.  (It may not be reliable unless the ordering is unique, as the LIMIT clause can be used to optimize the query.)"
msgstr "만약 SELECT 명령문이 유일한 순서를 생성하는 ORDER BY 문을 포함한다면, LIMIT 구문은 결과 행들의 연속된 묶음(a contiguous block of output rows)을 선택하여 추가할 수 있습니다. 이것은 일시에 묶음 단위의 열을 추출하는데 유용할 수 있습니다(어쩌면 순서가 유일하지 않는한 LIMIT 구문이 쿼리를 최적화하는 데 사용 가능한 것과 같이 신뢰할만 하지 않을 수도 있습니다)."

#
#. type: Plain text
#: R-data.texi:1278
msgid "There are queries to create a table (CREATE TABLE, but usually one copies a data frame to the database in these interfaces), INSERT or DELETE or UPDATE data.  A table is destroyed by a DROP TABLE `query'."
msgstr "CREATE TABLE 과 같이 표를 만들지만 보통은 이 인터페이스에서 데이터프레임을 데이터베이스에 복사하는 INSERT, DELETE 또는 UPDATE data 가 있습니다. 표는 쿼리 DROP TABLE 로 삭제될 수 있습니다."

#
#. type: Plain text
#: R-data.texi:1281
msgid "Kline and Kline (2001) discuss the details of the implementation of SQL in Microsoft SQL Server 2000, Oracle, MySQL and PostgreSQL."
msgstr "Kline and Kline(2001)은 SQL 서버 2000, 오라클. MySQL 과 PostgreSQL 에서 SQL 도입에 대해 자세히 논하였습니다."

#
#. type: Plain text
#: R-data.texi:1289
msgid "Data can be stored in a database in various data types.  The range of data types is DBMS-specific, but the @acronym{SQL} standard defines many types, including the following that are widely implemented (often not by the @acronym{SQL} name)."
msgstr "데이터는 다양한 형태로 데이터베이스에 저장될 수 있습니다. 데이터 형태의 범의는 DBMS 에 따라 결정되지만, (@acronym{SQL} 의 이름이 아니라) @acronym{SQL} 표준이 아래에 나열되어 있는 널리 도입되어 있는 것을 포함하여 많은 유형을 정의하고 있습니다."

#
#. type: item
#: R-data.texi:1291
#, no-wrap
msgid "float(@var{p})"
msgstr ""

#
#. type: table
#: R-data.texi:1294
msgid "Real number, with optional precision.  Often called @code{real} or @code{double} or @code{double precision}."
msgstr ""

#
#. type: item
#: R-data.texi:1294
#, no-wrap
msgid "integer"
msgstr ""

#
#. type: table
#: R-data.texi:1296
msgid "32-bit integer.  Often called @code{int}."
msgstr ""

#
#. type: item
#: R-data.texi:1296
#, no-wrap
msgid "smallint"
msgstr ""

#
#. type: table
#: R-data.texi:1298
msgid "16-bit integer"
msgstr ""

#
#. type: item
#: R-data.texi:1298
#, no-wrap
msgid "character(@var{n})"
msgstr ""

#
#. type: table
#: R-data.texi:1300
msgid "fixed-length character string.  Often called @code{char}."
msgstr ""

#
#. type: item
#: R-data.texi:1300
#, no-wrap
msgid "character varying(@var{n})"
msgstr ""

#
#. type: table
#: R-data.texi:1303
msgid "variable-length character string.  Often called @code{varchar}.  Almost always has a limit of 255 chars."
msgstr ""

#
#. type: item
#: R-data.texi:1303
#, no-wrap
msgid "boolean"
msgstr ""

#
#. type: table
#: R-data.texi:1305
msgid "true or false.  Sometimes called @code{bool} or @code{bit}."
msgstr ""

#
#. type: item
#: R-data.texi:1305
#, no-wrap
msgid "date"
msgstr ""

#
#. type: table
#: R-data.texi:1307
msgid "calendar date"
msgstr ""

#
#. type: item
#: R-data.texi:1307
#, no-wrap
msgid "time"
msgstr ""

#
#. type: table
#: R-data.texi:1309
msgid "time of day"
msgstr ""

#
#. type: item
#: R-data.texi:1309
#, no-wrap
msgid "timestamp"
msgstr ""

#
#. type: table
#: R-data.texi:1311
msgid "date and time"
msgstr ""

#
#. type: Plain text
#: R-data.texi:1317
msgid "There are variants on @code{time} and @code{timestamp}, @code{with timezone}.  Other types widely implemented are @code{text} and @code{blob}, for large blocks of text and binary data, respectively."
msgstr "@code{timezone} 과 함께 @code{time} 과 @code{timestamp} 에는 많은 변형이 있습니다. 대용량의 텍스트와 바이너리 데이터 블럭을 위해 도입된 다른 많은 유형들이 각각 텍스트와 벌브(@code{text} and @code{blob})의 형태로 있습니다."

#
#. type: Plain text
#: R-data.texi:1320
msgid "The more comprehensive of the @R{} interface packages hide the type conversion issues from the user."
msgstr "더욱 포괄적인 @R{} 인더페이스 패키지가 사용자로부터 형변환(the type conversion)을 숨겨져 있습니다."

#
#. type: Plain text
#: R-data.texi:1330
msgid "There are several packages available on @acronym{CRAN} to help @R{} communicate with DBMSs.  They provide different levels of abstraction.  Some provide means to copy whole data frames to and from databases.  All have functions to select data within the database via @acronym{SQL} queries, and to retrieve the result as a whole as a data frame or in pieces (usually as groups of rows)."
msgstr "@R{} 도움말을 위해 DBMSs 와 연계된 @acronym{CRAN} 에 관한 여러 종류의 패키지가 사용할 수 있습니다. 이것들은 여러 수준의 추론(abstraction)을 제공합니다. 어떤 것은 데이터베이스로부터 그리고 데이터베이스로 전체 데이터로 복사하는 기능을 제공합니다. 모든 패키지들이 데이터베이스에서 @acronym{SQL} 쿼리를 통해 데이터를 선택하고 데이터 프레임이나 그 일부(보통은 행들의 집합으로 구성된)로써 결과를 출력하기 위한 함수를 가지고 있습니다."

#. type: Plain text
#: R-data.texi:1340
msgid "All except @CRANpkg{RODBC} are tied to one DBMS, but there has been a proposal for a unified `front-end' package @CRANpkg{DBI} (@uref{https://developer.r-project.org/db}) in conjunction with a `back-end', the most developed of which is @CRANpkg{RMySQL}.  Also on @acronym{CRAN} are the back-ends @CRANpkg{ROracle}, @CRANpkg{RPostgreSQL} and @CRANpkg{RSQLite} (which works with the bundled DBMS @code{SQLite}, @uref{https://www.sqlite.org}), @CRANpkg{RJDBC} (which uses Java and can connect to any DBMS that has a JDBC driver) and @CRANpkg{RpgSQL} (a specialist interface to PostgreSQL built on top of @CRANpkg{RJDBC})."
msgstr ""

#
#. type: Plain text
#: R-data.texi:1343
msgid "The BioConductor project has updated @pkg{RdbiPgSQL} (formerly on @acronym{CRAN} ca 2000), a first-generation interface to PostgreSQL."
msgstr "초기의 두 개 패키지 RmSQL 과 RPgSQL 은 현재 지원되지 않고 @acronym{CRAN} 상의 아카이브 영역에 있습니다."

#
#. type: Plain text
#: R-data.texi:1347
msgid "@pkg{PL/R} (@uref{http://www.joeconway.com/plr/, @code{http://@/www.joeconway.com/@/plr/}}) is a project to embed R into PostgreSQL."
msgstr " BioConductor 프로젝트는 RdbPgSQL 로 CRAN 상에 업데이트 되어 있습니다. @pkg{PL/R}(@uref{http://www.joeconway.com/plr/})은 R 을 PostgreSQL 에 심기위한 프로젝트 입니다."

#. type: Plain text
#: R-data.texi:1352
msgid "Package @CRANpkg{RMongo} provides an @R{} interface to a Java client for `MongoDB' (@uref{https://en.wikipedia.org/wiki/MongoDB}) databases, which are queried using JavaScript rather than SQL.  Package @CRANpkg{rmongodb} is another client using @pkg{mongodb}'s C driver."
msgstr ""

#
#. type: node
#: R-data.texi:1357
#: R-data.texi:1360
#: R-data.texi:1451
#, no-wrap
msgid "DBI"
msgstr ""

#
#. type: node
#: R-data.texi:1357
#: R-data.texi:1360
#: R-data.texi:1451
#, no-wrap
msgid "RODBC"
msgstr ""

#
#. type: subsection
#: R-data.texi:1361
#, no-wrap
msgid "Packages using DBI"
msgstr ""

#
#. type: cindex
#: R-data.texi:1362
#: R-data.texi:1543
#, no-wrap
msgid "MySQL database system"
msgstr ""

#. type: Plain text
#: R-data.texi:1371
msgid "Package @CRANpkg{RMySQL} on @acronym{CRAN} provides an interface to the MySQL database system (see @uref{https://www.mysql.com} and Dubois, 2000) or its fork MariaDB (see @uref{https://mariadb.org/}).  The description here applies to versions @code{0.5-0} and later: earlier versions had a substantially different interface.  The current version requires the @CRANpkg{DBI} package, and this description will apply with minor changes to all the other back-ends to @CRANpkg{DBI}."
msgstr ""

#
#. type: Plain text
#: R-data.texi:1377
msgid "MySQL exists on Unix/Linux/OS X and Windows: there is a `Community Edition' released under GPL but commercial licenses are also available.  MySQL was originally a `light and lean' database.  (It preserves the case of names where the operating file system is case-sensitive, so not on Windows.)"
msgstr "2001 년 1 월의 3.23.x 버전부터 GPL 하에서 공개된 MySQL 은 Unix/Linux 및 Windows 에 존재합니다. MySQL 은 '가볍고 간결한' 데이터 베이스 입니다(그것은 운용 중인 파일 시스템이 경우에 따라 민감한 이름의 경우를 유지하여 Windows 에서는 작동되지 않습니다). 패키지 RMySQL 은 Linux 와 Windows 모두에서 사용되고 있습니다."

#
#. type: findex
#: R-data.texi:1379
#, no-wrap
msgid "dbDriver"
msgstr ""

#
#. type: findex
#: R-data.texi:1380
#, no-wrap
msgid "dbConnect"
msgstr ""

#
#. type: findex
#: R-data.texi:1381
#, no-wrap
msgid "dbDisconnect"
msgstr ""

#
#. type: Plain text
#: R-data.texi:1389
msgid "The call @code{dbDriver(\"MySQL\")} returns a database connection manager object, and then a call to @code{dbConnect} opens a database connection which can subsequently be closed by a call to the generic function @code{dbDisconnect}.  Use @code{dbDriver(\"Oracle\")}, @code{dbDriver(\"PostgreSQL\")} or @code{dbDriver(\"SQLite\")} with those DBMSs and packages @CRANpkg{ROracle}, @CRANpkg{RPostgreSQL} or @CRANpkg{RSQLite} respectively."
msgstr "@code{dbDriver(\"MySQL\")}의 호출은 데이터베이스 연결 객체를 반환하고 @code{dbConnect} 의 호출은 데이터베이스 연결(이것은 범용적 함수인 @code{dbDisconnect} 를 호출함으로써 닫는)을 열게 합니다. @CRANpkg{ROracle}, @code{PostgreSQL}, 또는 @code{RSQLite} 과 같은 각각의 DBMS 와 함께 @code{dbDriver(\"Oracle\")}, @code{dbDriver(\"PostgreSQL\")} @CRANpkg{RPostgreSQL}또는 @CRANpkg{dbDriver(\"SQLite\")}을 사용합니다."

#
#. type: findex
#: R-data.texi:1390
#, no-wrap
msgid "dbSendQuery"
msgstr ""

#
#. type: findex
#: R-data.texi:1391
#, no-wrap
msgid "dbClearResult"
msgstr ""

#
#. type: findex
#: R-data.texi:1392
#, no-wrap
msgid "dbGetQuery"
msgstr ""

#
#. type: Plain text
#: R-data.texi:1399
msgid "@acronym{SQL} queries can be sent by either @code{dbSendQuery} or @code{dbGetQuery}.  @code{dbGetquery} sends the query and retrieves the results as a data frame.  @code{dbSendQuery} sends the query and returns an object of class inheriting from @code{\"DBIResult\"} which can be used to retrieve the results, and subsequently used in a call to @code{dbClearResult} to remove the result."
msgstr "@acronym{SQL} 쿼리들은 @code{dbSendQuery} 또는 @code{dbGetQuery} 에 의해 보내질 수 있습니다. @code{dbGetQuery} 는 쿼리를 보내고 그 결과를 데이터프레임 처럼 추출할 수 있습니다. @code{dbSendQuery} 는 쿼리를 내보내고 그 결과들을 추출하는데 종종 사용될 수 있는 @code{\"DBIResult\"}로부터 이어 받은 class 의 객체를 반환하고 그 결과를 삭제하기 위해 @code{dbClearResult} 를 호출하는데 사용됩니다."

#
#. type: findex
#: R-data.texi:1400
#, no-wrap
msgid "fetch"
msgstr ""

#
#. type: Plain text
#: R-data.texi:1405
msgid "Function @code{fetch} is used to retrieve some or all of the rows in the query result, as a list.  The function @code{dbHasCompleted} indicates if all the rows have been fetched, and @code{dbGetRowCount} returns the number of rows in the result."
msgstr "함수 @code{fetch} 는 쿼리의 결과 중 일부분 또는 전체 행을 리스트로 추출하는데 사용됩니다. 모든 행이 fetch 되면 @code{dbHasCompleted} 와 @code{dbGetRowCount} 는 결과에서 행의 수를 나타내거나 반환합니다."

#
#. type: findex
#: R-data.texi:1406
#, no-wrap
msgid "dbReadTable"
msgstr ""

#
#. type: findex
#: R-data.texi:1407
#, no-wrap
msgid "dbWriteTable"
msgstr ""

#
#. type: findex
#: R-data.texi:1408
#, no-wrap
msgid "dbExistsTable"
msgstr ""

#
#. type: findex
#: R-data.texi:1409
#, no-wrap
msgid "dbRemoveTable"
msgstr ""

#
#. type: Plain text
#: R-data.texi:1414
msgid "These are convenient interfaces to read/write/test/delete tables in the database.  @code{dbReadTable} and @code{dbWriteTable} copy to and from an @R{} data frame, mapping the row names of the data frame to the field @code{row_names} in the @code{MySQL} table."
msgstr "데이터베이스에서 표를 읽고, 쓰고, 검증하고 그리고 삭제하기 위한 편리한 인터페이스가 있습니다. @code{dbReadTable} 과 @code{dbWriteTable} 은 @code{MySQL} 표에 필드의 @code{row_names}을 위해 데이터프레임의 행이름을 하는"

#
#. type: smallexample
#: R-data.texi:1449
#, no-wrap
msgid ""
"> library(RMySQL) # will load DBI as well\n"
"## open a connection to a MySQL database\n"
"> con <- dbConnect(dbDriver(\"MySQL\"), dbname = \"test\")\n"
"## list the tables in the database\n"
"> dbListTables(con)\n"
"## load a data frame into the database, deleting any existing copy\n"
"> data(USArrests)\n"
"> dbWriteTable(con, \"arrests\", USArrests, overwrite = TRUE)\n"
"TRUE\n"
"> dbListTables(con)\n"
"[1] \"arrests\"\n"
"## get the whole table\n"
"> dbReadTable(con, \"arrests\")\n"
"               Murder Assault UrbanPop Rape\n"
"Alabama          13.2     236       58 21.2\n"
"Alaska           10.0     263       48 44.5\n"
"Arizona           8.1     294       80 31.0\n"
"Arkansas          8.8     190       50 19.5\n"
"...\n"
"## Select from the loaded table\n"
"> dbGetQuery(con, paste(\"select row_names, Murder from arrests\",\n"
"                        \"where Rape > 30 order by Murder\"))\n"
"   row_names Murder\n"
"1   Colorado    7.9\n"
"2    Arizona    8.1\n"
"3 California    9.0\n"
"4     Alaska   10.0\n"
"5 New Mexico   11.4\n"
"6   Michigan   12.1\n"
"7     Nevada   12.2\n"
"8    Florida   15.4\n"
"> dbRemoveTable(con, \"arrests\")\n"
"> dbDisconnect(con)\n"
msgstr ""

#
#. type: subsection
#: R-data.texi:1452
#, no-wrap
msgid "Package RODBC"
msgstr ""

#
#. type: Plain text
#: R-data.texi:1464
msgid "Package @CRANpkg{RODBC} on @acronym{CRAN} provides an interface to database sources supporting an @acronym{ODBC} interface.  This is very widely available, and allows the same @R{} code to access different database systems.  @CRANpkg{RODBC} runs on Unix/Linux, Windows and OS X, and almost all database systems provide support for @acronym{ODBC}.  We have tested Microsoft SQL Server, Access, MySQL, PostgreSQL, Oracle and IBM DB2 on Windows and MySQL, MariaDB, Oracle, PostgreSQL and SQLite on Linux."
msgstr "@acronym{CRAN} 상의 패키지 @CRANpkg{RODBC} 는 특정한 @acronym{ODBC} 인터페이스를 지원하는 테이터베이스 원천을 위한 인터페이스를 제공합니다. 이것은 매우 광범위하게 적용되고 다른 데이터베이스 시스템에 접속하기 위한 동일한 @R{} 코드를 허용합니다. @CRANpkg{RODBC} 는 Unix/Linux 와 Windows 둘 모두에서 작동하고 거의 모든 시스템이 @acronym{ODBC} 를 위한 지원을 제공합니다. 이제껏 Windows 에서 마이크로소프트의 SQL Server, Access, MySQL 과 PostgreSQL 을 그리고 Linux 에서 MySQL, Oracle, PostgreSQL 과 SQLite 을 시험해 왔습니다. "

#
#. type: Plain text
#: R-data.texi:1467
msgid "ODBC is a client-server system, and we have happily connected to a DBMS running on a Unix server from a Windows client, and @emph{vice versa}."
msgstr "ODBC 는 클라이언트-서버 시스템이어서 Windows 클라이언트에서 Unix 서버에 관해 작동하는 DBMS 에 행복하게 접속해 왔습니다."

#
#. type: Plain text
#: R-data.texi:1473
msgid "On Windows ODBC support is part of the OS.  On Unix/Linux you will need an @acronym{ODBC} Driver Manager such as unixODBC (@uref{http://www.unixODBC.org}) or iOBDC (@uref{http://www.iODBC.org}: this is pre-installed in OS X) and an installed driver for your database system."
msgstr "Windows 에서 ODBC 지원은 평범하게 설치되었고 현재 버전은 MDAC 의 일부로서 http://www.microsoft.com/data/odbc/에서 사용 가능합니다. Unix 또는 Linux 상에서 여러분은 unixODBC(@uref{http://www.unixODBC.org}) 또는 iOBDC (@uref{http://www.iODBC.org})와 같은 @acronym{ODBC} 드라이버 관리자(driver manager)와 여러분의 데이터베이스 시스템에 적함한 설치된 드라이버가 필요합니다"

#
#. type: cindex
#: R-data.texi:1474
#: R-data.texi:1581
#, no-wrap
msgid "Excel"
msgstr ""

#
#. type: findex
#: R-data.texi:1475
#: R-data.texi:1582
#, no-wrap
msgid ".xls"
msgstr ""

#
#. type: cindex
#: R-data.texi:1476
#, no-wrap
msgid "Dbase"
msgstr ""

#
#. type: findex
#: R-data.texi:1477
#, no-wrap
msgid ".dbf"
msgstr ""

#. type: Plain text
#: R-data.texi:1488
msgid "Windows provides drivers not just for DBMSs but also for Excel (@file{.xls}) spreadsheets, DBase (@file{.dbf}) files and even text files.  (The named applications do @emph{not} need to be installed. Which file formats are supported depends on the versions of the drivers.)  There are versions for Excel and Access 2007/2010 (go to @uref{https://www.microsoft.com/@/en-us/@/download/@/default.aspx}, and search for `Office ODBC', which will lead to @file{AccessDatabaseEngine.exe}), the `2007 Office System Driver' (the latter has a version for 64-bit Windows, and that will also read earlier versions)."
msgstr ""

#. type: Plain text
#: R-data.texi:1493
msgid "On OS X the Actual Technologies (@url{https://www.actualtech.com/product_access.php}) drivers provide ODBC interfaces to Access databases (including Access 2007/2010)  and to Excel spreadsheets (not including Excel 2007/2010)."
msgstr ""

#
#. type: findex
#: R-data.texi:1494
#, no-wrap
msgid "odbcConnect"
msgstr ""

#
#. type: findex
#: R-data.texi:1495
#, no-wrap
msgid "odbcDriverConnect"
msgstr ""

#
#. type: findex
#: R-data.texi:1496
#, no-wrap
msgid "odbcGetInfo"
msgstr ""

#
#. type: Plain text
#: R-data.texi:1503
msgid "Many simultaneous connections are possible.  A connection is opened by a call to @code{odbcConnect} or @code{odbcDriverConnect} (which on the Windows GUI allows a database to be selected via dialog boxes) which returns a handle used for subsequent access to the database.  Printing a connection will provide some details of the ODBC connection, and calling @code{odbcGetInfo} will give details on the client and server."
msgstr " 동시에 많은 연결(connections)을 하는 것도 가능합니다. 연결은 데이터베이스가 대화상자를 통해 수집된 되도록 하는 Windows GUI 에 따라 @code{odbcConnect} 나 @code{odbcDriverConnect} 를 호출하여 열고 이후의 데이터베이스 접속을 위해 사용된 것(handle)을 반환합니다."

#
#. type: findex
#: R-data.texi:1505
#, no-wrap
msgid "odbcClose"
msgstr ""

#
#. type: findex
#: R-data.texi:1506
#: R-data.texi:1872
#, no-wrap
msgid "close"
msgstr ""

#
#. type: Plain text
#: R-data.texi:1510
msgid "A connection is closed by a call to @code{close} or @code{odbcClose}, and also (with a warning) when not R object refers to it and at the end of an R session."
msgstr "연결은 @code{close} 나 @code{odbcClose} 를 호출하거나 또한 (경고 메세지와 함께) R 객체가 아닌 것이 그것을 참조하거나 특정 R 세션의 마지막에 닫습니다."

#
#. type: findex
#: R-data.texi:1511
#, no-wrap
msgid "sqlTables"
msgstr ""

#
#. type: Plain text
#: R-data.texi:1514
msgid "Details of the tables on a connection can be found using @code{sqlTables}."
msgstr ""

#
#. type: findex
#: R-data.texi:1515
#, no-wrap
msgid "sqlFetch"
msgstr ""

#
#. type: findex
#: R-data.texi:1516
#, no-wrap
msgid "sqlSave"
msgstr ""

#
#. type: Plain text
#: R-data.texi:1520
msgid "Function @code{sqlSave} copies an @R{} data frame to a table in the database, and @code{sqlFetch} copies a table in the database to an @R{} data frame."
msgstr "함수 @code{sqlSave} 는 데이터베이스에서 R 데이터프레임을 표로 복사하고 @code{sqlFetch} 는 데이터베이스 내의 표를 특정한 @R{} 데이터프레임으로 복사합니다."

#
#. type: findex
#: R-data.texi:1521
#, no-wrap
msgid "sqlQuery"
msgstr ""

#
#. type: findex
#: R-data.texi:1522
#, no-wrap
msgid "sqlCopy"
msgstr ""

#
#. type: findex
#: R-data.texi:1523
#, no-wrap
msgid "odbcQuery"
msgstr ""

#
#. type: findex
#: R-data.texi:1524
#, no-wrap
msgid "sqlGetResults"
msgstr ""

#
#. type: findex
#: R-data.texi:1525
#, no-wrap
msgid "sqlFetchMore"
msgstr ""

#
#. type: Plain text
#: R-data.texi:1533
msgid "An @acronym{SQL} query can be sent to the database by a call to @code{sqlQuery}.  This returns the result in an @R{} data frame.  (@code{sqlCopy} sends a query to the database and saves the result as a table in the database.)  A finer level of control is attained by first calling @code{odbcQuery} and then @code{sqlGetResults} to fetch the results.  The latter can be used within a loop to retrieve a limited number of rows at a time, as can function @code{sqlFetchMore}."
msgstr "어떤 @acronym{SQL} 쿼리는 @code{sqlQuery} 를 호출하여 데이터베이스로 보내질 수 있습니다. 이것은 @R{} 데이터프레임에서 결과를 반환합니다(@code{sqlCopy} 는 쿼리를 데이터베이스로 보내고 데이터베이스에서 표처럼 결과물을 저장합니다). 보다 좋은 수준의 통제는 최초에 @code{odbcQuery} 를 호출함으로써 달성되며 @code{sqlGetResults} 는 결과를 불러옵니다. 후자는 함수 @code{sqlFetchMore} 의 기능처럼 반복되는 과정에서 일시에 제한된 수의 행들을 추출하는데 사용될 수 있습니다."

#
#. type: cindex
#: R-data.texi:1534
#, no-wrap
msgid "PostgreSQL database system"
msgstr ""

#
#. type: Plain text
#: R-data.texi:1543
msgid "Here is an example using PostgreSQL, for which the @acronym{ODBC} driver maps column and data frame names to lower case.  We use a database @code{testdb} we created earlier, and had the DSN (data source name) set up in @file{~/.odbc.ini} under @code{unixODBC}.  Exactly the same code worked using MyODBC to access a MySQL database under Linux or Windows (where MySQL also maps names to lowercase).  Under Windows, @acronym{DSN}s are set up in the @acronym{ODBC} applet in the Control Panel (`Data Sources (ODBC)' in the `Administrative Tools' section)."
msgstr "여기에 @acronym{ODBC} 드라이버가 행과 데이터프레임명을 낮은 사례로 포착하는데 PostgreSQL 을 이용하는 사례가 있습니다. 우리는 이전에 생성한 @code{testdb} 라는 데이터베이스를 사용하고 DSN(데이터 소스명)을 @code{unixODBC} 에서 '@file{~/.odbc.ini}'에 준비하였습니다. 정확히 동일한 코드가 Linux 나 Windows 에서 MySQL 데이터베이스에 접속하기 위해 MyODBC 를 사용하여 작동되었습니다(MySQL 은 또한 이름을 낮은 케이스로 파악합니다). Windows 에서 @acronym{DSN} 들은 관리자(the Control Panel)에서 @acronym{ODBC} 애플릿에 준비됩니다(2000/XP 에서 '응용도구(Administrative Tools)' 섹션에 'Data Sources(ODBC)')."

#
#. type: smallexample
#: R-data.texi:1579
#, no-wrap
msgid ""
"> library(RODBC)\n"
"## tell it to map names to l/case\n"
"> channel <- odbcConnect(\"testdb\", uid=\"ripley\", case=\"tolower\")\n"
"## load a data frame into the database\n"
"> data(USArrests)\n"
"> sqlSave(channel, USArrests, rownames = \"state\", addPK = TRUE)\n"
"> rm(USArrests)\n"
"## list the tables in the database\n"
"> sqlTables(channel)\n"
"  TABLE_QUALIFIER TABLE_OWNER TABLE_NAME TABLE_TYPE REMARKS\n"
"1                              usarrests      TABLE        \n"
"## list it\n"
"> sqlFetch(channel, \"USArrests\", rownames = \"state\")\n"
"               murder assault urbanpop rape\n"
"Alabama          13.2     236       58 21.2\n"
"Alaska           10.0     263       48 44.5\n"
"    ...\n"
"## an SQL query, originally on one line\n"
"> sqlQuery(channel, \"select state, murder from USArrests\n"
"           where rape > 30 order by murder\")\n"
"       state murder\n"
"1 Colorado      7.9\n"
"2 Arizona       8.1\n"
"3 California    9.0\n"
"4 Alaska       10.0\n"
"5 New Mexico   11.4\n"
"6 Michigan     12.1\n"
"7 Nevada       12.2\n"
"8 Florida      15.4\n"
"## remove the table\n"
"> sqlDrop(channel, \"USArrests\")\n"
"## close the connection\n"
"> odbcClose(channel)\n"
msgstr ""

#
#. type: findex
#: R-data.texi:1583
#: R-data.texi:2284
#, no-wrap
msgid "odbcConnectExcel"
msgstr ""

#
#. type: Plain text
#: R-data.texi:1586
msgid "As a simple example of using @acronym{ODBC} under Windows with a Excel spreadsheet, we can read from a spreadsheet by"
msgstr "Windows 에서 엑셀작업시트로 @acronym{ODBC} 를 사용하는 단순한 예로 우리는 작업시트에서 다음과 같이 읽을 수 있습니다."

#
#. type: smallexample
#: R-data.texi:1600
#, no-wrap
msgid ""
"> library(RODBC)\n"
"> channel <- odbcConnectExcel(\"bdr.xls\")\n"
"## list the spreadsheets\n"
"> sqlTables(channel)\n"
"  TABLE_CAT TABLE_SCHEM        TABLE_NAME   TABLE_TYPE REMARKS\n"
"1 C:\\\\bdr            NA           Sheet1$ SYSTEM TABLE      NA\n"
"2 C:\\\\bdr            NA           Sheet2$ SYSTEM TABLE      NA\n"
"3 C:\\\\bdr            NA           Sheet3$ SYSTEM TABLE      NA\n"
"4 C:\\\\bdr            NA Sheet1$Print_Area        TABLE      NA\n"
"## retrieve the contents of sheet 1, by either of\n"
"> sh1 <- sqlFetch(channel, \"Sheet1\")\n"
"> sh1 <- sqlQuery(channel, \"select * from [Sheet1$]\")\n"
msgstr ""

#
#. type: Plain text
#: R-data.texi:1606
msgid "Notice that the specification of the table is different from the name returned by @code{sqlTables}: @code{sqlFetch} is able to map the differences."
msgstr "표를 특정하는 것과 @code{sqlTables} 에 의해 반환된 이름은 다르다는 것에 주의하십시오. @code{sqlFetch} 는 그 차이를 파악할 수 있습니다."

#
#. type: node
#: R-data.texi:1734
#: R-data.texi:1741
#: R-data.texi:1742
#: R-data.texi:1770
#, no-wrap
msgid "Binary data formats"
msgstr ""

#
#. type: section
#: R-data.texi:1734
#: R-data.texi:1741
#: R-data.texi:1770
#: R-data.texi:1771
#, no-wrap
msgid "dBase files (DBF)"
msgstr ""

#
#. type: Plain text
#: R-data.texi:1738
msgid "Binary connections (@ref{Connections}) are now the preferred way to handle binary files."
msgstr "Binary connections(Chapter 6 @ref{Connections}, Page ?)는 binary file 을 다루는데 현재 가장 선호되는 방법입니다."

#
#. type: findex
#: R-data.texi:1743
#, no-wrap
msgid "hdf5"
msgstr ""

#
#. type: cindex
#: R-data.texi:1744
#, no-wrap
msgid "Hierarchical Data Format"
msgstr ""

#
#. type: findex
#: R-data.texi:1746
#, no-wrap
msgid "netCDF"
msgstr ""

#
#. type: cindex
#: R-data.texi:1747
#, no-wrap
msgid "network Common Data Form"
msgstr ""

#. type: Plain text
#: R-data.texi:1755
msgid "Packages @CRANpkg{hdf5}, @CRANpkg{h5r}, Bioconductor's @pkg{rhdf5}, @CRANpkg{RNetCDF}, @CRANpkg{ncdf} and @CRANpkg{ncdf4} on @acronym{CRAN} provide interfaces to @acronym{NASA}'s HDF5 (Hierarchical Data Format, see @uref{https://www.hdfgroup.org/HDF5/}) and to UCAR's netCDF data files (network Common Data Form, see @uref{http://www.unidata.ucar.edu/software/netcdf/})."
msgstr ""

#
#. type: Plain text
#: R-data.texi:1761
msgid "Both of these are systems to store scientific data in array-oriented ways, including descriptions, labels, formats, units, @dots{}.  HDF5 also allows @emph{groups} of arrays, and the @R{} interface maps lists to HDF5 groups, and can write numeric and character vectors and matrices."
msgstr "이 둘은 모두 데이터에 대한 개략적 설명(descriptions), 라벨(labels), 포맷(formats), 단위(units),@dots{} 등을 포함하는 과학적 데이터를 배열기준(array-oriented)의 방법으로 저장하는 시스템입니다. HDF5 는 또한 배열(arrays)을 @emph{그룹화}하고, R interface 는 HDF5 그룹에 대한 리스트를 확인(map)하게 할 수 있으며, 숫자나 문자 벡터나 행렬을 사용할 수 있습니다"

#
#. type: Plain text
#: R-data.texi:1766
msgid "NetCDF's version 4 format (confusingly, implemented in netCDF 4.1.1 and later, but not in 4.0.1) includes the use of various HDF5 formats.  This is handled by package @CRANpkg{ncdf4} whereas @CRANpkg{RNetCDF} and @CRANpkg{ncdf} handle version 3 files."
msgstr ""

#
#. type: Plain text
#: R-data.texi:1769
msgid "The availability of software to support these formats is somewhat limited by platform, especially on Windows."
msgstr ""

#
#. type: cindex
#: R-data.texi:1773
#, no-wrap
msgid "dBase"
msgstr ""

#
#. type: cindex
#: R-data.texi:1774
#, no-wrap
msgid "DBF files"
msgstr ""

#
#. type: Plain text
#: R-data.texi:1788
msgid "@code{dBase} was a DOS program written by Ashton-Tate and later owned by Borland which has a binary flat-file format that became popular, with file extension @file{.dbf}.  It has been adopted for the 'Xbase' family of databases, covering dBase, Clipper, FoxPro and their Windows equivalents Visual dBase, Visual Objects and Visual FoxPro (see @uref{http://www.e-bachmann.dk/docs/xbase.htm}).  A dBase file contains a header and then a series of fields and so is most similar to an @R{} data frame.  The data itself is stored in text format, and can include character, logical and numeric fields, and other types in later versions (see for example @uref{http://www.digitalpreservation.gov/formats/fdd/fdd000325.shtml} and @uref{http://www.clicketyclick.dk/databases/xbase/format/index.html})."
msgstr ""

#
#. type: findex
#: R-data.texi:1789
#, no-wrap
msgid "read.dbf"
msgstr ""

#
#. type: findex
#: R-data.texi:1790
#, no-wrap
msgid "write.dbf"
msgstr ""

#
#. type: Plain text
#: R-data.texi:1797
msgid "Functions @code{read.dbf} and @code{write.dbf} provide ways to read and write basic DBF files on all @R{} platforms.  For Windows users @code{odbcConnectDbase} in package @CRANpkg{RODBC} provides more comprehensive facilities to read DBF files @emph{via} Microsoft's dBase ODBC driver (and the Visual FoxPro driver can also be used via @code{odbcDriverConnect})."
msgstr "@code{read.dbf} 와 @code{write.dbf} 함수(function)는 모든 R platform 에 기본적인 DBF 파일은 읽고 작성할 수 있는 방법을 제공합니다. @CRANpkg{RODBC} package 내의 @code{odbcConnectDbase} 는 윈도우 이용자들에게 마이크로소프트가 제공하는 dBase 드라이버를 통해 DBF 파일을 읽는데 보다 포괄적인 도구들을 제공합니다(또한 Visual FoxPro 드라이버도 @code{odbcDriverConnect} 를 통해 사용가능 합니다)."

#
#. type: findex
#: R-data.texi:1797
#, no-wrap
msgid "odbcConnectDbase"
msgstr ""

#
#. type: Plain text
#: R-data.texi:1804
msgid "A particular class of binary files are those representing images, and a not uncommon request is to read such a file into @R{} as a matrix."
msgstr ""

#
#. type: Plain text
#: R-data.texi:1814
msgid "There are many formats for image files (most with lots of variants), and it may be necessary to use external conversion software to first convert the image into one of the formats for which a package currently provides an @R{} reader.  A versatile example of such software is ImageMagick and its fork GraphicsMagick.  These provide command-line programs @command{convert} and @command{gm convert} to convert images from one format to another: what formats they can input is determined when they are compiled, and the supported formats can be listed by e.g.@: @command{convert -list format}."
msgstr ""

#
#. type: Plain text
#: R-data.texi:1818
msgid "Package @CRANpkg{pixmap} has a function @code{read.pnm} to read `portable anymap' images in PBM (black/white), PGM (grey) and PPM (RGB colour)  formats.  These are also known as `netpbm' formats."
msgstr ""

#
#. type: Plain text
#: R-data.texi:1822
msgid "Packages @CRANpkg{bmp}, @CRANpkg{jpeg} and @CRANpkg{png} read the formats after which they are named.  See also packages @CRANpkg{biOps} and @CRANpkg{Momocs}, and Bioconductor package @pkg{EBImage}."
msgstr ""

#
#. type: Plain text
#: R-data.texi:1829
msgid "TIFF is more a meta-format, a wrapper within which a very large variety of image formats can be embedded.  Packages @CRANpkg{rtiff} (orphaned)  and @CRANpkg{tiff} can read some of the sub-formats (depending on the external @code{libtiff} software against which they are compiled).  There some facilities for specialized sub-formats, for example in Bioconductor package @pkg{beadarray}."
msgstr ""

#
#. type: Plain text
#: R-data.texi:1838
msgid "Raster files are common in the geographical sciences, and package @CRANpkg{rgdal} provides an interface to GDAL which provides some facilities of its own to read raster files and links to many others.  Which formats it supports is determined when GDAL is compiled: use @code{gdalDrivers()} to see what these are for the build you are using.  It can be useful for uncommon formats such as JPEG 2000 (which is a different format from JPEG, and not currently supported in the OS X nor Windows binary versions of @CRANpkg{rgdal})."
msgstr ""

#
#. type: Plain text
#: R-data.texi:1847
msgid "@emph{Connections} are used in @R{} in the sense of Chambers (1998) and Ripley (2001), a set of functions to replace the use of file names by a flexible interface to file-like objects."
msgstr "@R{} 에서 사용되는 @emph{Connections} 는 Chambers(1998)가 고안한 것으로, 파일과 같은 것들에 대한 유연한 interface 에 의해서 파일이름의 사용을 바꾸는 함수(function)들의 집합입니다."

#
#. type: node
#: R-data.texi:1855
#: R-data.texi:1858
#: R-data.texi:1859
#: R-data.texi:1948
#, no-wrap
msgid "Types of connections"
msgstr ""

#
#. type: node
#: R-data.texi:1855
#: R-data.texi:1858
#: R-data.texi:1948
#: R-data.texi:1949
#: R-data.texi:2003
#, no-wrap
msgid "Output to connections"
msgstr ""

#
#. type: node
#: R-data.texi:1855
#: R-data.texi:1948
#: R-data.texi:2003
#: R-data.texi:2004
#: R-data.texi:2046
#: R-data.texi:2083
#, no-wrap
msgid "Input from connections"
msgstr ""

#
#. type: node
#: R-data.texi:1855
#: R-data.texi:2003
#: R-data.texi:2083
#: R-data.texi:2084
#: R-data.texi:2108
#, no-wrap
msgid "Listing and manipulating connections"
msgstr ""

#
#. type: node
#: R-data.texi:1855
#: R-data.texi:2083
#: R-data.texi:2108
#: R-data.texi:2109
#: R-data.texi:2175
#, no-wrap
msgid "Binary connections"
msgstr ""

#
#. type: findex
#: R-data.texi:1862
#, no-wrap
msgid "file"
msgstr ""

#
#. type: cindex
#: R-data.texi:1863
#, no-wrap
msgid "File connections"
msgstr ""

#
#. type: Plain text
#: R-data.texi:1870
msgid "The most familiar type of connection will be a file, and file connections are created by function @code{file}.  File connections can (if the OS will allow it for the particular file) be opened for reading or writing or appending, in text or binary mode.  In fact, files can be opened for both reading and writing, and @R{} keeps a separate file position for reading and writing."
msgstr "가장 익숙한 유형의 connection 은 파일일 것입니다. 파일 connection 은 @code{file} 이라는 함수(function)에 의해 생성됩니다. 이러한 file connection 은 사용자의 OS 가 특정 파일의 사용을 지원한다면 text mode 나 binary mode 모두에서 읽기, 쓰기 또는 붙이기를 하는데 사용할 수 있습니다. 실제로 파일들은 읽기와 쓰기 둘 모두를 위해서 사용될 수 있으며, @R{} 은 읽기와 쓰기를 위해 따로 분리된 파일 위치(file position)를 유지합니다."

#
#. type: findex
#: R-data.texi:1871
#, no-wrap
msgid "open"
msgstr ""

#
#. type: Plain text
#: R-data.texi:1879
msgid "Note that by default a connection is not opened when it is created.  The rule is that a function using a connection should open a connection (needed) if the connection is not already open, and close a connection after use if it opened it.  In brief, leave the connection in the state you found it in.  There are generic functions @code{open} and @code{close} with methods to explicitly open and close connections."
msgstr "주의할 점은 default 에서 connection 은 그것이 생성될 때 열리지 않는다는 것입니다. connection 이 사전에 열려있지 않으면 그 connection 을 사용하는 어떤 함수(function)는 그 connection 을 열어야만 하고, 그리고 만약 어떤 함수(function)가 connection 을 열어놓은 상태이면 그 함수(function)의 사용 후에 그 connection 을 닫아야만 하는 것입니다. 간단히 말하면, 당신이 만들어 놓은 상태 그대로 connection 을 유지하십시오. 일반적으로 connection 을 분명하게 열거나 닫는 방법으로 @code{open} 과 @code{close} 라는 함수(function)를 사용할 수 있습니다."

#
#. type: findex
#: R-data.texi:1880
#, no-wrap
msgid "gzfile"
msgstr ""

#
#. type: findex
#: R-data.texi:1881
#, no-wrap
msgid "bzfile"
msgstr ""

#
#. type: cindex
#: R-data.texi:1882
#, no-wrap
msgid "Compressed files"
msgstr ""

#
#. type: Plain text
#: R-data.texi:1886
msgid "Files compressed via the algorithm used by @code{gzip} can be used as connections created by the function @code{gzfile}, whereas files compressed by @code{bzip2} can be used via @code{bzfile}."
msgstr "@code{gzip} 알고리즘을 통해 압축된 파일은 @code{gzfile} 함수(function)에 의해 생성된 connection 으로 사용될 수 있고, @code{bzip2} 알고리즘으로 압축된 파일은 @code{bzfile} 을 통해 사용될 수 있습니다."

#
#. type: cindex
#: R-data.texi:1887
#, no-wrap
msgid "Terminal connections"
msgstr ""

#
#. type: findex
#: R-data.texi:1888
#, no-wrap
msgid "stdin"
msgstr ""

#
#. type: findex
#: R-data.texi:1889
#, no-wrap
msgid "stdout"
msgstr ""

#
#. type: findex
#: R-data.texi:1890
#, no-wrap
msgid "stderr"
msgstr ""

#
#. type: Plain text
#: R-data.texi:1897
msgid "Unix programmers are used to dealing with special files @code{stdin}, @code{stdout} and @code{stderr}.  These exist as @emph{terminal connections} in @R{}.  They may be normal files, but they might also refer to input from and output to a GUI console.  (Even with the standard Unix @R{} interface, @code{stdin} refers to the lines submitted from @code{readline} rather than a file.)"
msgstr "Unix 프로그래머들은 종종 @code{stdin}, @code{stdout} 그리고 @code{stderr} 과 같은 특별한 파일들을 다루기도 합니다. 이러한 파일들은 @R{} 에서 @emph{terminal connections} 로 존재합니다. 이것들은 일반적인 파일들 이겠지만, GUI console 에서 입 • 출력하는 데 사용될 수도 있습니다(the standard @R{} interface 에 의해서도 @code{stdin} 은 특정 파일이라기 보다는 @code{readline} 에 의해 line 을 삽입하는데 사용됩니다)."

#
#. type: Plain text
#: R-data.texi:1906
msgid "The three terminal connections are always open, and cannot be opened or closed.  @code{stdout} and @code{stderr} are conventionally used for normal output and error messages respectively.  They may normally go to the same place, but whereas normal output can be re-directed by a call to @code{sink}, error output is sent to @code{stderr} unless re-directed by @code{sink, type=\"message\")}.  Note carefully the language used here: the connections cannot be re-directed, but output can be sent to other connections."
msgstr "세 개의 terminal connection 은 항상 열려있으며, 따로 열거나 닫을 수 없습니다. @code{stdout} 와 @code{stderr} 은 각각 전통적으로 일반적인 출력결과 및 에러 메시지에 각각 사용되어 왔습니다. 이것들은 일반적으로 같은 장소에 저장되지만, 일반적인 출력결과는 @code{sink} 를 이용하여 다른 디렉터리에 저장할 수 있습니다. 에러 메시지도 @code{sink, type=”message”}의 방법으로 다른 디렉터리를 지정하지 않는 한 stderr 에 저장됩니다. 여기서 사용된 말의 의미에 주의하십시오. connection 은 디렉터리를 다른 곳으로 지정할 수 없지만, 출력결과는 다른 connection 에 저장될 수 있습니다."

#
#. type: cindex
#: R-data.texi:1907
#, no-wrap
msgid "Text connections"
msgstr ""

#
#. type: findex
#: R-data.texi:1908
#, no-wrap
msgid "textConnection"
msgstr ""

#
#. type: Plain text
#: R-data.texi:1914
msgid "@emph{Text connections} are another source of input.  They allow @R{} character vectors to be read as if the lines were being read from a text file.  A text connection is created and opened by a call to @code{textConnection}, which copies the current contents of the character vector to an internal buffer at the time of creation."
msgstr "@emph{text connections} 은 입력을 할 수 있는 또 다른 방법으로 사용됩니다. @code{text connection} 들은 마치 text 파일에서 line 들이 읽히는 것처럼 @R{} 문자 벡터가 읽히도록 해 줍니다. text connection 은 textConnection 을 호출(call)해서 생성되고 열립니다. 그리고 @code{text connection} 은 생성과 동시에 문자 벡터의 현재 내용을 내부버퍼(internal buffer)에 복사합니다.text connection 은 @R{} 의 출력결과를 문자  벡터로 인식하는 데에도 사용될 수 있습니다."

#
#. type: Plain text
#: R-data.texi:1922
msgid "Text connections can also be used to capture @R{} output to a character vector.  @code{textConnection} can be asked to create a new character object or append to an existing one, in both cases in the user's workspace.  The connection is opened by the call to @code{textConnection}, and at all times the complete lines output to the connection are available in the @R{} object.  Closing the connection writes any remaining output to a final element of the character vector."
msgstr "@code{textConnection} 은 사용자의 작업공간(user‟s workspace)에서 새로운 문자 object 를 생성하거나 현재 존재하고 있는 것에 추가하는 두 가지 경우 모두에 사용될 수 있습니다. 이 connection 은 @code{textConnection} 의 호출(call)에 의하여 열리고, connection 에 있는 완전한 행 출력결과(complete lines output)는 항상 @R{} object 에서 사용가능 합니다. 이 connection 을 닫는 것은 남아있는 어떤 출력결과를 문자벡터의 마지막 요소로 기록합니다"

#
#. type: cindex
#: R-data.texi:1923
#, no-wrap
msgid "Pipe connections"
msgstr ""

#
#. type: findex
#: R-data.texi:1924
#, no-wrap
msgid "pipe"
msgstr ""

#
#. type: Plain text
#: R-data.texi:1932
msgid "@emph{Pipes} are a special form of file that connects to another process, and pipe connections are created by the function @code{pipe}.  Opening a pipe connection for writing (it makes no sense to append to a pipe) runs an OS command, and connects its standard input to whatever @R{} then writes to that connection.  Conversely, opening a pipe connection for input runs an OS command and makes its standard output available for @R{} input from that connection."
msgstr "@emph{Pipes} 는 다른 과정(another process)과 연결시켜주는 특별한 형태의 파일 중의 하나이며, pipe connection 은 @code{pipe} 함수에 의해 생성됩니다. 쓰기(writing)를 위한 pipe connection 의 개시(opening)는 어떤 OS 명령을 실행(pipe 에 추가하는 것은 아닙니다)하고, 그것의 표준적 입력을 모든 @R{} 이라도 그 connection 에 쓰는 것과 연결시켜 줍니다. 반대로 말하면, 입력을 위한 pipe connection 의 개시는 어떤 OS 명령을 실행하고 그것의 표준 출력결과를 그 connection 으로부터 @R{} 의 입력으로 사용할 수 있게 합니다"

#
#. type: cindex
#: R-data.texi:1933
#: R-data.texi:2037
#, no-wrap
msgid "URL connections"
msgstr ""

#
#. type: findex
#: R-data.texi:1934
#, no-wrap
msgid "url"
msgstr ""

#. type: Plain text
#: R-data.texi:1939
msgid "@acronym{URL}s of types @samp{http://}, @samp{ftp://} and @samp{file://} can be read from using the function @code{url}.  For convenience, @code{file} will also accept these as the file specification and call @code{url}.  On most platforms @samp{https://} are also accepted."
msgstr ""

#
#. type: cindex
#: R-data.texi:1940
#: R-data.texi:2220
#, no-wrap
msgid "Sockets"
msgstr ""

#
#. type: findex
#: R-data.texi:1941
#, no-wrap
msgid "socketConnection"
msgstr ""

#
#. type: Plain text
#: R-data.texi:1946
msgid "Sockets can also be used as connections via function @code{socketConnection} on platforms which support Berkeley-like sockets (most Unix systems, Linux and Windows).  Sockets can be written to or read from, and both client and server sockets can be used."
msgstr "Socket 은 Berkeley 와 같은 socket 을 지원하는 platform(대부분 Unix, Linux 그리고 Windows)에서 @code{socketConnection} 함수를 통해 connection 들처럼 사용될 수 있습니다. Socket 은 client 와 server socket 들이 사용될 수 있으며 이들 client 와 server socket 에 쓰거나 이들로부터 읽어 들일 수 있습니다."

#
#. type: Plain text
#: R-data.texi:1960
msgid "We have described functions @code{cat}, @code{write}, @code{write.table} and @code{sink} as writing to a file, possibly appending to a file if argument @code{append = TRUE}, and this is what they did prior to @R{} version 1.2.0."
msgstr "지금까지 파일에 쓰기(writing)의 방법으로 함수 @code{cat}, @code{write}, @code{write.table} 그리고 @code{sink}, 파일에 붙여넣기(appending)의 방법으로 인수(argument) @code{append=TRUE} 에 대하여 설명하였습니다. 이것은 @R{} 1.2.0 이전 버전에서 작동합니다."

#
#. type: Plain text
#: R-data.texi:1970
msgid "The current behaviour is equivalent, but what actually happens is that when the @code{file} argument is a character string, a file connection is opened (for writing or appending) and closed again at the end of the function call.  If we want to repeatedly write to the same file, it is more efficient to explicitly declare and open the connection, and pass the connection object to each call to an output function.  This also makes it possible to write to pipes, which was implemented earlier in a limited way via the syntax @code{file = \"|cmd\"} (which can still be used)."
msgstr "현재의 방법도 동일하지만, 실제로 일어나는 것은 @code{file} 인수(argument)가 문자열(a character string)일 때, 파일 connection 이 열리고 함수의 호출이 끝날 때 다시 닫힙니다. 만약 우리가 반복적으로 같은 파일을 쓰고 싶다면, 그 connection 을 명백히 선언(declare)하여 열고 각 output 함수를 호출하는 connection object 를 건너뛰는 방법이 효율적입니다. 이것은 또 pipe 에 쓰는 것을 가능하게 합니다. 지금도 여전히 가능하지만 이것은 전에는 syntax @code{file=\"| cmd\"}를 이용한 제한된 방법으로만 사용할 수 있었습니다."

#
#. type: findex
#: R-data.texi:1971
#, no-wrap
msgid "writeLines"
msgstr ""

#
#. type: Plain text
#: R-data.texi:1974
msgid "There is a function @code{writeLines} to write complete text lines to a connection."
msgstr "어떤 connection 에 완전한 텍스트 line 을 쓰는 @code{writeLines} 라는 함수가 있습니다. "

#
#. type: Plain text
#: R-data.texi:1976
#: R-data.texi:2019
msgid "Some simple examples are"
msgstr "간단한 예는 아래와 같습니다"

#
#. type: example
#: R-data.texi:1983
#, no-wrap
msgid ""
"zz <- file(\"ex.data\", \"w\")  # open an output file connection\n"
"cat(\"TITLE extra line\", \"2 3 5 7\", \"\", \"11 13 17\", \n"
"    file = zz, sep = \"\\n\")\n"
"cat(\"One more line\\n\", file = zz)\n"
"close(zz)\n"
"\n"
msgstr ""

#
#. type: example
#: R-data.texi:1991
#, no-wrap
msgid ""
"## convert decimal point to comma in output, using a pipe (Unix)\n"
"## both R strings and (probably) the shell need \\ doubled\n"
"zz <- pipe(paste(\"sed s/\\\\\\\\./,/ >\", \"outfile\"), \"w\")\n"
"cat(format(round(rnorm(100), 4)), sep = \"\\n\", file = zz)\n"
"close(zz)\n"
"## now look at the output file:\n"
"file.show(\"outfile\", delete.file = TRUE)\n"
"\n"
msgstr ""

#
#. type: example
#: R-data.texi:2001
#, no-wrap
msgid ""
"## capture R output: use examples from help(lm)\n"
"zz <- textConnection(\"ex.lm.out\", \"w\")\n"
"sink(zz)\n"
"example(lm, prompt.echo = \"> \")\n"
"sink()\n"
"close(zz)\n"
"## now `ex.lm.out' contains the output for futher processing.\n"
"## Look at it by, e.g.,\n"
"cat(ex.lm.out, sep = \"\\n\")\n"
msgstr ""

#
#. type: Plain text
#: R-data.texi:2014
msgid "The basic functions to read from connections are @code{scan} and @code{readLines}.  These take a character string argument and open a file connection for the duration of the function call, but explicitly opening a file connection allows a file to be read sequentially in different formats."
msgstr "connection 으로부터 읽는 기본적 함수는 @code{scan} 과 @code{readLines} 입니다. 이것들은 문자열(character string) 인수(argument)를 취하고 함수의 지속을 위해 파일 connection 을 엽니다. 그러나 분명한 파일 connection 의 열기(opening)는 다른 format 에서 연속적으로 파일 읽기를 가능하게 해줍니다."

#
#. type: Plain text
#: R-data.texi:2017
msgid "Other functions that call @code{scan} can also make use of connections, in particular @code{read.table}."
msgstr "@code{scan} 을 호출하는 다른 함수들 또한 connection 을 사용할 수 있습니다. 특히 @code{read.table} 이 그렇습니다."

#
#. type: example
#: R-data.texi:2024
#, no-wrap
msgid ""
"## read in file created in last examples\n"
"readLines(\"ex.data\")\n"
"unlink(\"ex.data\")\n"
"\n"
msgstr ""

#
#. type: example
#: R-data.texi:2027
#, no-wrap
msgid ""
"## read listing of current directory (Unix)\n"
"readLines(pipe(\"ls -1\"))\n"
"\n"
msgstr ""

#
#. type: example
#: R-data.texi:2035
#, no-wrap
msgid ""
"# remove trailing commas from an input file.\n"
"# Suppose we are given a file `data' containing\n"
"450, 390, 467, 654,  30, 542, 334, 432, 421,\n"
"357, 497, 493, 550, 549, 467, 575, 578, 342,\n"
"446, 547, 534, 495, 979, 479\n"
"# Then read this by\n"
"scan(pipe(\"sed -e s/,$// data\"), sep=\",\")\n"
msgstr ""

#
#. type: Plain text
#: R-data.texi:2041
msgid "For convenience, if the @code{file} argument specifies a FTP or HTTP @acronym{URL}, the @acronym{URL} is opened for reading via @code{url}.  Specifying files via @samp{file://foo.bar} is also allowed."
msgstr "편의를 위해, 만약 @code{file} 인수(argument)가 어떤 FTP 나 HTTP @acronym{URL} 을 특정한다면, 그 @acronym{URL} 은 읽기(reading)를 위해 @code{url} 을 통해 열립니다. @samp{file://foo.bar}를 통해 파일을 특정하는 것도 허용됩니다."

#
#. type: subsection
#: R-data.texi:2044
#: R-data.texi:2046
#: R-data.texi:2047
#, no-wrap
msgid "Pushback"
msgstr ""

#
#. type: findex
#: R-data.texi:2049
#, no-wrap
msgid "pushBack."
msgstr ""

#
#. type: cindex
#: R-data.texi:2050
#, no-wrap
msgid "Pushback on a connection"
msgstr ""

#
#. type: Plain text
#: R-data.texi:2056
msgid "C programmers may be familiar with the @code{ungetc} function to push back a character onto a text input stream.  @R{} connections have the same idea in a more powerful way, in that an (essentially) arbitrary number of lines of text can be pushed back onto a connection via a call to @code{pushBack}."
msgstr "C 프로그래머들은 텍스트 입력 stream 에 어떤 문자를 뒤로 밀리게 하는 @code{ungetc} 에 익숙할 것입니다. @R{} connection 은 더 강력한 방법으로 같은 작업을 할 수 있는데, @code{pushBack} 의 호출을 통하여 connection 에 임의의 수만큼 텍스트 line 을 뒤로 밀리게 할 수 있습니다."

#
#. type: Plain text
#: R-data.texi:2063
msgid "Pushbacks operate as a stack, so a read request first uses each line from the most recently pushbacked text, then those from earlier pushbacks and finally reads from the connection itself.  Once a pushbacked line is read completely, it is cleared.  The number of pending lines pushed back can be found via a call to @code{pushBackLength}."
msgstr "Pushback 은 stack 처럼 동작해서, 첫 번째 읽기 요구는 가장 최근에 pushback 된 text 에서 각 line 을 이용하고, 그 다음엔 이전의 pushback 된 text, 마지막으로 connection 자체로부터 읽어 들입니다. 한 번 pushback 된 line 은 완벽히 읽어나서 지워집니다. push back 되고 있는 line 의 수는 @code{pushBackLength} 을 호출하여 알 수 있습니다. 간단한 예는 아래와 같습니다."

#
#. type: findex
#: R-data.texi:2063
#, no-wrap
msgid "pushBackLength"
msgstr ""

#
#. type: Plain text
#: R-data.texi:2066
msgid "A simple example will show the idea."
msgstr ""

#
#. type: example
#: R-data.texi:2079
#, no-wrap
msgid ""
"> zz <- textConnection(LETTERS)\n"
"> readLines(zz, 2)\n"
"[1] \"A\" \"B\"\n"
"> scan(zz, \"\", 4)\n"
"Read 4 items\n"
"[1] \"C\" \"D\" \"E\" \"F\"\n"
"> pushBack(c(\"aa\", \"bb\"), zz)\n"
"> scan(zz, \"\", 4)\n"
"Read 4 items\n"
"[1] \"aa\" \"bb\" \"G\"  \"H\" \n"
"> close(zz)\n"
msgstr ""

#
#. type: Plain text
#: R-data.texi:2082
msgid "Pushback is only available for connections opened for input in text mode."
msgstr "Pushback 은 텍스트 모드에서 입력 할 때 connection 이 열려있을 경우에만 사용가능 합니다."

#
#. type: findex
#: R-data.texi:2087
#, no-wrap
msgid "showConnections"
msgstr ""

#
#. type: Plain text
#: R-data.texi:2092
msgid "A summary of all the connections currently opened by the user can be found by @code{showConnections()}, and a summary of all connections, including closed and terminal connections, by @code{showConnections(all = TRUE)}"
msgstr "User 에 의해 현재 열려있는 모든 connection 의 개요는 @code{showConnections( )}로 알아낼 수 있고, 닫혀 있는 connection 과 terminal connection 등을 포함한 모든 connection 의 개요는 @code{showConnections(all=TRUE)}로 알 수 있습니다."

#
#. type: findex
#: R-data.texi:2093
#, no-wrap
msgid "seek"
msgstr ""

#
#. type: findex
#: R-data.texi:2094
#, no-wrap
msgid "isSeekable"
msgstr ""

#
#. type: Plain text
#: R-data.texi:2101
msgid "The generic function @code{seek} can be used to read and (on some connections) reset the current position for reading or writing.  Unfortunately it depends on OS facilities which may be unreliable (e.g. with text files under Windows).  Function @code{isSeekable} reports if @code{seek} can change the position on the connection given by its argument."
msgstr "일반적 함수인 @code{seek} 은 읽기에 사용될 수 있으며 (어떤 connection 에서는) 읽기 또는 쓰기와 같은 현재의 position 을 reset 할 수 있습니다. 그런데 이것은 불행하게도 신뢰하기 어려울 수 있는 OS facility 에 따라 달라집니다(예를 들어, Windows 환경에서의 text 파일). 함수 @code{isSeekable} 은 함수 @code{seek} 이 position 바꿀 수 있는 지를 보고해 줍니다."

#
#. type: findex
#: R-data.texi:2102
#, no-wrap
msgid "truncate"
msgstr ""

#
#. type: Plain text
#: R-data.texi:2106
msgid "The function @code{truncate} can be used to truncate a file opened for writing at its current position.  It works only for @code{file} connections, and is not implemented on all platforms."
msgstr "함수 @code{truncate} 는 현재의 position 에서 읽기나 쓰기를 위해 열려있는 파일을 truncate 하는데 사용될 수 있습니다. 이것은 오로지 @code{file} connection 에 대해서만 작동하고, 역시 모든 platform 에서 적용되지는 않습니다."

#
#. type: findex
#: R-data.texi:2112
#, no-wrap
msgid "readBin"
msgstr ""

#
#. type: findex
#: R-data.texi:2113
#, no-wrap
msgid "writeBin"
msgstr ""

#
#. type: Plain text
#: R-data.texi:2119
msgid "Functions @code{readBin} and @code{writeBin} read to and write from binary connections.  A connection is opened in binary mode by appending @code{\"b\"} to the mode specification, that is using mode @code{\"rb\"} for reading, and mode @code{\"wb\"} or @code{\"ab\"} (where appropriate) for writing.  The functions have arguments"
msgstr "@code{readBin} 과 @code{writeBin} 은 binary connection 에서 읽거나 쓰는데 사용됩니다. binary 모드에서 @code{“b”}를 모드 specification 에 덧붙임으로써 connection 이 열립니다. 즉 모드 @code{“rb”}는 읽기에 그리고 모드 @code{“wb”} 또는 @code{“ab”}는 쓰기에 사용합니다. 이 함수들은 다음과 같은 인수(argument)를 가집니다."

#
#. type: example
#: R-data.texi:2123
#, no-wrap
msgid ""
"readBin(con, what, n = 1, size = NA, endian = .Platform$endian) \n"
"writeBin(object, con, size = NA, endian = .Platform$endian) \n"
msgstr ""

#
#. type: Plain text
#: R-data.texi:2128
msgid "In each case @code{con} is a connection which will be opened if necessary for the duration of the call, and if a character string is given it is assumed to specify a file name."
msgstr "각각의 경우에 @code{con} 은 호출이 유지되는데 필요한 경우 열려 있으며 문자열이 주어지면, 파일명을 지정하는 것으로 가정됩니다."

#
#. type: Plain text
#: R-data.texi:2135
msgid "It is slightly simpler to describe writing, so we will do that first.  @code{object} should be an atomic vector object, that is a vector of mode @code{numeric}, @code{integer}, @code{logical}, @code{character}, @code{complex} or @code{raw}, without attributes.  By default this is written to the file as a stream of bytes exactly as it is represented in memory."
msgstr "쓰기(writing)를 묘사하는 것은 조금 더 단순하여서 우리는 먼저 그것을 설명할 것입니다. @code{object} 는 atomic vector object 로 attributes 가 없는 @code{numeric}, @code{integer}, @code{logical}, @code{character}, @code{complex} 또는 @code{raw} 와 같은 mode 의 vector 입니다. 디폴트 상태에서 이것은 memory 에 나타나는 것과 똑같이 바이트의 흐름처럼 파일에 쓰여집니다."

#
#. type: Plain text
#: R-data.texi:2145
msgid "@code{readBin} reads a stream of bytes from the file and interprets them as a vector of mode given by @code{what}.  This can be either an object of the appropriate mode (e.g. @code{what=integer()}) or a character string describing the mode (one of the five given in the previous paragraph or @code{\"double\"} or @code{\"int\"}).  Argument @code{n} specifies the maximum number of vector elements to read from the connection: if fewer are available a shorter vector will be returned.  Argument @code{signed} allows 1-byte and 2-byte integers to be read as signed (the default) or unsigned integers."
msgstr "@code{readBin} 은 파일로부터 바이트의 흐름을 읽고 그것을 @code{what} 으로 주어진 mode 의 vector 처럼 해석합니다. 이것은 적절한 mode 의 object(예를 들어, @code{what=integer( ))}나 또는 그 mode 를 묘사하는 문자열(character string)이 될 수 있습니다(앞의 문단에서 말한 다섯 가지 중 하나 또는 @code{“double”} 또는 @code{“int”}). 인수(argument) @code{n} 은 connection 으로 부터 읽기 위기 위한 벡터 요소의 최대 수를 지정합니다. 즉, 보다 적은 수가 가능하면 더 짧은 벡터가 만들어 집니다. 인수(argument) @code{signed} 는 1 바이트와 2 바이트의 정수가 default 인 기호화된 정수 또는 기호화되지 않은 정수처럼 읽혀지게 합니다."

#
#. type: Plain text
#: R-data.texi:2163
msgid "The remaining two arguments are used to write or read data for interchange with another program or another platform.  By default binary data is transferred directly from memory to the connection or @emph{vice versa}.  This will not suffice if the data are to be transferred to a machine with a different architecture, but between almost all @R{} platforms the only change needed is that of byte-order.  Common PCs (@cputype{ix86}-based and @cputype{x86_64}-based machines), Compaq Alpha and Vaxen are @emph{little-endian}, whereas Sun Sparc, mc680x0 series, IBM R6000, SGI and most others are @emph{big-endian}.  (Network byte-order (as used by XDR, eXternal Data Representation) is big-endian.)  To transfer to or from other programs we may need to do more, for example to read 16-bit integers or write single-precision real numbers.  This can be done using the @code{size} argument, which (usually) allows sizes 1, 2, 4, 8 for integers and logicals, and sizes 4, 8 and perhaps 12 or 16 for reals.  Transferring at different sizes can lose precision, and should not be attempted for vectors containing @code{NA}'s."
msgstr "남아있는 두 인수(argument)는 데이터를 다른 프로그램이나 다른 플랫폼으로 대체시켜 쓰거나 읽는데 사용됩니다. 디폴트 상태의 바이너리 데이터(binary data)는 직접 메모리에서 connection 으로 또는 그 반대로 옮겨 집니다. 이것은 특정 파일이 다른 구조로 특정 장치(machine)로 옮겨져야 한다면 충분치 않을 것이나 거의 모든 R 플랫폼들 사이에서는 단지 바이트 순서(byte-order)만 변화시켜주면 됩니다. 일반적인 PC(@cputype{ix86}과 @cputype{x86_64} 기반)들과 Compaq Alpha 그리고 Vaxen 은 @emph{little-endian} 구조인데 반해, Sun Sparc, mc680x0 시리즈, IBM R6000, Apple Macintosh, SGI 등의 다른 대부분의 장치들은 @emph{big-endian} 구조 입니다(네트워크 바이트 순서(network byte-order)는 XDR(eXternal Data Representation)에서 사용되는 것과 같이 big- endian 입니다.) 예를 들어 16 비트로 된 정수나 단정밀도(single-precision; 단정도 또는 단밀도) 실수를 쓰는 경우와 같이 다른 프로그램으로 전송하거나 받아오기 위해서 우리는 조금 더 작업을 할 필요가 있을 지도 모릅니다. 이것은 @code{size} 인수(argument)를 이용함으로써 해결할 수 있는데, size 인수(argument)는 정수와 논리자(logical)의 크기를 1, 2, 4, 8 또는 4, 8 그리고 또는 실수를 12 나 16 으로 정할 수 있게 합니다. 다른 크기로 전환하는 것은 정확성을 잃을 수 있으므로 @code{결측값(NA: not available)}들을 포함하고 있는 벡터에 대해서는 사용하지 말아야 합니다."

#
#. type: findex
#: R-data.texi:2164
#, no-wrap
msgid "readChar"
msgstr ""

#
#. type: findex
#: R-data.texi:2165
#, no-wrap
msgid "writeChar"
msgstr ""

#
#. type: Plain text
#: R-data.texi:2169
msgid "Character strings are read and written in C format, that is as a string of bytes terminated by a zero byte.  Functions @code{readChar} and @code{writeChar} provide greater flexibility."
msgstr "문자열은 C 포맷에서 읽히거나 쓰여집니다. 그것은 바이트 열(string of bytes)처럼 영(0) 바이트에 의해 종료됩니다. 함수 @code{readChar} 와 @code{writeChar} 는 보다 더 유연하게 사용할 수 있습니다"

#
#. type: subsection
#: R-data.texi:2173
#: R-data.texi:2175
#: R-data.texi:2176
#, no-wrap
msgid "Special values"
msgstr ""

#
#. type: Plain text
#: R-data.texi:2181
msgid "Functions @code{readBin} and @code{writeBin} will pass missing and special values, although this should not be attempted if a size change is involved."
msgstr "크기 변화가 관련되어 있다면 시도되지 말아야 하더라도 함수 @code{readBin} 과 @code{writeBin} 은 결측값(missing values)과 특이값(special values)을 처리해 줍니다. "

#
#. type: Plain text
#: R-data.texi:2186
msgid "The missing value for @R{} logical and integer types is @code{INT_MIN}, the smallest representable @code{int} defined in the C header @file{limits.h}, normally corresponding to the bit pattern @code{0x80000000}."
msgstr "R 에서 논리 유형(logical type)과 정수 유형(integer type)의 경우 결측값(missing values)은 '@file{limits.h}'로 C 의 헤더로 정의된 나타낼 수 있는 가장 작은 @code{int} 인 @code{INT_MIN} 인데 이것은 보통 비트 패턴(the bit pattern) @code{0x80000000} 에 대응하는 것 입니다."

#
#. type: Plain text
#: R-data.texi:2194
msgid "The representation of the special values for @R{} numeric and complex types is machine-dependent, and possibly also compiler-dependent.  The simplest way to make use of them is to link an external application against the standalone @code{Rmath} library which exports double constants @code{NA_REAL}, @code{R_PosInf} and @code{R_NegInf}, and include the header @file{Rmath.h} which defines the macros @code{ISNAN} and @code{R_FINITE}."
msgstr "@R{} 에서 숫자와 복합적인 형태의 특이값(special values)의 표현은 사용하는 컴퓨터(machine)나 컴파일러(Compiler: BASIC, COBOL, PASCAL 등의 프로그래밍 언어를 기계어로 번역하는 로그램)에 따라 달라집니다(The representation of the special values for R numeric and complex types is machine-dependent, and possibly also compiler-dependent.) 그것들을 이용하는 가장 단순한 방법은 이중상수(double constants)인 @code{NA_REAL}, @code{R_PosInf} 그리고 @code{R_NegInf} 를 내보내고 ISNAN 과 @code{R_FINITE} 과 같은 매크로를 정의하는 '@file{Rmath.h}' 헤더를 포함하는 독립적인 @code{Rmath} 라이브러리 외부의 어플리케이션(application; 응용프로그램?)(an external application)과 연결시키는 것 입니다."

#
#. type: Plain text
#: R-data.texi:2200
msgid "If that is not possible, on all current platforms IEC 60559 (aka IEEE 754) arithmetic is used, so standard C facilities can be used to test for or set @code{Inf}, @code{-Inf} and @code{NaN} values.  On such platforms @code{NA} is represented by the @code{NaN} value with low-word @code{0x7a2} (1954 in decimal)."
msgstr "만약 이와 같은 작업이 불가능하면 산술(arithmetic)이 사용되는 모든 보통의 IEC 60559 (aka IEEE 754) 플랫폼에서, @code{Inf}, @code{-Inf} 그리고 @code{NaN} 값들을 테스트하거나 설정하는데 표준적인 C 도구(facility)를 사용할 수 있습니다. 그러한 플랫폼에서 @code{NA} 는 low-word @code{0x7a2}(1954 in decimal)에따라 @code{NaN} 값으로 표시됩니다."

#
#. type: Plain text
#: R-data.texi:2204
msgid "Character missing values are written as @code{NA}, and there are no provision to recognize character values as missing (as this can be done by re-assigning them once read)."
msgstr "문자결측값들은 @code{NA} 처럼 사용되며, 결측값으로 문자 값을 인식할 수 있는 규칙(provision)은 없습니다(이것은 마치 한 번 읽고 다시 그것들을 재할당함으로써 완성되는 것과 같습니다)."

#
#. type: node
#: R-data.texi:2212
#: R-data.texi:2217
#: R-data.texi:2218
#: R-data.texi:2237
#, no-wrap
msgid "Reading from sockets"
msgstr ""

#
#. type: node
#: R-data.texi:2212
#: R-data.texi:2217
#: R-data.texi:2237
#, no-wrap
msgid "Using download.file"
msgstr ""

#
#. type: Plain text
#: R-data.texi:2216
msgid "Some limited facilities are available to exchange data at a lower level across network connections."
msgstr "몇 가지 제한된 도구들이 network connection 을 통해 낮은 수준의 데이터를 교환하는데 사용될 수 있습니다."

#
#. type: Plain text
#: R-data.texi:2228
msgid "Base @R{} comes with some facilities to communicate @emph{via} @acronym{BSD} sockets on systems that support them (including the common Linux, Unix and Windows ports of @R{}).  One potential problem with using sockets is that these facilities are often blocked for security reasons or to force the use of Web caches, so these functions may be more useful on an intranet than externally.  For new projects it is suggested that socket connections are used instead."
msgstr "기본적인 @R{} 프로그램은 그것들을 지원(보통의 Linux, Unix, 그리고 @R{} 의 Windows 포트(port)를 포함)하는 시스템에서 @acronym{BSD} 소켓(sockets)을 통한 커뮤니케이션을 위한 몇 가지 장치(facility)에 연결되어 있습니다. 이러한 소켓들(sockets)을 사용하면서 잠재적으로 발생할 수 있는 문제점 하나는 이러한 장치들이 종종 보안상의 문제로 차단되거나 Web caches 의 사용이 강요된다는 것입니다. 그래서 이러한 함수들은 외면상(externally) 보다는 인터넷에서 더욱 유용할 수 있습니다."

#
#. type: findex
#: R-data.texi:2229
#, no-wrap
msgid "make.socket"
msgstr ""

#
#. type: findex
#: R-data.texi:2230
#, no-wrap
msgid "read.socket"
msgstr ""

#
#. type: findex
#: R-data.texi:2231
#, no-wrap
msgid "write.socket"
msgstr ""

#
#. type: findex
#: R-data.texi:2232
#, no-wrap
msgid "close.socket"
msgstr ""

#
#. type: Plain text
#: R-data.texi:2235
msgid "The earlier low-level interface is given by functions @code{make.socket}, @code{read.socket}, @code{write.socket} and @code{close.socket}."
msgstr "초기 낮은 수준의 인터페이스(interface)는 함수 @code{make.socket}, @code{read.socket}, @code{write.socket}, and @code{close.socket} 으로 주어졌습니다."

#
#. type: section
#: R-data.texi:2238
#, no-wrap
msgid "Using @code{download.file}"
msgstr ""

#
#. type: Plain text
#: R-data.texi:2246
msgid "Function @code{download.file} is provided to read a file from a Web resource via FTP or HTTP and write it to a file.  Often this can be avoided, as functions such as @code{read.table} and @code{scan} can read directly from a URL, either by explicitly using @code{url} to open a connection, or implicitly using it by giving a URL as the @code{file} argument."
msgstr "함수 @code{download.file} 은 FTP 나 HTTP 를 통한 Web 기반 자원(resource)에서 파일을 읽거나 파일에 쓰기를 위해 제공됩니다. 종종 이것은 @code{read.table} 과 같은 함수들과 같이 피할 수 있고, @code{scan} 은 명백히 connection 을 열기 위해서 @code{url} 을 사용하거나 @code{file} 인수(argument)로서 URL 을 부여함으로써 특정 URL 로부터 직접 읽기를 할 수 있게 합니다."

#
#. type: Plain text
#: R-data.texi:2255
msgid "The most common R data import/export question seems to be `how do I read an Excel spreadsheet'.  This chapter collects together advice and options given earlier.  Note that most of the advice is for pre-Excel 2007 spreadsheets and not the later @file{.xlsx} format."
msgstr "가장 일반적인 R 데이터 불러오기/내보내기 질문은 „어떻게 엑셀에서 데이터를 가져오지?'하는 것입니다. 이 장은 도움마라과 앞서 설명한 옵션을 함께 모아둔 것입니다. 도움말의 대부분이 엑셀 2007 이전의 스프레드시트를 위한 것임에 유의하십시오. 현재 '@file{.xlsx}' 포맷의 파일을 읽는 유일한 방법은 RODBC 를 통하는 것입니다."

#
#. type: findex
#: R-data.texi:2260
#, no-wrap
msgid "readClipboard"
msgstr ""

#
#. type: Plain text
#: R-data.texi:2268
msgid "The first piece of advice is to avoid doing so if possible! If you have access to Excel, export the data you want from Excel in tab-delimited or comma-separated form, and use @code{read.delim} or @code{read.csv} to import it into R.  (You may need to use @code{read.delim2} or @code{read.csv2} in a locale that uses comma as the decimal point.)  Exporting a DIF file and reading it using @code{read.DIF} is another possibility."
msgstr ""

#. type: Plain text
#: R-data.texi:2278
msgid "If you do not have Excel, many other programs are able to read such spreadsheets and export in a text format on both Windows and Unix, for example Gnumeric (@uref{http://www.gnome.org/projects/gnumeric/}) and OpenOffice (@uref{https://www.openoffice.org}).  You can also cut-and-paste between the display of a spreadsheet in such a program and R: @code{read.table} will read from the R console or, under Windows, from the clipboard (via @code{file = \"clipboard\"} or @code{readClipboard}).  The @code{read.DIF} function can also read from the clipboard."
msgstr ""

#
#. type: Plain text
#: R-data.texi:2283
msgid "Note that an Excel @file{.xls} file is not just a spreadsheet: such files can contain many sheets, and the sheets can contain formulae, macros and so on.  Not all readers can read other than the first sheet, and may be confused by other contents of the file."
msgstr ""

#
#. type: findex
#: R-data.texi:2285
#, no-wrap
msgid "odbcConnectExcel2007"
msgstr ""

#
#. type: Plain text
#: R-data.texi:2295
msgid "Windows users (of 32-bit @R{}) can use @code{odbcConnectExcel} in package @CRANpkg{RODBC}.  This can select rows and columns from any of the sheets in an Excel spreadsheet file (at least from Excel 97--2003, depending on your ODBC drivers: by calling @code{odbcConnect} directly versions back to Excel 3.0 can be read).  The version @code{odbcConnectExcel2007} will read the Excel 2007 formats as well as earlier ones (provided the drivers are installed, including with 64-bit Windows @R{}: @pxref{RODBC}).  OS X users can also use @CRANpkg{RODBC} if they have a suitable driver (e.g.@: that from Actual Technologies)."
msgstr ""

#
#. type: findex
#: R-data.texi:2296
#, no-wrap
msgid "read.xls"
msgstr ""

#
#. type: Plain text
#: R-data.texi:2303
msgid "@code{Perl} users have contributed a module @code{OLE::SpreadSheet::ParseExcel} and a program @code{xls2csv.pl} to convert Excel 95--2003 spreadsheets to CSV files.  Package @CRANpkg{gdata} provides a basic wrapper in its @code{read.xls} function.  With suitable @code{Perl} modules installed this function can also read Excel 2007 spreadsheets."
msgstr ""

#
#. type: findex
#: R-data.texi:2304
#, no-wrap
msgid "xlsReadWrite"
msgstr ""

#
#. type: Plain text
#: R-data.texi:2309
msgid "32-bit Windows package @CRANpkg{xlsReadWrite} from @uref{http://www.swissr.org/} and CRAN has a function @code{read.xls} to read @file{.xls} files (based on a third-party non-Open-Source Delphi component)."
msgstr ""

#
#. type: findex
#: R-data.texi:2310
#, no-wrap
msgid "dataframes2xls"
msgstr ""

#
#. type: findex
#: R-data.texi:2311
#, no-wrap
msgid "WriteXLS"
msgstr ""

#
#. type: Plain text
#: R-data.texi:2316
msgid "Packages @CRANpkg{dataframes2xls} and @CRANpkg{WriteXLS} each contain a function to @emph{write} one or more data frames to an @file{.xls} file, using Python and Perl respectively.  Another version of @code{write.xls} in available in package @CRANpkg{xlsReadWrite}."
msgstr ""

#
#. type: findex
#: R-data.texi:2317
#, no-wrap
msgid "xlsx"
msgstr ""

#
#. type: findex
#: R-data.texi:2318
#, no-wrap
msgid "RExcelXML"
msgstr ""

#
#. type: Plain text
#: R-data.texi:2322
msgid "Two packages which can read and and manipulate Excel 2007/10 spreadsheets but not earlier formats are @CRANpkg{xlsx} (which requires Java) and the Omegahat package @pkg{RExcelXML}."
msgstr ""

#
#. type: findex
#: R-data.texi:2323
#, no-wrap
msgid "XLConnect"
msgstr ""

#
#. type: Plain text
#: R-data.texi:2326
msgid "Package @CRANpkg{XLConnect} can read, write and manipulate both Excel 97--2003 and Excel 2007/10 spreadsheets, requiring Java."
msgstr ""

#
#. type: Plain text
#: R-data.texi:2335
msgid "R.@: A.@: Becker, J.@: M.@: Chambers and A.@: R.@: Wilks (1988)  @emph{The New S Language.  A Programming Environment for Data Analysis and Graphics.} Wadsworth & Brooks/Cole."
msgstr ""

#
#. type: Plain text
#: R-data.texi:2340
msgid "J.@: Bowman, S.@: Emberson and M.@: Darnovsky (1996) @emph{The Practical @acronym{SQL} Handbook.  Using Structured Query Language.} Addison-Wesley."
msgstr ""

#
#. type: Plain text
#: R-data.texi:2344
msgid "J.@: M.@: Chambers (1998) @emph{Programming with Data.  A Guide to the S Language.} Springer-Verlag."
msgstr ""

#
#. type: Plain text
#: R-data.texi:2347
msgid "P.@: Dubois (2000) @emph{MySQL.} New Riders."
msgstr ""

#
#. type: Plain text
#: R-data.texi:2351
msgid "M.@: Henning and S.@: Vinoski (1999) @emph{Advanced CORBA Programming with C++.} Addison-Wesley."
msgstr ""

#
#. type: Plain text
#: R-data.texi:2354
msgid "K.@: Kline and D.@: Kline (2001) @emph{SQL in a Nutshell.} O'Reilly."
msgstr ""

#
#. type: Plain text
#: R-data.texi:2359
msgid "B.@: Momjian (2000) @emph{PostgreSQL: Introduction and Concepts.} Addison-Wesley.  Also available at @uref{http://momjian.us/main/writings/pgsql/aw_pgsql_book/}."
msgstr ""

#. type: Plain text
#: R-data.texi:2363
msgid "B.@: D.@: Ripley (2001) Connections. \\@emph{R News}, @strong{1/1}, 16--7.  \\@uref{https://www.r-project.org/doc/Rnews/Rnews_2001-1.pdf}"
msgstr ""

#
#. type: Plain text
#: R-data.texi:2368
msgid "T.@: M.@: Therneau and P.@: M.@: Grambsch (2000) @emph{Modeling Survival Data.  Extending the Cox Model.} Springer-Verlag."
msgstr ""

#
#. type: Plain text
#: R-data.texi:2372
msgid "E.@: J.@: Yarger, G.@: Reese and T.@ King (1999) @emph{MySQL & mSQL}.  O'Reilly."
msgstr ""

#
#~ msgid "A common field separator to use in the file is a comma, as that is unlikely to appear in any of the fields in English-speaking countries.  Such files are known as CSV (comma separated values) files, and wrapper function @code{write.csv} provides appropriate defaults.  In some locales the comma is used as the decimal point (set this in @code{write.table} by @code{dec = \",\"}) and there CSV files use the semicolon as the field separator: use @code{write.csv2} for appropriate defaults.  There is an IETF standard for CSV files (which mandates commas and CRLF line endings, for which use @code{eol = \"\\r\\n\"}), RFC4180 (see @uref{http://tools.ietf.org/html/rfc4180}), but what is more important in practice is that the file is readable by the application it is targeted at."
#~ msgstr "가장 많이 사용되는 필드 구분자 중 하나는 쉼표(comma)이며, 그래서 영어를 사용하는 국가에서는 필드 안에서 입력된 값에서 쉼표를 발견하는 일이 그리 흔하지는 않습니다. 이러한 형태의 파일들을 CSV (comma separated values)라고 하며, wrapper 함수인 @code{write.csv}가 적당한 기본값을 제공합니다. 몇몇 지역에서는, 쉼표가 소수점(decimal point)으로 사용되고 있으므로(이 경우는 @code{write.table}에서 @{dec = \",\"}을 지정하는 것과 같습니다) CSV 파일 중에 세미콜론이 필드 구분자로 사용되는 것도 있습니다. 이 경우 적절한 기본값을 사용하기 위해 @code{write.csv2}을 사용해야 합니다. CSV에 대한 IETF 표준이 있습니다. IETF에서는 @code{eol = \"\\r\\n\"}), RFC4180 (see @uref{http://tools.ietf.org/html/rfc4180}) 를 사용하는 것에 대해콤마와 CRLF 라인 인코딩을 권장합니다. 그러나 실제에서 더욱 중요한 것은 목표로 하고 있는 어플리케이션에 의해 읽혀들여 질 수 있는가 입니다."

#
#~ msgid "Traditionally there had been large (and expensive) commercial RDBMSs (@uref{http://www.informix.com, Informix}; @uref{http://www.oracle.com, Oracle}; @uref{http://www.sybase.com, Sybase}; @uref{http://www.ibm.com/db2, IBM's DB2}; @uref{http://www.microsoft.com/SQL/default.mspx, Microsoft @acronym{SQL} Server} on Windows) and academic and small-system databases (such as MySQL@footnote{and forks, notably MariaDB.}, PostgreSQL, Microsoft Access, @dots{}), the former marked out by much greater emphasis on data security features.  The line is blurring, with MySQL and PostgreSQL having more and more high-end features, and free `express' versions being made available for the commercial DBMSs."
#~ msgstr "전통적으로 데이터 보안에 보다 비중을 두고 있는 비싸고 큰 상업용 RDBMSs 는 있었습니다((@uref{http://www.informix.com, Informix}; @uref{http://www.oracle.com,Oracle}; @uref{http://www.sybase.com, Sybase}; @uref{http://www.ibm.com/db2, IBM's DB2}; @uref{http://www.microsoft.com/SQL/default.mspx, Microsoft @acronym{SQL} Server} on Windows). 그리고 교육용이나 작은 크기의 데이터베이스(MySQL, PostgreSQL, Microsoft Access 와 같은)도 있었습니다.오픈소스인 PostgreSQL 이 점점 고도화되고 Informix, Oracle, 그리고 Sybase 가 리눅스에서 무료 버전을 배포하면서 이러한 관점의 논의는 의미가 희미해져 가고 있습니다."

#
#, fuzzy
#~| msgid "All except @CRANpkg{RODBC} are tied to one DBMS, but there has been a proposal for a unified `front-end' package @CRANpkg{DBI} (@uref{http://developer.r-project.org/db}) in conjunction with a `back-end', the most developed of which is @CRANpkg{RMySQL}.  Also on @acronym{CRAN} are the back-ends @CRANpkg{ROracle}, @CRANpkg{RPostgreSQL} and @CRANpkg{RSQLite} (which works with the bundled DBMS @code{SQLite}, @uref{http://www.sqlite.org}), @CRANpkg{RJDBC} (which uses Java and can connect to any DBMS that has a JDBC driver) and @CRANpkg{RpgSQL} (a specialist interface to PostgreSQL built on top of @CRANpkg{RJBDC})."
#~ msgid "All except @CRANpkg{RODBC} are tied to one DBMS, but there has been a proposal for a unified `front-end' package @CRANpkg{DBI} (@uref{http://developer.r-project.org/db}) in conjunction with a `back-end', the most developed of which is @CRANpkg{RMySQL}.  Also on @acronym{CRAN} are the back-ends @CRANpkg{ROracle}, @CRANpkg{RPostgreSQL} and @CRANpkg{RSQLite} (which works with the bundled DBMS @code{SQLite}, @uref{http://www.sqlite.org}), @CRANpkg{RJDBC} (which uses Java and can connect to any DBMS that has a JDBC driver) and @CRANpkg{RpgSQL} (a specialist interface to PostgreSQL built on top of @CRANpkg{RJDBC})."
#~ msgstr "@R{} 도움말을 위해 DBMSs 와 연계된 @acronym{CRAN} 에 관한 여러 종류의 패키지가 사용할 수 있습니다. 이것들은 여러 수준의 추론(abstraction)을 제공합니다. 어떤 것은 데이터베이스로부터 그리고 데이터베이스로 전체 데이터로 복사하는 기능을 제공합니다. 모든 패키지들이 데이터베이스에서 @acronym{SQL} 쿼리를 통해 데이터를 선택하고 데이터 프레임이나 그 일부(보통은 행들의 집합으로 구성된)로써 결과를 출력하기 위한 함수를 가지고 있습니다."

#
#~ msgid "Package @CRANpkg{RMySQL} on @acronym{CRAN} provides an interface to the MySQL database system (see @uref{http://www.mysql.com} and Dubois, 2000).  The description here applies to version @code{0.5-0}: earlier versions had a substantially different interface.  The current version requires the @CRANpkg{DBI} package, and this description will apply with minor changes to all the other back-ends to @CRANpkg{DBI}."
#~ msgstr "@acronym{CRAN} 에 있는 패키지 @CRANpkg{RMySQL} 는 MySQL 데이터 베이스 시스템을 위한 인터페이스를 제공합니다(이에 관하여는 @uref{http://www.mysql.com} and Dubois, 2000.을 참고하십시오). 여기에서 설명하는 것은 버전 @code{0.5-0} 에 관한 것이고 그 이전 버전은 완전히 다른 인터페이스를 가지고 있습니다. 현재 버전은 @CRANpkg{DBI} 패키지를 필요로 하고 여기서의 설명은 다른 모든 최근의 작은 변화들과 함께 @CRANpkg{DBI} 에 적용됩니다."

#
#, fuzzy
#~| msgid "Windows provides drivers not just for DBMSs but also for Excel (@file{.xls}) spreadsheets, DBase (@file{.dbf}) files and even text files.  (The named applications do @emph{not} need to be installed. Which file formats are supported depends on the the versions of the drivers.)  There are versions for Excel and Access 2007/2010 (go to @uref{http://download.microsoft.com}, and search for `Office ODBC', which will lead to @file{AccessDatabaseEngine.exe}), the `2007 Office System Driver' (the latter has a version for 64-bit Windows, and that will also read earlier versions)."
#~ msgid "Windows provides drivers not just for DBMSs but also for Excel (@file{.xls}) spreadsheets, DBase (@file{.dbf}) files and even text files.  (The named applications do @emph{not} need to be installed. Which file formats are supported depends on the versions of the drivers.)  There are versions for Excel and Access 2007/2010 (go to @uref{http://download.microsoft.com}, and search for `Office ODBC', which will lead to @file{AccessDatabaseEngine.exe}), the `2007 Office System Driver' (the latter has a version for 64-bit Windows, and that will also read earlier versions)."
#~ msgstr "Windows 는 DBMS 들을 위한 것뿐만 아니라 엑셀시트('@file{.xls}'), DBase('@file{.dbf}') 그리고 텍스트 파일을 위한 드라이버도 제공합니다(명명된 응용프로그램들이 설치될 필요는 없습니다. 그리고 그런 파일 형태들은 드라이버 버전에 따라 지원 여부가 결정됩니다). 엑셀 2007 과 엑세스 2007 을 위한 '2007 Office System Driver 가 있습니다(@uref{http://download.microsoft.com} 을 방문하여 \"Office ODBC\"를 검색하면 '@file{AccessDatabaseEngine.exe}'를 찾을 수 있습니다)."

#
#, fuzzy
#~| msgid "Packages @CRANpkg{hdf5}, @CRANpkg{h5r}, Bioconductor's @pkg{rhdf5}, @CRANpkg{RNetCDF}, @CRANpkg{ncdf} and @CRANpkg{ncdf4} on @acronym{CRAN} provide interfaces to @acronym{NASA}'s HDF5 (Hierarchical Data Format, see @uref{http://hdf.ncsa.uiuc.edu/HDF5/}) and to UCAR's netCDF data files (network Common Data Form, see @uref{http://www.unidata.ucar.edu/packages/netcdf/})."
#~ msgid "Packages @CRANpkg{hdf5}, @CRANpkg{h5r}, Bioconductor's @pkg{rhdf5}, @CRANpkg{RNetCDF}, @CRANpkg{ncdf} and @CRANpkg{ncdf4} on @acronym{CRAN} provide interfaces to @acronym{NASA}'s HDF5 (Hierarchical Data Format, see @uref{http://www.hdfgroup.org/HDF5/}) and to UCAR's netCDF data files (network Common Data Form, see @uref{http://www.unidata.ucar.edu/software/netcdf/})."
#~ msgstr "@acronym{CRAN} 에서 제공되는 @CRANpkg{hdf5}, Bioconductor's @pkg{rhdf5},@pkg{RNetCDF}, @CRANpkg{ncdf4} 그리고 @CRANpkg{ncdf} 패키지는 @acronym{NASA} 의 HDF5(Hierarchical Data Format: 위계적 데이터 포맷; 이에 관하여는 @uref{http://hdf.ncsa.uiuc.edu/HDF5/}를 참고하십시오)와 UCAR 의 netCDF 데이터 파일 (network Common Data Form: 네트워크 공용 데이타 폼; 이에 관하여는 겯ㄹ@uref{http://www.unidata.ucar.edu/packages/netcdf/}를참고하십시오)로의 인터페이스를 제공합니다."

#
#~ msgid "@acronym{URL}s of types @samp{http://}, @samp{ftp://} and @samp{file://} can be read from using the function @code{url}.  For convenience, @code{file} will also accept these as the file specification and call @code{url}."
#~ msgstr "@samp{http://}, @samp{ftp://}, 그리고 @samp{file://}과 같은 유형의 @acronym{URL} 들은 @code{url} 함수를 사용함으로써 읽혀질 수 있습니다. 편의를 위해 파일을 지정함으로써 @code{file} 또한 @samp{http://}, @samp{ftp://}, 그리고 @samp{file://}을 인식하고 @code{url} 을 불러옵니다."

#
#~ msgid "There are other commonly used data sources, including spreadsheets, non-relational databases and even text files (possibly compressed).  Open Database Connectivity (@acronym{ODBC}) is a standard to use all of these data sources.  It originated on Windows (see @uref{http://www.microsoft.com/data/odbc/}) but is also implemented on Linux/Unix/OS X."
#~ msgstr "텍스트 파일뿐만 아니라 관련된 데이터베이스를 사용하는 다른 일반적인 - 스프레드시트를 포함하여 -데이터 원천들이 있습니다. @acronym{ODBC}(Open Database Connectivity)는 이런 종류의 모든 데이터 원천 사용의 표준입니다.그것은 Windows에 기반한 것이었지만 Linux/Unix 에서도 사용할 수 있습니다(@uref{http://www.microsoft.com/data/odbc} 를 참고하시오). 이 장의 후반부에 클라이언트 대 글라이언트/서버 데이터베이스를 제공하는 모든 패키지가 설명되어 있습니다."

#
#~ msgid "@code{dBase} was a DOS program written by Ashton-Tate and later owned by Borland which has a binary flat-file format that became popular, with file extension @file{.dbf}.  It has been adopted for the 'Xbase' family of databases, covering dBase, Clipper, FoxPro and their Windows equivalents Visual dBase, Visual Objects and Visual FoxPro (see @uref{http://www.e-bachmann.dk/docs/xbase.htm}).  A dBase file contains a header and then a series of fields and so is most similar to an @R{} data frame.  The data itself is stored in text format, and can include character, logical and numeric fields, and other types in later versions (see @uref{http://clicketyclick.dk/docs/data_types.html})."
#~ msgstr "@code{dBases} 는 Ashton-Tate 에 의해 만들어진 DOS 프로그램입니다. 그리고 이후에 '@file{.dbf}'라는 흔히 사용되는 파일 확장자와 함께 flat-file format 의 binary 를 가진 Borland 가 소유하게 되었습니다. 그것은 dBase, Clipper, FoxPro 와 그것들의 윈도우 형태인 Visual dBase, Visual Objects 그리고 Visual FoxPro 를 포함하는 „Xbase‟라는 데이터베이스 군에 적용되어 왔습니다(이에 관하여는 @uref{http://www.e-bachmann.dk/docs/Xbase.htm} 을 참고하십시오). dBase 파일은 헤더(header)와 일련의 필드(fields)를 포함하고 있어서 R 데이터 프레임과 가장 유사합니다. 데이터는 텍스트 포맷으로 저장되며, 문자, 논리적 필드와 수리적 필드, 그리고 최신 버전의 다른 유형들(이에 관하여는 @uref{http://clicketyclick.dk/docs/data_types.html} 를 참고하십시오)을 포함할 수 있습니다."

#
#~ msgid "@acronym{CORBA} (Common Object Request Broker Architecture) is similar to @acronym{DCOM}, allowing applications to call methods, or operations, in server objects running in other applications, potentially programmed in different languages and running on different machines.  There is a @pkg{CORBA} package available from the Omegahat project (at @uref{http://www.omegahat.org/RSCORBA/}), currently for Unix but a Windows version looks to be possible."
#~ msgstr "@acronym{CORBA}(Common Object Request Broker Architecture)는 어플리케이션(application; 응용프로그램?)이 잠재적으로 다른 언어와 다른 장치에서 작동중인 프로그램되어 다른 어플리케이션(application; 응용프로그램?)들에서 작동중인 서버 대상(server objects)에서 방법 또는 오퍼레이션들(?)을 불러들일 수 있게 한다는 점에서 @acronym{DCOM} 과 비슷합니다. 패키지 @pkg{CORBA} 는 Omegahat project(@uref{http://www.omegahat.org/RSCOR BA/})에서 얻을 수 있으며, 현재 Unix 버전이 제공되고 있습니다. Windows 버전은 제공되고 있지 않지만 앞으로 개발할 것으로 보입니다."

#
#~ msgid "This package allows @R{} commands to be used to locate available @acronym{CORBA} servers, query the methods they provide, and dynamically invoke methods on these objects.  @R{} values given as arguments in these calls are exported in the call and made available to that operation invocation.  Primitive data types (vectors and lists) are exported by default, while more complex objects are exported by reference.  Examples of using this include communicating with the Gnumeric (@uref{http://www.gnumeric.org}) spreadsheet, and also interacting with the data visualization system @uref{http://www.ggobi.org, ggobi}."
#~ msgstr "이 패키지는 @R{} 명령어들이 사용 가능한 @acronym{CORBA} 서버에 접속하고, 그것들이 제공하는 방법들(methods)에 대해 질문(query)하고, 그리고 동적으로(dynamically) 이런 대상들에 대한 방법을 불러 들입니다(invoke). 이러한 불러오기(calls)에서 인수로 주어진 R 값들은 불러오기(the call)에서 내보내어지고 오퍼레이션(?) 불러오기(invocation: 조회?)를 가능하게 만들어 줍니다. 원시 데이터 유형(vector 와 list)은 디폴트 형태로 내보내기 됩니다. 반면, 더욱 복잡한 형태의 대상은 참조(reference)에 따라 내보내기 됩니다. 이것의 사용사례는 Gnumeric(@uref{http://www.gnumeric.org}) 스프레드시트(spreadsheet)와의 커뮤니케이팅과 데이터 시각화 시스템 ggobi@uref{http://www.ggobi.org, ggobi} 와의 상호작용을 포함합니다."

#
#~ msgid "One can also create @acronym{CORBA} servers within @R{}, allowing other applications to call these methods.  For example, one might offer access to a particular dataset or to some of @R{}'s modelling software.  This is done dynamically by combining @R{} data objects and functions.  This allows one to explicitly export data and functionality from @R{}."
#~ msgstr "또한 누구든지 다른 어플리케이션들이 이런 방법을 요구하도록 함으로써 @R{} 에서 @acronym{CORBA} 서버를 생성할 수 있습니다. 예를 들어, 누군가 특정 데이터세트(dataset) 또는 어떤 @R{} 모델링 소프트웨어 접근을 신청할 수 있습니다. 이것은 @R{} 데이터 대상과 함수를 결합함으로써 동적으로 이루어집니다. 이것은 누구든지 명백하게 데이터와 @R{} 로부터의 기능성(functionality from R)을 내보낼 수 있게 합니다."

#
#~ msgid "One can also use the @pkg{CORBA} package to achieve distributed, parallel computing in @R{}.  One @R{} session acts as a manager and dispatches tasks to different servers running in other @R{} worker sessions.  This uses the ability to invoke asynchronous or background CORBA calls in @R{}.  More information is available from the Omegahat project at @uref{http://www.omegahat.org/RSCORBA/}."
#~ msgstr "누구든지 @R{} 에서 computing 하는 것과 동일(parallel)하게 배포할 수 있도록 @pkg{CORBA} 패키지를 이용할 수 있습니다. 어느 @R{} 세션은 마치 매니저처럼 행동하기도 하고 다른 @R{} 작업자(worker) 세션에서 작동하는 다른 서버에 대해 일을 처리할 수 있습니다. 이것은 @R{} 에서 비동기(asynchronous) 또는 background CORBA call 을 부르는 능력을 사용합니다. 이것에 대한 더 자세한 정보는 Omegahat project(@uref{http://www.omegahat.org/RSCORBA})에서 얻을 수 있습니다."
