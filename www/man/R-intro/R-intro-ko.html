<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- 이 매뉴얼은 R (3.3.0)을 위하여 작성되었습니다.

Copyright (C) 1990 W. N. Venables
 Copyright (C) 1992
W. N. Venables & D. M. Smith
 Copyright (C) 1997 R.
Gentleman & R. Ihaka
 Copyright (C) 1997, 1998 M. Maechler

Copyright (C) 1999-2014 R Core Team

Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided that the
entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions,
except that this permission notice may be stated in a translation
approved by the R Core Team. -->
<!-- Created by GNU Texinfo 5.2, http://www.gnu.org/software/texinfo/ -->
<head>
<title>An Introduction to R (translated in Korean)</title>

<meta name="description" content="An Introduction to R (translated in Korean)">
<meta name="keywords" content="An Introduction to R (translated in Korean)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link href="#Top" rel="start" title="Top">
<link href="#g_t_d568_c218-_bc0f-_bcc0_c218_c640-_ad00_b828_b41c-_c0c9_c778" rel="index" title="함수 및 변수와 관련된 색인">
<link href="#SEC_Contents" rel="contents" title="Table of Contents">
<link href="dir.html#Top" rel="up" title="(dir)">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.smallquotation {font-size: smaller}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.indentedblock {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
div.smalldisplay {margin-left: 3.2em}
div.smallexample {margin-left: 3.2em}
div.smallindentedblock {margin-left: 3.2em; font-size: smaller}
div.smalllisp {margin-left: 3.2em}
kbd {font-style:oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: inherit; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: inherit; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.nocodebreak {white-space:nowrap}
span.nolinebreak {white-space:nowrap}
span.roman {font-family:serif; font-weight:normal}
span.sansserif {font-family:sans-serif; font-weight:normal}
ul.no-bullet {list-style: none}
body {
    margin-left: 5%;
    margin-right: 5%;
}

h1 {             
    background: white;
    color: rgb(25%, 25%, 25%);
    font-family: monospace;
    font-size: xx-large;
    text-align: center;
}

h2 {
    background: white;
    color: rgb(40%, 40%, 40%);
    font-family: monospace;
    font-size: x-large;
    text-align: center;
}

h3 {
    background: white;
    color: rgb(40%, 40%, 40%);
    font-family: monospace;
    font-size: large;
}

h4 {
    background: white;
    color: rgb(40%, 40%, 40%);
    font-family: monospace;
}

span.samp {
    font-family: monospace;
}

span.command {
    font-family: monospace;
}

span.option {
    font-family: monospace;
}

span.file {
    font-family: monospace;
}

span.env {
    font-family: monospace;
}

ul {
    margin-top: 0.25ex;
    margin-bottom: 0.25ex;
}

li {
    margin-top: 0.25ex;
    margin-bottom: 0.25ex;
}

p {
    margin-top: 0.6ex;
    margin-bottom: 1.2ex;
}

-->
</style>


</head>

<body lang="en" bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#800080" alink="#FF0000">
<h1 class="settitle" align="center">An Introduction to R (translated in Korean)</h1>


























<a name="SEC_Contents"></a>
<h2 class="contents-heading">Table of Contents</h2>

<div class="contents">

<ul class="no-bullet">
  <li><a name="toc-seomun" href="#g_t_c11c_bb38">서문</a></li>
  <li><a name="toc-sogae-mic-miri-aladueoya-hal-naeyong" href="#g_t_c18c_ac1c-_bc0f-_bbf8_b9ac-_c54c_c544_b450_c5b4_c57c-_d560-_b0b4_c6a9">1 소개 및 미리 알아두어야 할 내용</a>
  <ul class="no-bullet">
    <li><a name="toc-Ryi-hwangyeong-_0028inbaireonmeonteu-ddoneun-environment_0029" href="#R_c758-_d658_acbd-_0028_c778_bc14_c774_b7f0_ba3c_d2b8-_b610_b294-environment_0029">1.1 R의 환경 (인바이런먼트 또는 environment)</a></li>
    <li><a name="toc-yeongwandoen-sopeuteuweeo-mic-munseodeul" href="#g_t_c5f0_ad00_b41c-_c18c_d504_d2b8_c6e8_c5b4-_bc0f-_bb38_c11c_b4e4">1.2 연관된 소프트웨어 및 문서들</a></li>
    <li><a name="toc-Rgwa-tonggye" href="#R_acfc-_d1b5_acc4">1.3 R과 통계</a></li>
    <li><a name="toc-Rgwa-windou-siseutem" href="#R_acfc-_c708_b3c4_c6b0-_c2dc_c2a4_d15c">1.4 R과 윈도우 시스템</a></li>
    <li><a name="toc-Reul-daehwasigeuro-sayonghagi" href="#R_c744-_b300_d654_c2dd_c73c_b85c-_c0ac_c6a9_d558_ae30">1.5 R을 대화식으로 사용하기</a></li>
    <li><a name="toc-sogae-sesyeon_0028introductory-session_0029" href="#sogae-sesyeon_0028introductory-session_0029">1.6 소개 세션(introductory session)</a></li>
    <li><a name="toc-hamsu_0028functions_0029wa-gineung_0028features_0029e-daehan-doummal-sayonghagi" href="#g_t_b3c4_c6c0_b9d0-_ae30_b2a5-_c0ac_c6a9_d558_ae30">1.7 함수(functions)와 기능(features)에 대한 도움말 사용하기</a></li>
    <li><a name="toc-R-myeongryeongeo-mic-daesomunjayi-gubungwa-gateun-naeyongdeul" href="#R-_ba85_b839_c5b4-_bc0f-_b300_c18c_bb38_c790_c758-_ad6c_bd84_acfc-_ac19_c740-_b0b4_c6a9_b4e4">1.8 R 명령어 및 대소문자의 구분과 같은 내용들</a></li>
    <li><a name="toc-ijeonyi-myeongryeongeoreul-bulreowa-sujeonghagi" href="#g_t_c774_c804_c758-_ba85_b839_c5b4_b97c-_bd88_b7ec_c640-_c218_c815_d558_ae30">1.9 이전의 명령어를 불러와 수정하기</a></li>
    <li><a name="toc-paile-jagseongdoen-myeongryeongeoreul-silhaenghageona-culryeogbanghyangeul-pailro-byeongyeonghagi" href="#g_t_d30c_c77c_c5d0-_c791_c131_b41c-_ba85_b839_c5b4_b97c-_c2e4_d589_d558_ac70_b098-_cd9c_b825_bc29_d5a5_c744-_d30c_c77c_b85c-_bcc0_acbd_d558_ae30">1.10 파일에 작성된 명령어를 실행하거나 출력방향을 파일로 변경하기</a></li>
    <li><a name="toc-yeonggujeog-deiteo-saengseong-mic-gaegceyi-jegeo" href="#g_t_c601_ad6c_c801-_b370_c774_d130-_c0dd_c131-_bc0f-_ac1d_ccb4_c758-_c81c_ac70">1.11 영구적 데이터 생성 및 객체의 제거</a></li>
  </ul></li>
  <li><a name="toc-susjawa-begteoe-daehan-gico-jojagbeob" href="#Simple-manipulations-numbers-and-vectors">2 숫자와 벡터에 대한 기초 조작법</a>
  <ul class="no-bullet">
    <li><a name="toc-begteowa-haldang" href="#g_t_bca1_d130_c640-_d560_b2f9">2.1 벡터와 할당</a></li>
    <li><a name="toc-begteo-yeonsan" href="#g_t_bca1_d130-_c5f0_c0b0">2.2 벡터 연산</a></li>
    <li><a name="toc-Generating-regular-sequences-_0028gyucigseongeul-jinin-ilryeonyi-susjadeuleul-saengseonghagi_0029" href="#Generating-regular-sequences-_0028_addc_ce59_c131_c744-_c9c0_b2cc-_c77c_b828_c758-_c22b_c790_b4e4_c744-_c0dd_c131_d558_ae30_0029">2.3 Generating regular sequences (규칙성을 지닌 일련의 숫자들을 생성하기)</a></li>
    <li><a name="toc-nonrihyeong-begteo" href="#g_t_b17c_b9ac_d615-_bca1_d130">2.4 논리형 벡터</a></li>
    <li><a name="toc-gyeolceuggabs" href="#g_t_acb0_ce21_ac12">2.5 결측값</a></li>
    <li><a name="toc-munjahyeong-begteo" href="#g_t_bb38_c790_d615-_bca1_d130">2.6 문자형 벡터</a></li>
    <li><a name="toc-indegseu-begteoreul-sayonghan-deiteosesyi-seontaeggwa-sujeong" href="#g_t_c778_b371_c2a4-_bca1_d130">2.7 인덱스 벡터를 사용한 데이터셋의 선택과 수정</a></li>
    <li><a name="toc-gaegceyi-dareun-yuhyeongdeul" href="#g_t_ac1d_ccb4_c758-_b2e4_b978-_c720_d615_b4e4">2.8 객체의 다른 유형들</a></li>
  </ul></li>
  <li><a name="toc-gaegceyi-jeojangbangsiggwa-sogseong" href="#Objects">3 객체의 저장방식과 속성</a>
  <ul class="no-bullet">
    <li><a name="toc-goyusogseong_003a-jeojangbangbeob-geurigo-gili" href="#The-intrinsic-attributes-mode-and-length">3.1 고유속성: 저장방법 그리고 길이</a></li>
    <li><a name="toc-gaegceyi-gili-byeongyeong" href="#g_t_ac1d_ccb4_c758-_ae38_c774-_bcc0_acbd">3.2 객체의 길이 변경</a></li>
    <li><a name="toc-Getting-and-setting-attributes-_0028sogseongeul-seoljeonghago-hwaginhagi_0029" href="#Getting-and-setting-attributes-_0028_c18d_c131_c744-_c124_c815_d558_ace0-_d655_c778_d558_ae30_0029">3.3 Getting and setting attributes (속성을 설정하고 확인하기)</a></li>
    <li><a name="toc-gaegceyi-keulraeseu" href="#g_t_ac1d_ccb4_c758-_d074_b798_c2a4">3.4 객체의 클래스</a></li>
  </ul></li>
  <li><a name="toc-sunseohyeonggwa-bisunseohyeong-yoin" href="#Factors-_0028_c694_c778_0029">4 순서형과 비순서형 요인</a>
  <ul class="no-bullet">
    <li><a name="toc-gucejeogin-yeje" href="#gucejeogin-yeje">4.1 구체적인 예제</a></li>
    <li><a name="toc-hamsu-tapply_0028_0029wa-bijeonghyeong-baeyeol" href="#The-function-tapply_0028_0029-and-ragged-arrays">4.2 함수 <code>tapply()</code>와 비정형 배열</a></li>
    <li><a name="toc-sunseohyeong-yoin" href="#g_t_c21c_c11c_d615-_c694_c778">4.3 순서형 요인</a></li>
  </ul></li>
  <li><a name="toc-Arrays-and-matrices-_0028baeyeolgwa-haengryeol_0029" href="#Arrays-and-matrices-_0028_bc30_c5f4_acfc-_d589_b82c_0029">5 Arrays and matrices (배열과 행렬)</a>
  <ul class="no-bullet">
    <li><a name="toc-baeyeol" href="#g_t_bc30_c5f4">5.1 배열</a></li>
    <li><a name="toc-baeyeol-indegsing_0028array-indexing_0029gwa-guseongyosoyi-seontaegjeog-jijeong_0028subsections_0029" href="#Array-indexing">5.2 배열 인덱싱(array indexing)과 구성요소의 선택적 지정(subsections)</a></li>
    <li><a name="toc-Index-matrices-_0028indegseu-haengryeol_0029" href="#Index-matrices-_0028_c778_b371_c2a4-_d589_b82c_0029">5.3 Index matrices (인덱스 행렬)</a></li>
    <li><a name="toc-array_0028_0029-hamsu" href="#array_0028_0029-_d568_c218">5.4 <code>array()</code> 함수</a>
    <ul class="no-bullet">
      <li><a name="toc-begteowa-baeyeoleul-hamgge-iyonghayeo-yeonsanhaneun-bangbeob-geurigo-jaehwalyong-gyucig" href="#The-recycling-rule">5.4.1 벡터와 배열을 함께 이용하여 연산하는 방법 그리고 재활용 규칙</a></li>
    </ul></li>
    <li><a name="toc-du-baeyeolyi-oejeog" href="#g_t_b450-_bc30_c5f4_c758-_c678_c801">5.5 두 배열의 외적</a></li>
    <li><a name="toc-baeyeolyi-jeoncie-sayongdoeneun-ilbanhwadoen-bangbeob" href="#g_t_bc30_c5f4_c758-_c804_ce58_c5d0-_c0ac_c6a9_b418_b294-_c77c_bc18_d654_b41c-_bc29_bc95">5.6 배열의 전치에 사용되는 일반화된 방법</a></li>
    <li><a name="toc-haengryeolyi-gineungdeul" href="#g_t_d589_b82c_c758-_ae30_b2a5_b4e4">5.7 행렬의 기능들</a>
    <ul class="no-bullet">
      <li><a name="toc-haengryeolyi-gobsem" href="#Multiplication">5.7.1 행렬의 곱셈</a></li>
      <li><a name="toc-seonhyeongbangjeongsiggwa-yeoghaengryeol" href="#g_t_c120_d615_bc29_c815_c2dd_acfc-_c5ed_d589_b82c">5.7.2 선형방정식과 역행렬</a></li>
      <li><a name="toc-goyugabsgwa-goyubegteo" href="#g_t_ace0_c720_ac12_acfc-_ace0_c720_bca1_d130">5.7.3 고유값과 고유벡터</a></li>
      <li><a name="toc-teugigabs-bunhae-mic-haengryeolsig" href="#g_t_d2b9_c774_ac12-_bd84_d574-_bc0f-_d589_b82c_c2dd">5.7.4 특이값 분해 및 행렬식</a></li>
      <li><a name="toc-coesojegobbeobgwa-QR-bunhaebeob" href="#g_t_cd5c_c18c_c81c_acf1_bc95_acfc-QR-_bd84_d574_bc95">5.7.5 최소제곱법과 QR 분해법</a></li>
    </ul></li>
    <li><a name="toc-cbind_0028_0029wa-rbind_0028_0029reul-iyonghayeo-bunhaldoen-haengryeoleul-johabhagi" href="#Forming-partitioned-matrices">5.8 <code>cbind()</code>와 <code>rbind()</code>를 이용하여 분할된 행렬을 조합하기</a></li>
    <li><a name="toc-baeyeoleseo-sayonghaneun-gyeolhab_0028concatenation_0029-hamsu-c_0028_0029" href="#g_t_bc30_c5f4_c5d0-_c0ac_c6a9_b418_b294-_acb0_d569_d568_c218-c_0028_0029">5.9 배열에서 사용하는 결합(concatenation) 함수 <code>c()</code></a></li>
    <li><a name="toc-yoineul-iyonghayeo-dosubunpopyo-saengseonghagi" href="#g_t_c694_c778_c744-_c774_c6a9_d558_c5ec-_b3c4_c218_bd84_d3ec_d45c-_c0dd_c131_d558_ae30">5.10 요인을 이용하여 도수분포표 생성하기</a></li>
  </ul></li>
  <li><a name="toc-riseuteuwa-deiteo-peureim" href="#g_t_b9ac_c2a4_d2b8_c640-_b370_c774_d130-_d504_b808_c784">6 리스트와 데이터 프레임</a>
  <ul class="no-bullet">
    <li><a name="toc-Lists-_0028riseuteu_0029" href="#Lists-_0028_b9ac_c2a4_d2b8_0029">6.1 Lists (리스트)</a></li>
    <li><a name="toc-riseuteureul-saengseonggwa-sujeong" href="#g_t_b9ac_c2a4_d2b8_b97c-_c0dd_c131_acfc-_c218_c815">6.2 리스트를 생성과 수정</a>
    <ul class="no-bullet">
      <li><a name="toc-Concatenating-lists-_0028riseuteu-yeongyeolhagi_0029" href="#Concatenating-lists-_0028_b9ac_c2a4_d2b8-_c5f0_acb0_d558_ae30_0029">6.2.1 Concatenating lists (리스트 연결하기)</a></li>
    </ul></li>
    <li><a name="toc-Data-frames-_0028deiteo-peureim_0029" href="#Data-frames-_0028_b370_c774_d130-_d504_b808_c784_0029">6.3 Data frames (데이터 프레임)</a>
    <ul class="no-bullet">
      <li><a name="toc-deiteo-peureim-saengseonghagi" href="#g_t_b370_c774_d130-_d504_b808_c784-_c0dd_c131_d558_ae30">6.3.1 데이터 프레임 생성하기</a></li>
      <li><a name="toc-attach_0028_0029-and-detach_0028_0029" href="#attach_0028_0029_c640-detach_0028_0029">6.3.2 <code>attach()</code> and <code>detach()</code></a></li>
      <li><a name="toc-deiteo-peureim-hwalyonghagi" href="#g_t_b370_c774_d130-_d504_b808_c784-_d65c_c6a9_d558_ae30">6.3.3 데이터 프레임 활용하기</a></li>
      <li><a name="toc-Attaching-arbitrary-lists-_0028imyijeogin-riseuteureul-yeongyeolhagi_0029" href="#Attaching-arbitrary-lists-_0028_c784_c758_c801_c778-_b9ac_c2a4_d2b8_b97c-_c5f0_acb0_d558_ae30_0029">6.3.4 Attaching arbitrary lists (임의적인 리스트를 연결하기)</a></li>
      <li><a name="toc-tamsaeggyeongroreul-gwanrihagi" href="#g_t_d0d0_c0c9_acbd_b85c_b97c-_ad00_b9ac_d558_ae30">6.3.5 탐색경로를 관리하기</a></li>
    </ul></li>
  </ul></li>
  <li><a name="toc-Reading-data-from-files-_0028pailrobuteo-deiteo-ilgeoogi_0029" href="#Reading-data-from-files-_0028_d30c_c77c_b85c_bd80_d130-_b370_c774_d130-_c77d_c5b4_c624_ae30_0029">7 Reading data from files (파일로부터 데이터 읽어오기)</a>
  <ul class="no-bullet">
    <li><a name="toc-read_002etable_0028_0029-hamsu" href="#The-read_002etable_0028_0029-function">7.1 <code>read.table()</code> 함수</a></li>
    <li><a name="toc-scan_0028_0029-hamsu" href="#The-scan_0028_0029-function">7.2 <code>scan()</code> 함수</a></li>
    <li><a name="toc-naejangdoen-deiteoseseul-iyonghagi" href="#g_t_b0b4_c7a5_b41c-_b370_c774_d130_c14b_c744-_c774_c6a9_d558_ae30">7.3 내장된 데이터셋을 이용하기</a>
    <ul class="no-bullet">
      <li><a name="toc-dareun-R-paekijideulrobuteo-deiteoreul-rodinghagi" href="#dareun-R-paekijideulrobuteo-deiteoreul-rodinghagi">7.3.1 다른 R 패키지들로부터 데이터를 로딩하기</a></li>
    </ul></li>
    <li><a name="toc-deiteoreul-pyeonjibhagi" href="#g_t_b370_c774_d130_b97c-_d3b8_c9d1_d558_ae30">7.4 데이터를 편집하기</a></li>
  </ul></li>
  <li><a name="toc-hwagryulbunpohamsu" href="#g_t_d655_b960_bd84_d3ec_d568_c218">8 확률분포함수</a>
  <ul class="no-bullet">
    <li><a name="toc-tonggyebunpopyodeuleul-hande-muggeo-noheun-R" href="#g_t_d1b5_acc4_bd84_d3ec_d45c_b4e4_c744-_d55c_b370-_bb36_c5b4-_b193_c740-R">8.1 통계분포표들을 한데 묶어 놓은 R</a></li>
    <li><a name="toc-deiteoyi-bunpo-salpyeobogi" href="#g_t_b370_c774_d130_c758-_bd84_d3ec-_c0b4_d3b4_bcf4_ae30">8.2 데이터의 분포 살펴보기</a></li>
    <li><a name="toc-ilpyobongwa-ipyobon-geomjeong" href="#g_t_c77c_d45c_bcf8_acfc-_c774_d45c_bcf8-_ac80_c815">8.3 일표본과 이표본 검정</a></li>
  </ul></li>
  <li><a name="toc-geurubhwa_002c-banbogmun_002c-geurigo-jogeonbu-silhaeng" href="#Loops-and-conditional-execution-_0028_bc18_bcf5-_bc0f-_c870_ac74_bd80-_c2e4_d589_0029">9 그룹화, 반복문, 그리고 조건부 실행</a>
  <ul class="no-bullet">
    <li><a name="toc-geurubhwadoen-pyohyeon" href="#g_t_adf8_b8f9_d654_b41c-_d45c_d604">9.1 그룹화된 표현</a></li>
    <li><a name="toc-jeeomun" href="#g_t_c81c_c5b4_bb38">9.2 제어문</a>
    <ul class="no-bullet">
      <li><a name="toc-jogeonbu-silhaeng_003a-if-mun" href="#Conditional-execution">9.2.1 조건부 실행: <code>if</code> 문</a></li>
      <li><a name="toc-banbogjeog-silhaeng_003a-forreul-iyonghan-banbog_002c-repeat-geurigo-while" href="#Repetitive-execution">9.2.2 반복적 실행: <code>for</code>를 이용한 반복, <code>repeat</code> 그리고 <code>while</code></a></li>
    </ul></li>
  </ul></li>
  <li><a name="toc-Writing-your-own-functions-_0028sayongja-jeongyihamsu-jagseonghagi_0029" href="#Writing-your-own-functions-_0028_c0ac_c6a9_c790-_c815_c758_d568_c218-_c791_c131_d558_ae30_0029">10 Writing your own functions (사용자 정의함수 작성하기)</a>
  <ul class="no-bullet">
    <li><a name="toc-gandanhan-yeje" href="#g_t_ac04_b2e8_d55c-_c608_c81c">10.1 간단한 예제</a></li>
    <li><a name="toc-saeroun-ihangyeonsanjareul-jeongyihagi" href="#g_t_c0c8_b85c_c6b4-_c774_d56d_c5f0_c0b0_c790_b97c-_c815_c758_d558_ae30">10.2 새로운 이항연산자를 정의하기</a></li>
    <li><a name="toc-injamyeonggwa-gibongabs" href="#g_t_c778_c790_ba85_acfc-_ae30_bcf8_ac12">10.3 인자명과 기본값</a></li>
    <li><a name="toc-The-_2026-argument" href="#The-three-dots-argument">10.4 The &lsquo;<samp>&hellip;</samp>&rsquo; argument</a></li>
    <li><a name="toc-Assignments-within-functions" href="#g_t_d568_c218_b0b4-_d560_b2f9">10.5 Assignments within functions</a></li>
    <li><a name="toc-jom-deo-baljeondoen-yejedeul" href="#g_t_c880-_b354-_bc1c_c804_b41c-_c608_c81c_b4e4">10.6 좀 더 발전된 예제들</a>
    <ul class="no-bullet">
      <li><a name="toc-Efficiency-factors-in-block-designs-1" href="#Efficiency-factors-in-block-designs">10.6.1 Efficiency factors in block designs</a></li>
      <li><a name="toc-Dropping-all-names-in-a-printed-array-1" href="#Dropping-all-names-in-a-printed-array">10.6.2 Dropping all names in a printed array</a></li>
      <li><a name="toc-Recursive-numerical-integration-1" href="#Recursive-numerical-integration">10.6.3 Recursive numerical integration</a></li>
    </ul></li>
    <li><a name="toc-Scope-_0028seukopeu_0029" href="#Scope-_0028_c2a4_cf54_d504_0029">10.7 Scope (스코프)</a></li>
    <li><a name="toc-hwangyeong-seoljeonghagi" href="#g_t_d658_acbd-_c124_c815_d558_ae30">10.8 환경 설정하기</a></li>
    <li><a name="toc-keulraeseu_002c-jenerig-hamsu_002c-geurigo-gaegcejihyang-peurogeuraeming" href="#Object-orientation-_0028_ac1d_ccb4_c9c0_d5a5_c801-_bc29_bc95_0029">10.9 클래스, 제네릭 함수, 그리고 객체지향 프로그래밍</a></li>
  </ul></li>
  <li><a name="toc-Statistical-models-in-R-_0028Reseo-sayongdoeneun-tonggyemohyeongdeul_0029" href="#Statistical-models-in-R-_0028R_c5d0_c11c-_c0ac_c6a9_b418_b294-_d1b5_acc4_baa8_d615_b4e4_0029">11 Statistical models in R (R에서 사용되는 통계모형들)</a>
  <ul class="no-bullet">
    <li><a name="toc-Defining-statistical-models_003b-formulae" href="#g_t_c2dd_0028formulae_0029_c744-_d1b5_d55c-_d1b5_acc4_baa8_d615_c758-_c815_c758">11.1 Defining statistical models; formulae</a>
    <ul class="no-bullet">
      <li><a name="toc-Contrasts-1" href="#Contrasts">11.1.1 Contrasts</a></li>
    </ul></li>
    <li><a name="toc-Linear-models-1" href="#Linear-models">11.2 Linear models</a></li>
    <li><a name="toc-Generic-functions-for-extracting-model-information-1" href="#Generic-functions-for-extracting-model-information">11.3 Generic functions for extracting model information</a></li>
    <li><a name="toc-Analysis-of-variance-and-model-comparison-1" href="#Analysis-of-variance-and-model-comparison">11.4 Analysis of variance and model comparison</a>
    <ul class="no-bullet">
      <li><a name="toc-ANOVA-tables-1" href="#ANOVA-tables">11.4.1 ANOVA tables</a></li>
    </ul></li>
    <li><a name="toc-Updating-fitted-models-1" href="#Updating-fitted-models">11.5 Updating fitted models</a></li>
    <li><a name="toc-Generalized-linear-models-1" href="#Generalized-linear-models">11.6 Generalized linear models</a>
    <ul class="no-bullet">
      <li><a name="toc-Families-1" href="#Families">11.6.1 Families</a></li>
      <li><a name="toc-The-glm_0028_0029-function-1" href="#The-glm_0028_0029-function">11.6.2 The <code>glm()</code> function</a></li>
    </ul></li>
    <li><a name="toc-Nonlinear-least-squares-and-maximum-likelihood-models-1" href="#Nonlinear-least-squares-and-maximum-likelihood-models">11.7 Nonlinear least squares and maximum likelihood models</a>
    <ul class="no-bullet">
      <li><a name="toc-Least-squares-1" href="#Least-squares">11.7.1 Least squares</a></li>
      <li><a name="toc-Maximum-likelihood-1" href="#Maximum-likelihood">11.7.2 Maximum likelihood</a></li>
    </ul></li>
    <li><a name="toc-Some-non_002dstandard-models-1" href="#Some-non_002dstandard-models">11.8 Some non-standard models</a></li>
  </ul></li>
  <li><a name="toc-Graphical-procedures" href="#Graphics-_0028_adf8_b798_d53d_c2a4_0029">12 Graphical procedures</a>
  <ul class="no-bullet">
    <li><a name="toc-High_002dlevel-plotting-commands-1" href="#High_002dlevel-plotting-commands">12.1 High-level plotting commands</a>
    <ul class="no-bullet">
      <li><a name="toc-The-plot_0028_0029-function-1" href="#The-plot_0028_0029-function">12.1.1 The <code>plot()</code> function</a></li>
      <li><a name="toc-Displaying-multivariate-data-1" href="#Displaying-multivariate-data">12.1.2 Displaying multivariate data</a></li>
      <li><a name="toc-Display-graphics-1" href="#Display-graphics">12.1.3 Display graphics</a></li>
      <li><a name="toc-Arguments-to-high_002dlevel-plotting-functions-1" href="#Arguments-to-high_002dlevel-plotting-functions">12.1.4 Arguments to high-level plotting functions</a></li>
    </ul></li>
    <li><a name="toc-Low_002dlevel-plotting-commands-1" href="#Low_002dlevel-plotting-commands">12.2 Low-level plotting commands</a>
    <ul class="no-bullet">
      <li><a name="toc-Mathematical-annotation-1" href="#Mathematical-annotation">12.2.1 Mathematical annotation</a></li>
      <li><a name="toc-Hershey-vector-fonts-1" href="#Hershey-vector-fonts">12.2.2 Hershey vector fonts</a></li>
    </ul></li>
    <li><a name="toc-Interacting-with-graphics-1" href="#Interacting-with-graphics">12.3 Interacting with graphics</a></li>
    <li><a name="toc-Using-graphics-parameters-1" href="#Using-graphics-parameters">12.4 Using graphics parameters</a>
    <ul class="no-bullet">
      <li><a name="toc-yeonggujeog_0028permanent_0029-byeonhwaneul-weonhal-ddae_003a-par_0028_0029-hamsu" href="#The-par_0028_0029-function">12.4.1 영구적(permanent) 변환을 원할 때: <code>par()</code> 함수</a></li>
      <li><a name="toc-injareul-sayonghan-ilsijeog-byeonhwan_0028Temporary-changes_003a-Arguments-to-graphics-functions_0029" href="#Arguments-to-graphics-functions">12.4.2 인자를 사용한 일시적 변환(Temporary changes: Arguments to graphics functions)</a></li>
    </ul></li>
    <li><a name="toc-geuraepig-paramiteo-mogrog" href="#Graphics-parameters">12.5 그래픽 파라미터 목록</a>
    <ul class="no-bullet">
      <li><a name="toc-geuraepig-yosodeulyi-hwalyong_0028Graphical-elements_0029" href="#g_t_adf8_b798_d53d-_c694_c18c_b4e4_c758-_d65c_c6a9_0028Graphical-elements_0029">12.5.1 그래픽 요소들의 활용(Graphical elements)</a></li>
      <li><a name="toc-cuggwa-tig-makeu-_0028tick-marks_0029" href="#g_t_cd95_acfc-_d2f1-_b9c8_d06c-_0028tick-marks_0029">12.5.2 축과 틱 마크 (tick marks)</a></li>
      <li><a name="toc-geurim-_0028figure_0029yi-yeobaeg" href="#g_t_adf8_b9bc-_0028figure_0029_c758-_c5ec_bc31">12.5.3 그림 (figure)의 여백</a></li>
      <li><a name="toc-jungceobdoen-geurim-_0028figure_0029-hwangyeong" href="#g_t_c911_cca9_b41c-_adf8_b9bc-_0028figure_0029-_d658_acbd">12.5.4 중첩된 그림 (figure) 환경</a></li>
    </ul></li>
    <li><a name="toc-Device-drivers-1" href="#Device-drivers">12.6 Device drivers</a>
    <ul class="no-bullet">
      <li><a name="toc-jopan-munseoreul-wihan-poseuteuseukeuribteu-daieogeuraem-saengseonghagi_0028PostScript-diagrams-for-typeset-documents_0029" href="#g_t_c870_d310-_bb38_c11c_b97c-_c704_d55c-_d3ec_c2a4_d2b8_c2a4_d06c_b9bd_d2b8-_b2e4_c774_c5b4_adf8_b7a8-_c0dd_c131_d558_ae30_0028PostScript-diagrams-for-typeset-documents_0029">12.6.1 조판 문서를 위한 포스트스크립트 다이어그램 생성하기(PostScript diagrams for typeset documents)</a></li>
      <li><a name="toc-dasuyi-geuraepig-dibaiseu-_0028graphic-devices_0029" href="#g_t_b2e4_c218_c758-_adf8_b798_d53d-_b514_bc14_c774_c2a4-_0028graphic-devices_0029">12.6.2 다수의 그래픽 디바이스 (graphic devices)</a></li>
    </ul></li>
    <li><a name="toc-Dynamic-graphics-1" href="#Dynamic-graphics">12.7 Dynamic graphics</a></li>
  </ul></li>
  <li><a name="toc-Packages-_0028paekiji_0029" href="#Packages-_0028_d328_d0a4_c9c0_0029">13 Packages (패키지)</a>
  <ul class="no-bullet">
    <li><a name="toc-pyojun-paekijideul-_0028Standard-packages_0029" href="#g_t_d45c_c900-_d328_d0a4_c9c0_b4e4-_0028Standard-packages_0029">13.1 표준 패키지들 (Standard packages)</a></li>
    <li><a name="toc-sayongja_002dgiyeo-paekiji_0028Contributed-packages_0029wa-CRAN" href="#g_t_c0ac_c6a9_c790_002d_ae30_c5ec-_d328_d0a4_c9c0_0028Contributed-packages_0029_c640-CRAN">13.2 사용자-기여 패키지(Contributed packages)와 <acronym>CRAN</acronym></a></li>
    <li><a name="toc-neimseupeiseu-_0028Namespaces_0029" href="#g_t_b124_c784_c2a4_d398_c774_c2a4-_0028Namespaces_0029">13.3 네임스페이스 (Namespaces)</a></li>
  </ul></li>
  <li><a name="toc-unyeongcejeyi-gineungdeule-daehan-jeobgeun" href="#g_t_c6b4_c601_ccb4_c81c_c758-_ae30_b2a5_b4e4_c5d0-_b300_d55c-_c811_adfc">14 운영체제의 기능들에 대한 접근</a>
  <ul class="no-bullet">
    <li><a name="toc-pail-mic-diregteori" href="#g_t_d30c_c77c-_bc0f-_b514_b809_d130_b9ac">14.1 파일 및 디렉터리</a></li>
    <li><a name="toc-Filepaths-1" href="#Filepaths">14.2 Filepaths</a></li>
    <li><a name="toc-siseutem-myeongryeongeo" href="#g_t_c2dc_c2a4_d15c-_ba85_b839_c5b4">14.3 시스템 명령어</a></li>
    <li><a name="toc-abcuggwa-akaibeu-_0028archive_0029" href="#g_t_c555_cd95_acfc-_c544_ce74_c774_be0c-_0028archive_0029">14.4 압축과 아카이브 (archive)</a></li>
  </ul></li>
  <li><a name="toc-A-sample-session-1" href="#A-sample-session">Appendix A A sample session</a></li>
  <li><a name="toc-Invoking-R-_0028Reul-silhaenghagi_0029" href="#Invoking-R-_0028R_c744-_c2e4_d589_d558_ae30_0029">Appendix B Invoking R (R을 실행하기)</a>
  <ul class="no-bullet">
    <li><a name="toc-Invoking-R-from-the-command-line-1" href="#Invoking-R-from-the-command-line">B.1 Invoking R from the command line</a></li>
    <li><a name="toc-Invoking-R-under-Windows-1" href="#Invoking-R-under-Windows">B.2 Invoking R under Windows</a></li>
    <li><a name="toc-Invoking-R-under-OS-X-1" href="#Invoking-R-under-OS-X">B.3 Invoking R under OS X</a></li>
    <li><a name="toc-Scripting-with-R-1" href="#Scripting-with-R">B.4 Scripting with R</a></li>
  </ul></li>
  <li><a name="toc-The-command_002dline-editor-_0028myeongryeongeorain-pyeonjibgi_0029" href="#The-command_002dline-editor-_0028_ba85_b839_c5b4_b77c_c778-_d3b8_c9d1_ae30_0029">Appendix C The command-line editor (명령어라인 편집기)</a>
  <ul class="no-bullet">
    <li><a name="toc-Preliminaries" href="#Preliminaries">C.1 Preliminaries</a></li>
    <li><a name="toc-Editing-actions" href="#Editing-actions">C.2 Editing actions</a></li>
  </ul></li>
  <li><a name="toc-hamsu-mic-byeonsuwa-gwanryeondoen-saegin" href="#g_t_d568_c218-_bc0f-_bcc0_c218_c640-_ad00_b828_b41c-_c0c9_c778">Appendix D 함수 및 변수와 관련된 색인</a></li>
  <li><a name="toc-gaenyeomgwa-gwanryeondoen-saegin" href="#g_t_ac1c_b150_acfc-_ad00_b828_b41c-_c0c9_c778">Appendix E 개념과 관련된 색인</a></li>
  <li><a name="toc-References-_0028camgomunheon_0029" href="#References-_0028_cc38_ace0_bb38_d5cc_0029">Appendix F References (참고문헌)</a></li>
</ul>
</div>


<a name="Top"></a>
<a name="An-Introduction-to-R-_0028translated-in-Korean_0029"></a>
<h1 class="top">An Introduction to R (translated in Korean)</h1>

<p>이 문서는 통계 컴퓨팅(statistical computing)과 그래픽(graphics) 작업을 위한 언어(language)이자
환경(environment)이기도 한 통계소프트웨어 R (&ldquo;GNU S&rdquo;)에 대한 소개를 담고 있습니다. R은 벨연구소(Bell
laboratory)에서 존 챔버스(John Chambers)와 그의 동료들에 의하여 개발되었고 ACM 소프트웨어 시스템
상<a name="DOCF1" href="#FOOT1"><sup>1</sup></a>을 받은바 있는 S
시스템과 유사합니다. 이것은 선형 및 비선형 모델링(linear and non-linear modelling), 통계적
검정(statistical tests), 시계열분석(time series analysis), 통계적
분류기법(classification), 군집분석(clustering)과 같은 다양한 종류의 통계적 기법들과 그래픽 기능들을 제공합니다. 
</p>
<p>이 문서에서는 데이터형(data type), 프로그래밍 기본요소들(programming elements), 그리고 통계
모델링(statistical modelling) 및 그래픽(graphics)에 대한 내용을 다룹니다.
</p>
<p>이 매뉴얼은 R (3.3.0)을 위하여 작성되었습니다.
</p>
<p>Copyright &copy; 1990 W. N. Venables<br> Copyright &copy; 1992
W. N. Venables &amp; D. M. Smith<br> Copyright &copy; 1997 R.
Gentleman &amp; R. Ihaka<br> Copyright &copy; 1997, 1998 M. Maechler<br>
Copyright &copy; 1999&ndash;2014 R Core Team
</p>
<blockquote>
<p>Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.
</p>
<p>Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided that the
entire resulting derived work is distributed under the terms of a
permission notice identical to this one.
</p>
<p>Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions,
except that this permission notice may be stated in a translation
approved by the R Core Team.
</p></blockquote>




<hr>
<a name="g_t_c11c_bb38"></a>
<a name="seomun"></a>
<h2 class="unnumbered">서문</h2>

<p>R에 대한 소개를 담고 있는 본 문서는 빌 베너블스(Bill Venables)와 데이비드 스미스(David M. Smith)가
애들레이드 대학(University of Adelaide)에 있을 당시 S와 S-PLUS의 환경(environment)에 대하여
1990년부터 2년간에 걸쳐 작성한 노트를 기초로 하고 있습니다.  우리는 R과 S 프로그램 사이의 다른 점들을 반영하기
위하여 여러번의 작은 수정 및 일부 내용을 확장하였습니다.
</p>
<p>우리는 이러한 방법으로 수정된 노트를 재배포할 수 있도록 허락해주고, 오래 전부터 R을 지원해 온 빌 베네블스(Bill
Venables)와 데이비드 스미스(David Smith)에게 깊은 감사의 뜻을 전하고자 합니다.
</p>
<p>본 문서에 대한 조언과 교정을 언제나 환영하며, <a href="mailto:R-core@R-project.org">R-core@R-project.org</a>로 내용을 보내주시길 부탁드립니다.
</p>
<a name="munseoreul-ilggi-jeone-dogjadeulege-deurineun-malsseum"></a>
<h4 class="subheading">문서를 읽기 전에 독자들에게 드리는 말씀</h4>

<p>R이 생소한 독자인 경우에 부록 A에 있는 소개세션(introductory session)을 먼저 살펴보시길 바랍니다.아마도
R을 사용하는 방법에 좀 더 익숙해질 뿐만아니라, 실제로 어떤 결과들이 나오는지 바로 알 수 있게 도와줄 것입니다. 
</p>
<p>많은 사용자들이 주로 그래픽 기능 때문에 R을 찾습니다. 이러한 분들을 위하여 관련 내용을 언제든지 살펴볼 수 있도록
See <a href="#Graphics-_0028_adf8_b798_d53d_c2a4_0029">Graphics (그래픽스)</a> 챕터에 따로 정리해 두었습니다.  따라서, 문서의 내용을 순서대로 모두 소화내가며 따라가지
않아도 괜찮습니다.
</p>

<hr>
<a name="g_t_c18c_ac1c-_bc0f-_bbf8_b9ac-_c54c_c544_b450_c5b4_c57c-_d560-_b0b4_c6a9"></a>
<a name="sogae-mic-miri-aladueoya-hal-naeyong"></a>
<h2 class="chapter">1 소개 및 미리 알아두어야 할 내용</h2>


<hr>
<a name="R_c758-_d658_acbd-_0028_c778_bc14_c774_b7f0_ba3c_d2b8-_b610_b294-environment_0029"></a>
<a name="Ryi-hwangyeong-_0028inbaireonmeonteu-ddoneun-environment_0029"></a>
<h3 class="section">1.1 R의 환경 (인바이런먼트 또는 environment)</h3>

<p>R은 데이터의 조작(data manipulation) 및 수학적 계산(calculation), 그리고 시각화(graphical
display)를 위한 도구들을 한데 묶어놓은 것입니다. 특히 다음과 같은 기능들을 포함하고 있습니다.
</p>
<ul>
<li> 효과적인 데이터의 조작 및 처리, 그리고 저장 기능,
</li><li> 배열(array) 계산을 위한 다양한 연산자들 (행렬의 경우에 더욱 특화되어 있음),
</li><li> 체계적으로 잘 정리되어 있는 많은 데이터 분석도구들
</li><li> 데이터 분석을 위한 그래픽 기능들과 더불어 이를 컴퓨터에서 혹은 출력물의 형태로 전환하여 보여주는 기능, 그리고
</li><li> &lsquo;S&rsquo;라고 알려져 있으며, 조건문(conditionals), 반복문(loops), 사용자정의 재귀함수(user defined
recursive functions), 그리고 입출력기능(input and output facilities)을 포함하고 있을 뿐만아니라
단순하면서도 효과적이며 잘 개발된 프로그래밍 언어. (실제로 시스템에서 제공되는 대다수의 함수들은 S언어로 작성되어 있습니다.) 
</li></ul>

<p>환경(&ldquo;environment&rdquo;, 인바이런먼트)라는 용어는 다른 종류의 데이터 분석도구들이 어떤 특정한 기능만을 수행하도록 개발된
도구들을 추가함으로서 시스템을 확장하는 것과는 다르게 체계적이고 잘 계획된 하나의 시스템이라는 점을 부각하기 위하여 사용되었습니다.
</p>
<p>R은 연구자가 데이터와의 대화를 통하여 분석방법을 개발하는 수단입니다.  이러한 것은 방대한 양의
패키지(<em>package</em>)에 의하여 빠른 속도로 이루어져 왔습니다. 그러나, R로 작성된 대부분의 프로그램들은 어떤 특정
연구자에게 주어진 하나의 구체적인 데이터만을 분석하기 위하여 작성된 것입니다.
</p>
<hr>
<a name="g_t_c5f0_ad00_b41c-_c18c_d504_d2b8_c6e8_c5b4-_bc0f-_bb38_c11c_b4e4"></a>
<a name="yeongwandoen-sopeuteuweeo-mic-munseodeul"></a>
<h3 class="section">1.2 연관된 소프트웨어 및 문서들</h3>

<p>R은 벨연구소(Bell Laboratories)에서 근무중이던 릭 벡커(Rick Becker), 존 챔버스(John
Chambers), 그리고 앨런 윌크스(Allan Wilks)에 의하여 개발된 S 언어에 의하여 만들어진 것으로 생각할 수 있습니다. 이
언어는 또한 S-PLUS 시스템의 근간을 형성하고 있습니다.
</p>
<p>S 언어의 진화과정은 존 챔버스(John Chambers)와 그의 동료들이 쓴 네 권의 책을 통하여 알 수 있습니다. 만약,
R에 대해서 가장 기본적인 참고자료를 원한다면 리차드(Richard A.), 베커(Becker, John M.),
챔버스(Chambers), 그리고 앨런(Allan R. Wilks)가 쓴 <em>The New S Language: A
Programming Environment for Data Analysis and Graphics</em>이라는 책을 찾아보길 권합니다.
1991년에 배포된 S 언어의 새로운 기능들은 존 챔버스(John M. Chambers)와 트레버(Trevor J.
Hastie)에 의하여 편집된 <em>Statistical Models in S</em>이라는 책을 참고하길
바랍니다. <strong>methods</strong> 패키지에 구현되어 있는 메소드(method)와 클래스(class)는 존 챔버스(John M.
Chambers)가 저술한 <em>Programming with Data</em>을 토대로 하고 있습니다. 더 자세한 내용들은
See <a href="#References-_0028_cc38_ace0_bb38_d5cc_0029">References (참고문헌)</a>장에 있는 참고문헌을 살펴보시길 바랍니다.
</p>
<p>이미 시중에는 R을 이용한 데이터 분석과 통계학에 관련된 많은 서적들이 있습니다. 또한, S/<small>S-PLUS</small>의 사용을 위하여
작성된 문서들을 참고하는 것 역시 R을 사용하는데 도움이 될 수 있습니다. 그러나, S을 이용하여 구현한 것들간의 차이를
반드시 기억하고 있어야만 합니다. 이에 관해서는 See <a href="R-FAQ.html#What-documentation-exists-for-R_003f">What documentation exists for R?</a> in <cite>The R statistical system FAQ</cite> 이라는 장을 참고하시길 바랍니다.
</p>
<hr>
<a name="R_acfc-_d1b5_acc4"></a>
<a name="Rgwa-tonggye"></a>
<h3 class="section">1.3 R과 통계</h3>
<a name="index-Packages-_0028paekiji_0029"></a>

<p>R의 환경(environment)에 대한 본 안내서는 <em>statistics</em>(통계학)에 대한 설명을 위하여 작성된 것은
아니지만, 이미 많은 독자 여러분들은 R을 통계 시스템(statistics system)으로서 사용하고 있습니다. 우리는
여러분들께서 R이라는 시스템을 과거로부터 현재에 이르기까지 개발되어 온 수많은 통계적 방법들을 구현하여 한데 모아 놓아 사용해 볼
수 있는 하나의 환경으로 생각해주셨으면 합니다. 이러한 많은 방법들 중 일부는 R의 기본 환경(base environment) 안에
이미 포함되어 있습니다.  그러나, 대부분은 패키지(<em>packages</em>)의 형태로서 제공됩니다. 기본적으로 R은
표준(&ldquo;standard&rdquo;) 혹은 권장 (또는 추천, &ldquo;recommended&rdquo;) 패키지라고 불리우는 대략 25개의 패키지들로
구성되어 있습니다.더 많은 패키지들을 <acronym>CRAN</acronym>이라는 인터넷
저장소(<a href="http://CRAN.R-project.org">http://CRAN.R-project.org</a>)를 통해서 얻을 수 있습니다. 패키지에 관한 더 자세한 내용을
(see <a href="#Packages-_0028_d328_d0a4_c9c0_0029">Packages (패키지)</a>)에서 찾아볼 수 있습니다.
</p>
<p>가장 고전적인 통계(classical statistics) 방법부터 최근에 개발된 많은 방법들을R에서 사용될 수 있습니다.
그러나, 이런 것들을 찾는 것은 사용자의 몫입니다.
</p>
<p>S (이 문서에서는 R)과 다른 주요 통계 시스템들 사이에는 철학적인 면에서 중요한 다른 점이 존재합니다.S를 이용한
통계분석(statistical analysis)은 보통 일련의 절차로 수행되며, 각 과정에서 얻어진 결과들은 객체(objects)의
형태로 저장되게 됩니다.예를들어, SAS 또는 SPSS를 이용하여 회귀분석(regression) 또는 판별분석(discriminant
analysis)을 수행한 경우 분석 과정 중에 생성된 모든 결과를 한번에 보여주는 반면, R은 최소한의 결과만을 출력해주고 생성된
결과들을 적합한 객체의 형태로 저장하여 차후에 이를 활용할 수 있는 추가적인 R 함수들과 함께 사용할 수 있도록 합니다.
</p>
<hr>
<a name="R_acfc-_c708_b3c4_c6b0-_c2dc_c2a4_d15c"></a>
<a name="Rgwa-windou-siseutem"></a>
<h3 class="section">1.4 R과 윈도우 시스템</h3>

<p>R을 사용하는 가장 손쉬운 방법은 윈도우 시스템(windowing sytem, 즉 두 개이상의 서로 다른 데이터를 여러 개의 창을을
띄어 한 화면에 표시해 주는 시스템)을 사용하는 그래픽 워크스테이션(graphics workstation)을 이용하는 것입니다.  이
문서는 이러한 기능을 활용할 수 있는 사용자들을 위하여 작성되었습니다.  우리는 때때로 특히 X 윈도우 시스템에서 R을 사용하는
것을 위주로 설명하게 되겠지만, 이러한 설명들은 일반적으로 R을 실행할 수 있는 다른 체제에서도 동일하게 적용하게 됩니다.
</p>
<p>대부분의 사용자들은 이따금 운영체제(operating system)와 직접적으로 작업을 해야 할 필요가 있을 것입니다. 이 문서에서는
주로 UNIX에서 작업하는 것을 가정하고 있습니다.  만약, 윈도우즈(Windows) 또는 OS X에서 R을 사용하는 경우라면 다소
차이가 있을 수 있습니다.
</p>
<p>다소 번거로운 기술적인 조정이 필요하긴 하지만 R이 가진 장점들을 최대한 살리기 위하여 워크스테이션을 설정하는 것은 어렵지
않습니다. 그러나, 본 문서에서는 이러한 내용들을 다루지 않습니다.  만약, 이러한 조정에 어려움을 느끼신다면 주변 전문가에게 도움을
요청하시길 바랍니다.
</p>
<hr>
<a name="R_c744-_b300_d654_c2dd_c73c_b85c-_c0ac_c6a9_d558_ae30"></a>
<a name="Reul-daehwasigeuro-sayonghagi"></a>
<h3 class="section">1.5 R을 대화식으로 사용하기</h3>

<p>R 프로그램을 사용할 때 사용자의 명령어를 입력을 기다린다는 의미의 프롬프트(prompt)를 볼 수 있습니다.  이 프롬프트에 대한
기본설정은 &lsquo;<samp><code>&gt;</code></samp>&rsquo;으로 되어 있습니다.  이 표시는 UNIX에서의 쉘 프롬프트(shell prompt)와도 동일하기도
합니다.  그러나, 다른 모양의 R의 프롬프트를 지정하여 사용할 수도 있습니다.  우리는 이 문서에서 내용의 명확성을 위하여
UNIX의 쉘 프롬프트는 &lsquo;<samp><code>$</code></samp>&rsquo;를 이용하여 표시하도록 하겠습니다.
</p>
<p>UNIX에서 R을 사용하는 경우 다음과 같은 방법으로 실행시킬 수 있습니다:
</p>
<ol>
<li> 먼저 작업을 하게 될 <samp>work</samp>라고 하는 디렉토리를 생성합니다.  이 디렉토리는 R을 이용하면서 사용하게 될 데이터
파일들을 보관하게 됩니다.  이러한 이유로 이를 작업 디렉토리(working directory)라고 합니다.

<div class="example">
<pre class="example">$ mkdir work
$ cd work
</pre></div>

</li><li> 아래의 명령어를 입력하여 R 프로그램을 시작합니다.

<div class="example">
<pre class="example">$ R
</pre></div>

</li><li> 이제부터 R 명령어들을 사용할 수 있습니다 (추후에 보게 될 것입니다).

</li><li> R 프로그램을 종료하기 위해서는 다음의 명령어를 사용합니다.

<div class="example">
<pre class="example">&gt; q()
</pre></div>

<p>이때 현재의 R 세션에서 작업하던 데이터를 저장할 것인지에 대해서 확인하게 됩니다. 일부 시스템에서는 대화상자(dialog
box)를 통하여 이것을 묻게 될 수도 있는데 주로 일반텍스트(text) 형식으로 <kbd>yes</kbd>(예), <kbd>no</kbd>(아니오),
또는 <kbd>cancel</kbd>(취소)가 보여질 것입니다. 이때 첫글자를 이용하여 종료전에 데이터를 저장할 것인지, 저장하지 않고 종료할
것인지, 혹은 다시 작업중인 R 세션으로 돌아갈 것인지 선택할 수 있습니다.  저장된 데이터는 다음에 사용될  R 세션에서
다시 사용할 수 있습니다.
</p>
</li></ol>

<p>이렇게 프로그램을 종료 한 뒤 새로운 R 세션을 시작하는 것은 간단합니다.
</p>
<ol>
<li> 위에서 해 보았던 것과 같이 <samp>work</samp>라는 작업디렉토리를 생성하고 다음과 같이 프로그램을 시작할 수 있습니다:

<div class="example">
<pre class="example">$ cd work
$ R
</pre></div>

</li><li> R 프로그램을 사용하고 난 뒤, 세션의 맨 마지막에서 <code>q()</code> 명령어를 이용하여 종료할 수 있습니다.

</li></ol>

<p>윈도우즈 환경에서 R을 사용하기 방법은 기본적으로 UNIX에서 R을 사용하는 방법과 동일합니다.  먼저 작업디렉토리로 사용될
폴더(folder)를 생성한뒤, <samp>Start In</samp> 메뉴에서 R 바로가기를 생성합니다.  이제 생성된 아이콘을
더블클릭함으로서 R을 실행할 수 있습니다.
</p>
<a name="sogae-sesyeon_0028introductory-session_0029"></a>
<h3 class="section">1.6 소개 세션(introductory session)</h3>

<p>R을 사용하는데 좀 더 빠르게 익숙해지길 희망하는 독자라면 제일 먼저 <a href="#A-sample-session">A sample session</a>이라는 부록에 있는
소개세션(introductory session)을 따라해보기를 적극 권장합니다.
</p>
<hr>
<a name="g_t_b3c4_c6c0_b9d0-_ae30_b2a5-_c0ac_c6a9_d558_ae30"></a>
<a name="hamsu_0028functions_0029wa-gineung_0028features_0029e-daehan-doummal-sayonghagi"></a>
<h3 class="section">1.7 함수(functions)와 기능(features)에 대한 도움말 사용하기</h3>
<a name="index-help"></a>

<p>R은 UNIX에서 <code>man</code> 명령어를 이용하여 도움말을 찾는 것과 유사한 기능을 가지고 있습니다. 예를 들어,
<code>solve</code>라는 특정한 이름을 가진 함수에 대한 정보를 알고 싶다면, 다음과 같이 명령해 보도록 합니다.
</p>
<div class="example">
<pre class="example">&gt; help(solve)
</pre></div>
<a name="index-help-1"></a>

<p>다음은 또 다른 방법입니다.
</p>
<div class="example">
<pre class="example">&gt; ?solve
</pre></div>
<a name="index-_003f"></a>

<p>특수문자(special character)에 대해서 알고 싶다면, &ldquo;문자열(character string)&rdquo;과 같은 형식으로 반드시
큰따옴표(double quotes) 또는 작은따옴표(single quotes)를 문자열의 앞뒤로 함께 사용해주어야 합니다:  이것은 또한
<code>if</code>, <code>for</code>, 그리고 <code>function</code>과 같은 구문적의미를 가지는 키워드인 경우에도 요구됩니다.
</p>
<div class="example">
<pre class="example">&gt; help(&quot;[[&quot;)
</pre></div>

<p><code>&quot;It's important&quot;</code>에서 볼 수 있는 것과 같이 인용부호(quote mark)의 종류에 관계없이 문자열을 둘러싼
인용부호는 문자열 내에 포함된 다른종류의 인용부호를 표현할 수 있게 해줍니다.  일반적으로 권장되는 방법은 큰 따음표(double
quote marks)를 문자열을 둘러싸는 인용부호로 사용하는 것입니다.
</p>
<p>대부분의 경우 설치된 R로부터 <acronym>HTML</acronym>의 형식을 가진 도움말을 다음과 같은 방법으로 사용할 수 있습니다
</p>
<div class="example">
<pre class="example">&gt; help.start()
</pre></div>
<a name="index-help_002estart"></a>

<p>이것은 하이퍼링크를 이용하여 도움말 페이지들을 살펴볼 수 있는 웹브라우저(Web browser)를 실행시킬 것입니다.UNIX에서는 차후에
일어나는 도움말에 대한 요청들은 <acronym>HTML</acronym>기반의 도움말 시스템에 보내어집니다.<code>help.start()</code>에 의하여 불러들인
페이지 내에 있는 &lsquo;Search Engine and Keywords&rsquo;라는 링크는 매우 유용합니다.그 이유는 사용가능한 함수들을 철저하게
검색하는 고수준의 개념목록(high-level concept list)를 포함하고 있기 때문입니다.이것은 또한 시스템을 살펴볼 수 있는
뛰어난 방법이며 어떤 것들이 R에서 제공되는지를 이해할 수 있는 방법이기도 합니다.
</p>
<a name="index-help_002esearch"></a>
<p><code>help.search</code> 명령어 (다른 표현으로는 <code>??</code>)는 다양한 방법으로 도움말을 검색하도록 해줍니다. 예를들면,
다음과 같습니다.
</p>
<div class="example">
<pre class="example">&gt; ??solve
</pre></div>
<a name="index-_003f_003f"></a>

<p>더 자세한 내용 및 많은 예제들을 확인하기 위해서는 <code>?help.search</code>를 입력해 보길 바랍니다.
</p>
<p>검색한 도움말과 관련된 예제는 일반적으로 다음과 같은 방법으로 실행해 볼 수 있습니다.
</p>
<div class="example">
<pre class="example">&gt; example(<var>topic</var>)
</pre></div>
<a name="index-example"></a>

<p>윈도우즈 버전의 R을 사용하는 경우 도움말을 사용할 수 있는 또 다른 방법이 있습니다:
</p>
<div class="example">
<pre class="example">&gt; ?help
</pre></div>

<p>위의 명령어를 입력함으로서 더 자세한 사항을 확인해 볼 수 있습니다.
</p>
<hr>
<a name="R-_ba85_b839_c5b4-_bc0f-_b300_c18c_bb38_c790_c758-_ad6c_bd84_acfc-_ac19_c740-_b0b4_c6a9_b4e4"></a>
<a name="R-myeongryeongeo-mic-daesomunjayi-gubungwa-gateun-naeyongdeul"></a>
<h3 class="section">1.8 R 명령어 및 대소문자의 구분과 같은 내용들</h3>

<p>기술적인 측면에서 말하자면 R은 아주 간단한 문법(syntax)를 가진 표현언어(<em>expression
language</em>)이라고 할 수 있습니다.UNIX를 기반으로 하는 대부분의 패키지들과 같이 대소문자를 구별(<em>case
sensitive</em>)합니다.따라서, <code>A</code>와 <code>a</code>는 서로 다른 기호(symbol)로 인식되어 다른 변수를 가리키게
됩니다.R에서 사용할 수 있는 기호들은 사용자의 운영체제 및 R이 현재 실행되고 있는 국가설정(좀 더 기술적으로 말하자면
사용되고 있는 로케일(<em>locale</em>))에 따라 달라질 수 있습니다.기본적으로 모든 알파벳 기호들이
사용가능합니다<a name="DOCF2" href="#FOOT2"><sup>2</sup></a> (그리고 일부국가에서는 이것은 엑센트를 가진 문자를 포함하기도 합니다)  또한, &lsquo;<samp><code>.</code></samp>&rsquo;와
&lsquo;<samp><code>_</code></samp>&rsquo;을 함께 조합하여 사용할 수 있습니다.  그러나, 변수명은 반드시 &lsquo;<samp><code>.</code></samp>&rsquo; 또는
문자(letter)을 이용하여 시작해야 합니다.만약 변수명이 &lsquo;<samp><code>.</code></samp>&rsquo;로 시작한다면 바로뒤에 이어지는 두번째 문자는
반드시 숫자(digit)가 아닌 문자가 와야 합니다.실제적으로 변수명이 가질 수 있는 길이에는 제한이 없습니다.
</p>
<p>기초적인 명령문(commands)은 표현식(<em>expressions</em>) 또는 할당(<em>assignment</em>) 둘 중의
하나로 이루어지게 됩니다. 만약 표현식이 하나의 명령으로서 주어지는 경우, 이 표현식에 대한 평가(evaluate)가 이루어지게 되고
평가된 값은 (특별히 보이지 않도록 처리되지 않는한) 출력되게 됩니다. 그리고 이렇게 평가된 값은 어디에도 저장되지 않고 사라집니다.
할당의 경우 역시 주어진 표현식을 평가한 뒤 평가된 값을 어떤 변수에 저장하도록 넘겨주지만 그 값은 자동으로 출력되지 않습니다. 
</p>
<p>명령문은 세미콜론(&lsquo;<samp><code>;</code></samp>&rsquo;) 또는 새로운 행(newline, 또는 개행)에 의하여 구분됩니다. 기본적인 명령문들은 한
쌍의 열린 중괄호(&lsquo;<samp><code>{</code></samp>&rsquo;와 &lsquo;<samp><code>}</code></samp>&rsquo;)에 의하여 하나의 복합표현식(compound
expression)으로 묶을 수 있습니다.주석(<em>comments</em>)은 프로그램상의 어느 곳<a name="DOCF3" href="#FOOT3"><sup>3</sup></a>에나 놓일 수 있습니다.이것은 해쉬마크(hashmark,
&lsquo;<samp><code>#</code></samp>&rsquo;)가 사용된 지점부터 시작하여 라인의 끝부분까지 놓인 모든 것들을 주석처리합니다.
</p>
<p>만약 명령문이 한 줄에 모두 다 입력되지 않고 다음 행으로 계속 이어지게 된다면, R은 다른 모양의 프롬프트를 보여줄 것입니다.
아래에 보여지는 기호가 현재 기본적으로 설정되어 있습니다.
</p>
<div class="example">
<pre class="example">+
</pre></div>

<p>이 기호는 명령문이 문법적으로 완성될 때까지 두번째 그리고 그 이후의 줄에도 계속 표시되며 입력을 계속해서 받아들이게 됩니다.이
프롬프트는 사용자에 의하여 변경될 수 있습니다.우리는 이 문서에 컨티뉴에이션 프롬프트(continuation prompt)를 생략하고
간단한 들여쓰기(indenting)를 함으로서 명령어가 계속 이어짐(continuation)을 나타낼 것입니다.
</p>
<p>콘솔(console) 내에서 입력할 수 있는 명령어 라인(command lines)의 길이는 대략 4095 바이트(bytes)로 제한
됩니다 (문자의 개수를 의미하는 것이 아닙니다). <a name="DOCF4" href="#FOOT4"><sup>4</sup></a>
</p>
<hr>
<a name="g_t_c774_c804_c758-_ba85_b839_c5b4_b97c-_bd88_b7ec_c640-_c218_c815_d558_ae30"></a>
<a name="ijeonyi-myeongryeongeoreul-bulreowa-sujeonghagi"></a>
<h3 class="section">1.9 이전의 명령어를 불러와 수정하기</h3>

<p>다양한 버전의 UNIX와 윈도우즈 환경아래에서 실행되는 R은 이전에 사용되었던 명령어들을 다시 불러(recalling)들여 이를
재실행(re-executing) 할 수 있는 매커니즘(mechanism)을 가지고 있습니다.  키보드에서 위 또는 아래로 이동하는 화살표
키를 사용하여 이전에 실행한 명령어들의 이력(<em>command history</em>)을 앞뒤로 살펴볼 수있습니다.  이러한 방법으로
명령어를 선택한 뒤에 좌 또는 우로 이동하는 화살표키를 이용하여 커서를 이동시킵니다. 그리고 <tt class="key">DEL</tt>를 이용하여 문자를 지우거나
다른 키를 이용하여 입력할수도 있습니다.  더 자세한 내용은 see <a href="#The-command_002dline-editor-_0028_ba85_b839_c5b4_b77c_c778-_d3b8_c9d1_ae30_0029">The command-line editor (명령어라인 편집기)</a> 을 살펴보시길 바랍니다.
</p>
<p>UNIX 환경에서는 불러오고 수정하는 기능들을 매우 쉽게 사용자에 맞추어 조정할 수 있습니다.  이러한 조정방법에 대해서는
<strong>readline</strong> 라이브러리내 관련 매뉴얼 항목에서 찾을 수 있습니다. 
</p>
<p>더 나아가, 이맥스(Emacs)라는 텍스트 편집기(text editor)는 R과 소통하며 작업을 할 수 있도록
(<acronym>ESS</acronym>(<em>Emacs Speaks Statistics</em>)를 통하여) 보다 일반적인 지원 메카니즘(support
mechanism)을 제공하고 있습니다.  See <a href="R-FAQ.html#R-and-Emacs">R and Emacs</a> in <cite>The R statistical
system FAQ</cite>를 살펴보시길 바랍니다.
</p>
<hr>
<a name="g_t_d30c_c77c_c5d0-_c791_c131_b41c-_ba85_b839_c5b4_b97c-_c2e4_d589_d558_ac70_b098-_cd9c_b825_bc29_d5a5_c744-_d30c_c77c_b85c-_bcc0_acbd_d558_ae30"></a>
<a name="paile-jagseongdoen-myeongryeongeoreul-silhaenghageona-culryeogbanghyangeul-pailro-byeongyeonghagi"></a>
<h3 class="section">1.10 파일에 작성된 명령어를 실행하거나 출력방향을 파일로 변경하기</h3>
<a name="index-oebupaile-jeojangdoen-myeongryeong-silhaeng-mic-oebupailro-gyeolgwa-jeojanghagi"></a>

<p>이제 명령어들이 <samp>commands.R</samp>이라는 외부파일에 저장되어 있고, 이 파일은 <samp>work</samp>라는 작업
디렉토리(working directory)에 놓여있다고 가정해 봅니다.  이 명령어들은 R 세션내에서 다음의 명령어를 이용하여
언제든지 실행될 수 있습니다.
</p>
<div class="example">
<pre class="example">&gt; source(&quot;commands.R&quot;)
</pre></div>
<a name="index-source"></a>

<p>윈도우즈 환경에서는 <strong>File</strong> 메뉴에 놓여 있는 <strong>Source</strong> 항목을 이용하여 동일한 작업을 수행할 수
있습니다.다음에 보여지는 함수 <code>sink</code>는 출력방향을 콘솔로부터 <samp>record.lis</samp>이라는 외부파일로 변경하여
추후에 생성되는 결과물들이 외부파일에 저장될 수 있도록 해줍니다.
</p>
<div class="example">
<pre class="example">&gt; sink(&quot;record.lis&quot;)
</pre></div>
<a name="index-sink"></a>

<p>위와 같이 명령하게 되면 출력의 방향을 다시 콘솔로 향하도록 합니다.
</p>
<div class="example">
<pre class="example">&gt; sink()
</pre></div>

 

<hr>
<a name="g_t_c601_ad6c_c801-_b370_c774_d130-_c0dd_c131-_bc0f-_ac1d_ccb4_c758-_c81c_ac70"></a>
<a name="yeonggujeog-deiteo-saengseong-mic-gaegceyi-jegeo"></a>
<h3 class="section">1.11 영구적 데이터 생성 및 객체의 제거</h3>

<p>R에서 생성하고 다루게 되는 대상들은 객체(<em>objects</em>)라고 알려져 있습니다. 이것은 변수(variables),
숫자로 이루어진 배열(arrays of numbers), 문자열(character strings), 함수(functions)가 될 수도
있고, 또는 이러한 요소들로 이루어진 좀 더 일반적인 구조(structure)가 될 수도 있습니다.
</p>
<p>R 세션 내에서 이러한 객체들은 이름(name)을 가지게 됨으로서 생성되거나 저장되어집니다 (우리는 이 과정을 다음 섹션에서 설명할
것입니다).다음의 R 명령어 (또는 <code>ls()</code>)를 이용하여 현재 R에서 사용중인 (대부분의) 객체들의 이름을 나열해
볼 수 있습니다. 
</p>
<div class="example">
<pre class="example">&gt; objects()
</pre></div>

<p>이렇게 현재 사용중인 객체들이 저장되어 있는 공간을 작업공간(<em>workspace</em>)이라고 합니다. 
<a name="index-Workspace"></a>
</p>
<p>객체들을 삭제하기 위해서는 함수 <code>rm</code>를 사용할 수 있습니다.
</p>
<div class="example">
<pre class="example">&gt; rm(x, y, z, ink, junk, temp, foo, bar)
</pre></div>
<a name="index-rm"></a>
<a name="index-Removing-objects"></a>

<p>R 세션 내에서 생성된 모든 객체들은 하나의 파일형태로 영구저장되어 다음 세션에서 사용할 수 있습니다.각 R 세션의 마지막에서
현재 사용중인 모든 객체들을 저장할 수 있는 기회가 사용자에게 주어집니다.만약 객체들을 저장하고자 한다면, 객체들은
<samp>.RData</samp><a name="DOCF5" href="#FOOT5"><sup>5</sup></a>이라는 파일에 쓰여진 뒤 현재의 작업 디렉토리에 저장됩니다. 그리고 세션내에서
사용된 명령어 라인들은 <samp>.Rhistory</samp>라는 파일에 저장되게 됩니다. 
</p>
<p>추후에 같은 디렉토리에서 R이 실행된다면 이 파일로부터 이전에 저장된 작업공간(workspace)을 다시 불러오게 됩니다.  이와
동시에 이전 세션에서 사용한 명령어들의 이력 역시 함께 불러들여집니다.
</p>
<p>R을 이용하여 여러 개의 분석을 수행하는 경우, 각각의 분석 별로 다른 작업 공간을 이용하는 것이 좋습니다.  그 이유는 분석을
하는 동안 <code>x</code>와 <code>y</code> 같은 이름을 가진 객체를 생성하는 경우가 흔하기 때문입니다.만약 하나의 분석만을 하는
경우에는 이러한 종류의 이름을 사용하는 것은 종종 의미가 있을 수 있으나, 여러 개의 분석이 같은 디렉토리내에서 이루어지게 되는 경우에는
이러한 이름을 가진 객체들이 각각의 분석에서 어떤 의미를 가지고 사용되는지를 알아차리는 것이 쉽지 않을 수 있습니다.
</p>
<hr>
<a name="Simple-manipulations-numbers-and-vectors"></a>
<a name="susjawa-begteoe-daehan-gico-jojagbeob"></a>
<h2 class="chapter">2 숫자와 벡터에 대한 기초 조작법</h2>
<a name="index-Vectors"></a>


<hr>
<a name="g_t_bca1_d130_c640-_d560_b2f9"></a>
<a name="begteowa-haldang"></a>
<h3 class="section">2.1 벡터와 할당</h3>

<p>R은 이름이 주어진 <em>data structures</em>(데이터 구조)을 이용하여 작업을 하게 됩니다.  이러한 구조를 가진
가장 단순한 형태는 이용하여 라는 것을 기반으로 작동합니다.  가장 단순한 데이터의 구조는 임의의 숫자들의 정렬인 숫자형
(numeric) <em>vector</em>(벡터)입니다.예를들어, 10.4, 5.6, 3.1, 6.4, 그리고 21.7 라는 일련의
숫자로 <code>x</code>라는 이름을 가진 벡터를 생성하기 위해서는 다음과 같은 R 명령어를 입력합니다
</p>
<div class="example">
<pre class="example">&gt; x &lt;- c(10.4, 5.6, 3.1, 6.4, 21.7)
</pre></div>
<a name="index-c"></a>
<a name="index-vector"></a>

<p>위에서 사용된 표현식을 <em>assignment statement</em>(할당문) 이라고 하며, 여기서 사용된 <code>c()</code>라는
<em>function</em>(함수)는 함수 안에 입력된 여러 개의 임의의 숫자들을 하나로 연결하여 하나의 벡터를
생성합니다. <a name="DOCF6" href="#FOOT6"><sup>6</sup></a>
</p>
<p>어떤 식(expression) 에서 자체로 있는 하나의 숫자는 길이가 1인 벡터로 취급됩니다.
</p>
<p>또한, 띄어쓰기 없이 &lsquo;<samp><code>&lt;</code></samp>&rsquo;(부등호, 좌측이 우측보다 작음을 표시하는 수학적 기호) 와
&lsquo;<samp><code>-</code></samp>&rsquo;(음수를 나타내는 기호)를 붙여 써서 만든 &lsquo;<samp><code>&lt;-</code></samp>&rsquo; 라는 기호는 할당
연산자(assignment operator)라고 하며, 이 기호의 오른쪽의 표현식에 의해 생성된 값을 갖는 객체를 왼쪽의 이름을 갖도록
지정합니다. 대부분의 경우 &lsquo;<samp><code>=</code></samp>&rsquo; 연산자를 같은 작업을 이용하여 할 수 있습니다.
<a name="index-Assignment"></a>
</p>
<p>할당(Assignment) 작업은 <code>assign()</code> 함수를 통해서도 이루어질 수 있습니다. 위에서 수행한 것과 동일한 연산을
아래와 같은 방법으로도 할 수 있습니다. 
</p>
<div class="example">
<pre class="example">&gt; assign(&quot;x&quot;, c(10.4, 5.6, 3.1, 6.4, 21.7))
</pre></div>

<p>여러분은 할당 연산자 <code>&lt;-</code>를 단순히 <code>assign()</code> 함수와 같은 작업을 하는, 문법적으로는 더 쉬운
방법(short-cut)이라고 생각하셔도 됩니다.
</p>
<p>또, 이 할당 연산자의 방향을 바꾸어 아래와 같은 방법으로 사용할 수도 있습니다.
</p>
<div class="example">
<pre class="example">&gt; c(10.4, 5.6, 3.1, 6.4, 21.7) -&gt; x
</pre></div>

<p>만약 아래와 같이 할당 연산자를 사용하지 않고 표현식만으로 명령문을 작성하면, 결과물은 출력 되지만, 이 값이 저장되지 않아
<em>다시 불러 낼 수 없습니다</em>. <a name="DOCF7" href="#FOOT7"><sup>7</sup></a>.
</p>
<div class="example">
<pre class="example">&gt; 1/x
</pre></div>

<p>이제 위의 명령문을 실행하여 (위에서 할당한) <code>x</code>의  다섯 개 숫자의 역수 다섯 개를 출력 해 봅시다. 
</p>
<p>다음은 여기에 할당 연산자를 적용해보도록 합니다.
</p>
<div class="example">
<pre class="example">&gt; y &lt;- c(x, 0, x)
</pre></div>

<p>다음의 할당문은 2개의 <code>x</code> 벡터 사이에 0 을 입력한, 총 11개의 숫자로 구성된 <code>y</code> 라는 새로운 벡터를 생성
합니다.
</p>
<hr>
<a name="g_t_bca1_d130-_c5f0_c0b0"></a>
<a name="begteo-yeonsan"></a>
<h3 class="section">2.2 벡터 연산</h3>

<p>벡터(vector)는 요소 단위의 (element by element) 산술연산 표현식(arithmetic expression)에 사용
가능 합니다. 이 때, 같은 (산술) 표현식 내의 벡터들이 모두 같은 길이를 가질 필요는 없습니다.만약, 벡터들의 길이가 다르면 가장 긴
길이의 벡터를 기준으로, 상대적으로 짧은 길이를 갖는 벡터는 긴 벡터의 길이에 맞추기 위해 그 구성 요소를
재활용(<em>recycled</em>)하여 연산을 수행 합니다. 즉, 더 짧은 길이의 벡터는 가장 긴 벡터와 같은 길이를 같도록 구성
요소를 필요한 만큼 (경우에 따라서는 일부만) 반복 사용 합니다. 특히, 벡터의 길이가 1인 상수(constant)를 벡터와의 연산에
사용할 경우, 이 상수가 벡터의 길이만큼 반복되서 사용 됩니다.
<a name="index-Recycling-rule"></a>
</p>
<div class="example">
<pre class="example">&gt; v &lt;- 2*x + y + 1
</pre></div>

<p>위의 예제를 이용해서 설명하면, 다음 명령문을 실행하면 R은 연산을 하기 전 <code>x</code>의 길이를 <code>y</code>에 맞추기
위해서 그 구성 요소를 대략 2.2 번 반복하여 길이 11의 벡터를 만듭니다. 그리고, 2를 <code>x</code> 의 각 요소에 곱한 뒤
(11번의 곱하기 연산이 필요합니다), <code>y</code>의 각 요소와 더하기 연산을 수행합니다. 마지막으로 상수 <code>1</code>과의 더하기
연산 역시 11 번에 걸쳐 수행하며, 이렇게 벡터의 각 요소별로 수행된 연산의 결과는 길이 11의 벡터인 <code>v</code>에 할당
됩니다. 
</p>
<a name="index-Arithmetic-functions-and-operators"></a>
<p>요소 단위 기본 연산자는 <code>+</code>(더하기), <code>-</code>(빼기), <code>*</code>(곱하기), <code>/</code>(나누기), 그리고
<code>^</code>(자승) 입니다.
<a name="index-_002b"></a>
<a name="index-_002d"></a>
<a name="index-_002a"></a>
<a name="index-_002f"></a>
<a name="index-_005e"></a>
일반적인 수학 연산에 자주 사용되는 <code>log</code>, <code>exp</code>, <code>sin</code>, <code>cos</code>,
<code>tan</code>, <code>sqrt</code>와 같은 함수가 모두 제공되며, 수학에서 사용하는 것과 동일한 방법으로 사용 됩니다. 
<a name="index-log"></a>
<a name="index-exp"></a>
<a name="index-sin"></a>
<a name="index-cos"></a>
<a name="index-tan"></a>
<a name="index-sqrt"></a>
<code>max</code>와 <code>min</code>는 벡터의 구성요소들 중에서 가장 큰 값과 작은 값을 보여주는 함수입니다. 
<a name="index-max"></a>
<a name="index-min"></a>
<code>range</code> is a function whose value is a vector of length two, namely
<code>c(min(x), max(x))</code>.
<a name="index-rangeneun-jueojin-begteo-xyi-modeun-guseongyoso-jung-coesogabsgwa-coedaegabseul-c_0028min_0028x_0029_002c-max_0028x_0029_0029yi-hyeongtaero-culryeoghamyeo_002c-ireum-geudaero-begteo-byeonsuyi-beomwireul-guhal-ddae-sayong-habnida_002e"></a>
<code>length(x)</code>는 벡터 <code>x</code> 의 구성요소가 몇 개인가를 알려주며, 이를 보통 <code>x</code>의 길이라고 합니다.
<a name="index-length"></a>
<code>sum(x)</code>는 <code>x</code>의 모든 구성요소들의 합을 구하고자 할 때 사용하고, 
<a name="index-sum"></a>
<code>prod(x)</code>는 모든 구성요소들의 곱을 구할 때 이용됩니다.
<a name="index-prod"></a>
</p>
<p>R에서는 통계학에서 자주 이용되는 평균과 분산을 계산하는 함수들도 제공됩니다.샘플 평균(sample mean)은
<code>sum(x)/length(x)</code>으로 계산 되는데, <code>mean(x)</code>를 사용해서도 같은 결과를 얻을 수 있습니다. 
<a name="index-mean"></a>
그리고, 샘플 분산(sample variance)은 아래와 같은 공식을 통해 계산하는데, 이 역시 <code>var(x)</code>를 사용하면
아주 간단하게 계산할 수 있습니다. 
</p>
<div class="example">
<pre class="example">sum((x-mean(x))^2)/(length(x)-1)
</pre></div>
<a name="index-var"></a>

<p>만약, <code>var()</code> 에 사용되는 입력인자(argument)가 <em>n</em>-by-<em>p</em> 크기의 행렬이라면,
입력인자가<em>p</em>개의 변수들에 대한 <em>n</em> 개의 관측치를 갖는 데이터로 인식되어 <em>p</em>-by-<em>p</em>
크기의 샘플 공분산 행렬(sample covariance matrix)을 계산 합니다. 
</p>
<p><code>sort(x)</code>는 벡터 <code>x</code>를 인자로 받아 <code>x</code>의 모든 구성요소들을 오름차순(increasing
order, 즉, 작은 값에서 큰 값의 순서로)으로 재배열하여 <code>x</code>와 같은 길이의 벡터를 출력하는 함수 입니다. 이와 비슷한
다른 정렬 함수들 역시 매우 유용하며, 가장 빈번하게 사용되는 예로는 인자로 사용된 <code>x</code> 벡터의 정렬 순서를 확인하기 위해
<code>order()</code> 또는 <code>sort.list()</code>를 사용하는 것을 들 수 있습니다.
<a name="index-sort"></a>
<a name="index-order"></a>
</p>
<p><code>max</code>와 <code>min</code>에 여러 개의 벡터가 동시에 입력인수로 사용되었을지라도, 입력된 모든 구성요소들 중에서 최대값과
최소값 하나씩 만을 출력합니다.만약, 여러 개의 벡터 입력인자들을 동시에 입력해서 최대값과 최소값의 병렬(<em>parallel</em>
원한다면, 즉 입력된 여러 개 벡터 인자들을 입력순서 별 최대값 혹은 최소값을 찾는 과정) 원한다면, <code>pmax</code>와
<code>pmin</code> 함수를 각각 이용할 수 있습니다. 이 때 반환되는 벡터의 길이는 입력 인자들 중에서 가장 길이가 긴 벡터와
동일합니다. (즉, 길이가 다른 벡터들의 입력시, 길이가 짧은 벡터와 긴 벡터의 비교가 불가능한 구간에서는 오직 비교 가능한 벡터들끼리만
비교해서, 혹은 가장 길기가 긴 벡터의 구성요소를 그대로 출력하게 됩니다).  
<a name="index-pmax"></a>
<a name="index-pmin"></a>
</p>
<p>대부분의 연산에서, 숫자형 벡터(numeric vector)의 구성요소인 &ldquo;numbers&rdquo;(숫자)의 종류가 정수(integer)인지,
실수(real)인지, 또는 허수(complex)인지는 중요하지 않습니다. R은 자체적으로 입력된 벡터가 실수인 경우 double
precision을 갖는 실수로, 복소수(허수)이면 double precision을 갖는 복소수로 연산을 수행할 수 있습니다. 
</p>
<p>단, 복소수 연산의 경우, 어느 부분이 허수 부분(copmlex part)인지는 정확히 명시해주어야 합니다. 
</p>
<div class="example">
<pre class="example">sqrt(-17)
</pre></div>

<p>아래 예시와 같이 허수 부분이 지정하지 않고 명령문을 사용하면, <code>NaN</code> 값과 경고(warning) 메시지가 출력 될
것입니다.
</p>
<div class="example">
<pre class="example">sqrt(-17+0i)
</pre></div>

<p>따라서, 다음과 같이 명령문을 입력해야 복소수 연산이 올바르게 수행 됩니다. 
</p>

<hr>
<a name="Generating-regular-sequences-_0028_addc_ce59_c131_c744-_c9c0_b2cc-_c77c_b828_c758-_c22b_c790_b4e4_c744-_c0dd_c131_d558_ae30_0029"></a>
<a name="Generating-regular-sequences-_0028gyucigseongeul-jinin-ilryeonyi-susjadeuleul-saengseonghagi_0029"></a>
<h3 class="section">2.3 Generating regular sequences (규칙성을 지닌 일련의 숫자들을 생성하기)</h3>
<a name="index-Regular-sequences"></a>

<p>R은 수열 (sequence)을 생성하는 다양한 방법을 제공합니다.예를 들면, <code>1:30</code>이라는 명령어는
<code>c(1, 2, &hellip;, 29, 30)</code>과 같은 벡터를 생성합니다.
<a name="index-_003a"></a>
또 R의 표현식에서는 콜론(colon) 연산자가 다른 어떤 연산 보다 최우선으로 처리됩니다. 예를 들면, <code>2*1:15</code>은
<code>c(2, 4, &hellip;, 28, 30)</code>과 같은 벡터를 생성합니다. 좀 더 정확한 이해를 위해, <code>n &lt;-
10</code>을 입력한 뒤, <code>1:n-1</code>과 <code>1:(n-1)</code>로부터 생성되는 두개의 벡터를 비교해보시길 바랍니다.
</p>
<p>또 <code>30:1</code>이라는 명령문은 역순으로 (큰 수부터 작은 수로) 나열된 수열을 생성합니다.
</p>
<a name="index-seq"></a>
<p><code>seq()</code> 함수는 수열을 생성하는 좀 더 일반적인 방법 입니다. <code>seq()</code>는 5개의 파라미터를 가질 수 있는데,
이중의 일부만 사용해도 다양한 수열의 생성이 가능합니다.먼저, 처음 두개의 파라미터는 수열의 처음과 마지막 값을 지정합니다.이 두 개의
인자만 지정하면, 콜론 연산자를 사용한 것과 동일한 결과를 얻게 됩니다. 즉, <code>seq(2,10)</code>에 의하여 생성된 수열은
<code>2:10</code>으로부터 생성된 수열과 동일합니다. 
</p>
<p>R의 다른 많은 함수들처럼 함수 <code>seq()</code>가 사용하는 파라미터들은 반드시 함수에 지정된 순서로 입력되야 하며, 이
지정된 순서를 따를 경우 파라미터의 입력이 언뜻 이상하게 보일 수도 있습니다. 위에서 사용한 예제 <code>seq(1,30)</code>를 통해
설명하면, <code>seq()</code>의 처음 두 파라미터들은 처음 시작값 <code>from=<var>value</var></code>과 마지막 값
<code>to=<var>value</var></code>을 각각 의미하기 때문에, <code>seq(1,30)</code>, <code>seq(from=1,
to=30)</code>, <code>seq(to=30, from=1)</code> 모두 <code>1:30</code>으로부터 생성된 수열과 동일한 수열을
생성합니다.<code>seq()</code>의 다음 두개(세번째와 네번째)의 파라미터들은 <code>by=<var>value</var></code>와
<code>length=<var>value</var></code> 입니다. <code>by=<var>value</var></code>는 나열하게 될 숫자들 간의 차이 (step
size)를 지정하며, <code>length=<var>value</var></code>는 나열하게 될 숫자의 길이(length)를 지정합니다. 만약, 이
두가지 모두 지정되지 않는다면, 기본적으로  <code>by=1</code>를 가정한 상태에서 수열을 생성하게 됩니다. 
</p>
<p>다음의 예시를 살펴봅니다.
</p>
<div class="example">
<pre class="example">&gt; seq(-5, 5, by=.2) -&gt; s3
</pre></div>

<p>위 명령어를 실행하면 <code>c(-5.0, -4.8, -4.6, &hellip;, 4.6, 4.8, 5.0)</code>라는 수열을 생성하여,
이를 <code>s3</code>라는 이름의 벡터형 객체로 저장하게 됩니다.
</p>
<div class="example">
<pre class="example">&gt; s4 &lt;- seq(length=51, from=-5, by=.2)
</pre></div>

<p>아래와 같은 방법으로도 <code>s3</code>와 같은 벡터 <code>s4</code>를 생성할 수 있습니다.
</p>
<p>마지막으로 <code>seq()</code> 함수의 다섯번 째 파라미터는 <code>along=<var>vector</var></code>이며, 다른 파라이터의 입력
없이 이 파라미터만 사용할 경우, <code>1, 2, &hellip;, length(<var>vector</var>)</code>인 수열을 생성 합니다. 
</p>
<p>A related function is <code>rep()</code>
<a name="index-rep"></a>
<code>seq()</code>와 비슷한 수열 생성 함수 중, 객체를 반복하는데 사용할 수 있는 <code>rep()</code>라는 함수가 있습니다. 이
함수의 사용법은 아래와 같습니다.
</p>
<div class="example">
<pre class="example">&gt; s5 &lt;- rep(x, times=5)
</pre></div>

<p>위 명령어는 <code>x</code>라는 벡터를 처음부터 끝까지 5번 반복해서 나열한 객체를 <code>s5</code>로 지정 합니다.위 함수와 같은
결과를 얻기 위해 아래와 같은 명령문을 사용할 수도 있습니다.
</p>
<div class="example">
<pre class="example">&gt; s6 &lt;- rep(x, each=5)
</pre></div>

<p>둘 다 <code>x</code>란 벡터가 가지고 있는 각각의 요소들을 5번씩 반복 나열하여 수열을 생성 합니다.
</p>
<hr>
<a name="g_t_b17c_b9ac_d615-_bca1_d130"></a>
<a name="nonrihyeong-begteo"></a>
<h3 class="section">2.4 논리형 벡터</h3>

<p>R은 수치형 벡터 뿐만 아니라 논리값에 대한 연산도 가능합니다.논리형 벡터는 <code>TRUE</code>, <code>FALSE</code>, 그리고
<code>NA</code> (즉 &ldquo;not available&rdquo; - 해당 값이 이용가능하지 않아 사용에는 많은 제약이 따름)와 같은 요소로 구성
됩니다.처음 두 개의 요소인 <code>TRUE</code>와 <code>FALSE</code>가 각각 <code>T</code>와 <code>F</code>라는 약어로 표기하기도
하며, 이러한 약어 사용은 R에서 초기값으로 지정된 것입니다. 하지만, 사용자가 이 두 문자를 다른 변수나 함수 이름으로 사용할 경우,
더 이상 이러한 초기 약어 지정은 성립하지 않습니다. 따라서, 논리값을 표현할 때에는 <code>TRUE</code>와 <code>FALSE</code>와
같이 정확하게 표기할 것을 권장 합니다. 
<a name="index-FALSE"></a>
<a name="index-TRUE"></a>
<a name="index-F"></a>
<a name="index-T"></a>
</p>
<p>논리형 벡터는 조건문 (<em>conditions</em>)에 의해서 생성됩니다.
</p>
<div class="example">
<pre class="example">&gt; temp &lt;- x &gt; 13
</pre></div>

<p>예를 들어 아래의 명령문을 입력하면, <code>x</code> 벡터의 각 구성요소에 대해 13 보다 크다는 조건문이 참인지 거짓인지를 판단하여,
해당 구성 요소가 13 보다 큰 위치에는 <code>TRUE</code>, 그렇지 않은 경우에는 <code>FALSE</code>를 출력하여 원래의
<code>x</code>와 같은 길이를 갖는 새 벡터<code>temp</code>를 생성 합니다. 
</p>
<p>논리 연산자에는 <code>&lt;</code> (작음), <code>&lt;=</code> (작거나 같음), <code>&gt;</code> (큼), <code>&gt;=</code> (크거나
같음), <code>==</code> (같음), 그리고 <code>!=</code> (다름) 등이 있습니다. 
<a name="index-_003c"></a>
<a name="index-_003c_003d"></a>
<a name="index-_003e"></a>
<a name="index-_003e_003d"></a>
<a name="index-_003d_003d"></a>
<a name="index-_0021_003d"></a>
또한, <code>c1</code>과 <code>c2</code>와 같이 두 개의 논리 표현식이 있는 경우, <code>c1&nbsp;&amp;&nbsp;c2</code><!-- /@w -->는
(<em>&ldquo;and&rdquo;</em>)를 나타내는 교집합을 <code>c1&nbsp;|&nbsp;c2</code><!-- /@w -->는 (<em>&ldquo;or&rdquo;</em>)를 나타내는 합집합을
의미하며, <code>!c1</code>는 <code>c1</code>를 만족하지 않는 차집합을 의미 합니다.
<a name="index-_0021"></a>
<a name="index-_007c"></a>
<a name="index-_0026"></a>
</p>
<p>논리형 벡터들은 일반적인 산술연산에 사용할 수도 있으며, 이 경우 논리값인 <code>FALSE</code>는 숫자 <code>0</code>으로
<code>TRUE</code>는 숫자 <code>1</code>로 변환 되어야 합니다. 이러한 변환을 <em>coerced</em>(강제형변환)이라고
합니다. 그러나 논리형 벡터들이 수치형 벡터로의 강제형변환이 항상 위와 같은 방식으로만 이루어지는 것은 아니며, 여기에 대해서는 다음
섹션에서 살펴보도록 하겠습니다. 
</p>
<hr>
<a name="g_t_acb0_ce21_ac12"></a>
<a name="gyeolceuggabs"></a>
<h3 class="section">2.5 결측값</h3>
<a name="index-gyeolceuggabs"></a>

<p>가끔 벡터의 구성요소들 중 일부가 완전하지 않은 경우가 있습니다.통계적 의미에서 이러한 구성요소 또는 값들은 &ldquo;not
available&rdquo; (사용이 가능하지 않음) 또는 &ldquo;missing value&rdquo;(결측치 혹은 누락된 값)을 의미하며, 이러한 값들은
벡터 내에서 <code>NA</code>라는 특수 문자로 표기 됩니다. 
<a name="index-NA"></a>
일반적으로 어떤 연산이든 <code>NA</code>에 대한 연산의 결과는 <code>NA</code>가 됩니다.이러한 규칙을 만들게 된 동기는
단순합니다. 이러한 결측치의 연산법을 따로 지정하지 않으면, 결측치의 포함으로 인해 해당 연산이 정의되지 않거나 결과가 출력되지 않기
때문입니다. 
</p>
<a name="index-is_002ena"></a>
<p>함수 <code>is.na(x)</code>는 <code>x</code>의 각 구성요소 중 <code>NA</code>가 포함되었는지를 확인하여, 논리값인
<code>TRUE</code>또는 <code>FALSE</code>를 갖는 새로운 벡터를 생성 합니다. 따라서, 생성된 벡터의 길이는 원래 벡터인
<code>x</code>와 같아야 하며, 이는 아래의 명령문을 통해 확인해 볼 수 있습니다. 
</p>
<div class="example">
<pre class="example">&gt; z &lt;- c(1:3,NA);  ind &lt;- is.na(z)
</pre></div>

<p>그러나, <code>NA</code>라는 것은 실제로 단순히 벡터를 구성하는 요소의 값이 사용가능한지에 대한 마커일 뿐 해당 요소에 대한 값이
아니기 때문에 <code>x == NA</code>이라는 논리적 표현식과 <code>is.na(x)</code>는 서로 다른 것을 의미한다는 점을 이해하셔야
합니다. 즉 <code>x == NA</code>는 벡터 <code>x</code>와 길이는 같지만 그 구성요소 <em>모두</em>가 <code>NA</code>값을
가지므로, 이 식 자체가 논리형 표현식이라 어떤 연산을 수행하기에는 불완전하고 불충분하기 때문입니다. 
</p>
<p>또한 수치연산의 결과로서 발생하는 또 다른 종류의 결측치(&ldquo;missing&rdquo;)인 <code>NaN</code>은 <em>Not a
Number</em>(숫자가 아님)을 의미 합니다. 다음의 두 예제를 통해서 좀 더 자세히 알아 봅시다. 
<a name="index-NaN"></a>
values.  Examples are
</p>
<div class="example">
<pre class="example">&gt; 0/0
</pre></div>

<p>or
</p>
<div class="example">
<pre class="example">&gt; Inf - Inf
</pre></div>

<p>위의 두가지 경우 모두 수학적 정의에 따른 계산을 수행할 수 없기 때문에 <code>NaN</code>이라는 결과를 출력하게 됩니다. 
</p>
<p>요약해보면, <code>is.na(xx)</code>는 구성요소 중 하나 이상이 <code>NA</code>이거나 <code>NaN</code>인 두가지 경우 모두
<code>TRUE</code> 값을 돌려줍니다.  그러나, <code>is.nan(xx)</code>은 오직 구성 요소에 <code>NaN</code>이 포함될 때만
<code>TRUE</code>가 됩니다. 
<a name="index-is_002enan"></a>
</p>
<p>때때로 이렇게 <code>&lt;NA&gt;</code>로 표시된 값들 중, 실제 결측치가 아니라 단지 문자형 벡터가 인용 부호 (&quot;quotes&quot;) 없이
사용되었기 때문인 경우도 있으므로 주의하시기 바랍니다. 
</p>
<hr>
<a name="g_t_bb38_c790_d615-_bca1_d130"></a>
<a name="munjahyeong-begteo"></a>
<h3 class="section">2.6 문자형 벡터</h3>
<a name="index-munjahyeong-begteo"></a>

<p>문자값 또는 문자형 벡터는 종종 R에서 플롯의 라벨 등으로 사용 됩니다. 이러한 문자열은 <code>&quot;x-values&quot;</code> 또는
<code>&quot;New iteration results&quot;</code>과 같이 <code>&quot;&quot;</code> (큰 따옴표)에 의해 구분 됩니다.
</p>
<p>문자열의 입력은 큰 따옴표 (<code>&quot;</code>)와 작은 따옴표 (<code>'</code>)를 모두 사용할 수 있지만, 입력된 문자열을 출력할 때는
큰 따옴표에 의해 각 구성요소가 구분 됩니다. (경우에 따라 큰 따옴표 없이 출력되는 것도 가능 합니다).R에서는 C 언어처럼
<code>\</code>를 확장 문자(escape sequence)로 사용하여 문자열을 처리하는 것이 가능합니다. 따라서, <code>\\</code>를
출력하기 위해서는 (<code>&quot;</code>로 구분된) 문자열 내에 <code>\\</code>을 사용하고, 큰 따옴표 <code>&quot;</code>를 출력하기 위해서는
<code>&quot;</code>를 사용하도록 합니다. 그 밖의 유용한 이스케이프 시퀀스들로는 <code>\n</code>이 있는데 이는 새로운 행(즉, 개행)을,
<code>\t</code>는 탭(tab)을, <code>\b</code>는 백스페이스를 나타냅니다. 사용 가능한 확장 문자 대한 전체 목록을 확인하고
싶으시면 <code>?Quotes</code>을 입력하시길 바랍니다.
</p>
<p><code>c()</code>라는 함수를 이용하면 문자열을 연결하여 새로운 문자열 벡터를 생성할 수 있습니다. 이러한 문자 벡터의 생성은 앞으로
자주 등장하게 될 것입니다. 
<a name="index-c-1"></a>
</p>
<a name="index-paste"></a>
<p><code>paste()</code> 함수는 임의의 개수의 인자들을 입력받아, 이들을 한데 묶어 하나의 문자열로 생성 합니다.이 때, 주어진 인자들
중 일부가 숫자라도, 이들 역시 문자형으로 강제형변환이 이루어짐을 아셔야 합니다. 이러한 형변환 결과는 출력을 통해 확일할 수 있는데,
합쳐진 각각의 문자형 인자들 사이는 하나에는 공백문자(white space 또는 blank character)가 포함되어 두 요소가
합쳐졌다는 것을 알 수 있습니다. 이러한 공백문자를 포함한 새로운 문자형 인자의 생성은 <code>sep=<var>string</var></code> 옵션을
사용하여 다른 문자에 의해 구분되도록 지정하는 것이 가능하며, 아래의 예제처럼 입력시 <code><var>string</var></code>은 공백 없이 두
요소를 하나로 합치는 것도 가능합니다.  
</p>
<p>다음의 예시를 살펴봅니다.
</p>
<div class="example">
<pre class="example">&gt; labs &lt;- paste(c(&quot;X&quot;,&quot;Y&quot;), 1:10, sep=&quot;&quot;)
</pre></div>

<p>위의 할당문은 <code>labs</code> 를 아래와 같은 문자형 벡터로 만들어 줍니다.
</p>
<div class="example">
<pre class="example">c(&quot;X1&quot;, &quot;Y2&quot;, &quot;X3&quot;, &quot;Y4&quot;, &quot;X5&quot;, &quot;Y6&quot;, &quot;X7&quot;, &quot;Y8&quot;, &quot;X9&quot;, &quot;Y10&quot;)
</pre></div>

<p>위 명령문에서 <code>paste()</code>라는 함수는 <code>c(&quot;X&quot;, &quot;Y&quot;)</code>라는 문자형 벡터와 <code>1:10</code>이라는 숫자형
벡터를 하나로 묶어 문자형 벡터를 생성하는데, 두 벡터의 길이가 다르므로 <code>c(&quot;X&quot;, &quot;Y&quot;)</code>가 5번 반복되게 될
것입니다. 또, 구분자가 <code>sep=&quot;&quot;</code>로 지정 되었으므로 두 문자 사이에는 아무런 공백이 없을
것입니다. <a name="DOCF8" href="#FOOT8"><sup>8</sup></a> 
</p>
<hr>
<a name="g_t_c778_b371_c2a4-_bca1_d130"></a>
<a name="indegseu-begteoreul-sayonghan-deiteosesyi-seontaeggwa-sujeong"></a>
<h3 class="section">2.7 인덱스 벡터를 사용한 데이터셋의 선택과 수정</h3>
<a name="index-Indexing-vectors"></a>

<p>벡터의 이름 바로 뒤에 대괄호(<code>[]</code>)와 함께 사용된 <em>index vector</em>(인덱스 벡터)를 통해 벡터의 일부
구성 요소만 선택하는 것이 가능합니다. 여기서 인덱스 벡터란 대괄호 내부에 쓰인 벡터를 의미 합니다.좀 더 일반적으로 말하면, 연산의
결과로 벡터를 생성하게 되는 어떠한 표현식이라도 표현식 바로 다음에 대괄호와 함께 인덱스 벡터를 사용해서 벡터 구성요소 중 일부만
선택하는 것이 가능합니다.
</p>

<p>이러한 인덱스 벡터에는 다음과 같은 네가지 유형이 있습니다. 
</p>
<ol>
<li> <strong>논리형 인덱스 벡터</strong>:  이 경우는 인덱스 벡터는 반드시 선택할 구성요소를 포함한 벡터와 길이가 같아야 합니다. 인덱스
벡터에서 <code>TRUE</code>에 대응하는 요소들만 선택되고, <code>FALSE</code>에 대응하는 요소들은 제거될 것입니다. 예를 들면, 

<div class="example">
<pre class="example">&gt; y &lt;- x[!is.na(x)]
</pre></div>

<p>위의 명령문은 <code>x</code> 벡터 중 결측치가 아닌 요소들만을 원래의 순서대로 포함하는 객체 <code>y</code>를 생성합니다. 만약
<code>x</code>에 결측치가 포함되어 있다면 새로 생성된 <code>y</code>의 길이는 <code>x</code> 보다 짧을 것입니다. 또 한,
</p>
<div class="example">
<pre class="example">&gt; (x+1)[(!is.na(x)) &amp; x&gt;0] -&gt; z
</pre></div>

<p>위의 명령어는 <code>x</code>의 구성요소들 중 결측치가 아니면서 양수인 요소들만을 찾아서 이들에 각각 1을 더하여 객체 <code>z</code>를
생성합니다.
</p>
</li><li> <strong>양의 정수 인덱스 벡터</strong>: 이 경우의 인덱스 벡터는 반드시 {1, 2, &hellip;, <code>length(x)</code>}
범위 내에 있어야 합니다. 선택된 구성요소들은 인덱스 벡터에서 <em>지정한 순서</em> 대로 선택되어 하나로 묶여지게 됩니다. 선택된
결과는 사용된 인덱스 벡터의 길이와 같으며, 인덱스 벡터의 길이는 임의로 선택 가능합니다. 예를 들어, <code>x[6]</code>는
<code>x</code>의 여섯번째 구성요소를 선택하며, 

<div class="example">
<pre class="example">&gt; x[1:10]
</pre></div>

<p>위의 명령문은 (<code>x</code>의 길이가 10보다 작지만 않다면,) <code>x</code>가 가진 구성요소 중 처음 10개의 요소들을 선택
합니다.  또, 
</p>
<div class="example">
<pre class="example">&gt; c(&quot;x&quot;,&quot;y&quot;)[rep(c(1,2,2,1), times=4)]
</pre></div>

<p>위의 명령문은 (물론 이렇게 어렵게 사용하는 경우는 거의 없지만) <code>&quot;x&quot;, &quot;y&quot;, &quot;y&quot;, &quot;x&quot;</code>가 4번씩 반복되어 구성된
전체 길이 16인 문자형 벡터를 생성 합니다. 
</p>
</li><li> <strong>음의 정수 인덱스 벡터</strong>:  이 경우, 인덱스 벡터는 선택된 요소들을 포함하는 것이 아니라 <em>제외</em>할 목적으로
사용됩니다. 따라서, 

<div class="example">
<pre class="example">&gt; y &lt;- x[-(1:5)]
</pre></div>

<p>위의 명령문은 <code>x</code>의 처음 5개의 구성요소들만 제외시켜 <code>y</code>를 생성 합니다. 
</p>
</li><li> <strong>문자형 인덱스 벡터</strong>: 이 경우는 객체의 각 구성요소들이 <code>names</code>라는 속성(i.e.객체 안의 각
구성요소(변수)의 이름)을 가지고 있을 때에만 인덱스 벡터의 이용이 가능합니다. 이때, <code>names</code>를 한 데 묶어 나열한
벡터를 네임벡터 (names vector)라고하며, 위에서 설명한 양의 정수 인덱스 벡터와 동일한 방식으로 사용하면 됩니다.다음의 예제를
보면,  우선 <code>fruit</code>이라는 수치형 벡터에 <code>names()</code> 라는 함수를 이용하여 각각의 구성요소에
<code>&quot;orange&quot;, &quot;banana&quot;, &quot;apple&quot;, &quot;peach&quot;</code>라는 <code>names</code> 속성을 부여합니다.이제, 만약
<code>fruit</code> 벡터의 세번째와 첫번째 요소를 선택하고 싶다면, <code>[c(&quot;apple&quot;,&quot;orange&quot;)]</code>를 사용하면
됩니다.

<div class="example">
<pre class="example">&gt; fruit &lt;- c(5, 10, 1, 20)
&gt; names(fruit) &lt;- c(&quot;orange&quot;, &quot;banana&quot;, &quot;apple&quot;, &quot;peach&quot;)
&gt; lunch &lt;- fruit[c(&quot;apple&quot;,&quot;orange&quot;)]
</pre></div>

<p>이렇게 영문과 숫자의 조합(alphanumeric)인 <em>names</em>를 이용할 경우 <em>수치형 인덱스</em>를 이용하여
구성요소를 선택할 때 보다 기억하기에 편리하다는 장점이 있습니다. 이 옵션은 특히 나중에 설명하게 될 데이터 프레임과 연관이 있습니다.
</p>
</li></ol>

<p>인덱스를 사용한 표현식은 벡터의 일부 구성요소에 새로운 값을  할당하기 위한 목적으로도 사용 되는데,이 경우 주로 인덱스 벡터를 적용한
벡터 그 자신이 할당의 대상이 됩니다. 여기서 표현식은 반드시<code>vector[<var>index_vector</var>]</code>의 형태로
사용되야 하며, 네임벡터의 위치에 어떠한 표현식이든 자유롭게 사용될 수 있는 것은 아닙니다. 예제를 통해 살펴보면, 다음과 같은 명령문을
사용하면 <code>x</code>에서 결측값이 있는 위치를 확인하여 이 위치의 결측값에 0을 할당 하는 것이 가능합니다.
</p>
<p>다음의 예시를 살펴봅니다.
</p>
<div class="example">
<pre class="example">&gt; x[is.na(x)] &lt;- 0
</pre></div>

<p>또 다음의 예제에서는 <code>y</code>의 값들 중 0 보다 작은 값들을 찾고 이들의 부호를 바꿔줍니다.
</p>
<div class="example">
<pre class="example">&gt; y[y &lt; 0] &lt;- -y[y &lt; 0]
</pre></div>

<p>결과적으로 위의 예제는 아래의 명령문을 수행한 것과 같은 결과를 얻습니다. 
</p>
<div class="example">
<pre class="example">&gt; y &lt;- abs(y)
</pre></div>

<hr>
<a name="g_t_ac1d_ccb4_c758-_b2e4_b978-_c720_d615_b4e4"></a>
<a name="gaegceyi-dareun-yuhyeongdeul"></a>
<h3 class="section">2.8 객체의 다른 유형들</h3>

<p>벡터는 R에서 가장 중요한 객체입니다. 하지만 이번 섹션에서는 다른 유형의 객체들에 대해 간단히 소개하도록 하겠습니다. 
</p>
<ul>
<li> <em>matrices</em>(행렬) 또는 좀 더 일반적으로 <em>arrays</em>(배열)이라는 것은 1차원인 벡터를 다차원으로
일반화시킨 것 입니다. 실제로, 행렬과 배열은 두개 또는 그 이상의 인덱스를 사용하여 표현되는 <em>벡터</em>로 볼 수 있으며, 정해진
형태로 출력될 것입니다. See <a href="#Arrays-and-matrices-_0028_bc30_c5f4_acfc-_d589_b82c_0029">Arrays and matrices (배열과 행렬)</a>.

</li><li> <em>factors</em>(요인)을 이용하면 범주형 자료(categorical data)를 간단하게 다룰 수
있습니다. See <a href="#Factors-_0028_c694_c778_0029">Factors (요인)</a>.  

</li><li> <em>lists</em>는 가장 일반적인 형태의 벡터로 각 구성요소들이 같은 데이터 형태로 되어야한다는 제약이 없으며, 종종 벡터나
리스트를 그 자체로 포함하기도 합니다. 또한 리스트는 통계연산의 결과를 편리하게 출력하기 위해 사용될 수도
있습니다. See <a href="#Lists-_0028_b9ac_c2a4_d2b8_0029">Lists (리스트)</a>.

</li><li> <em>data frames</em>은 행렬과 비슷한 구조를 가지고 있지만, 각각의 열이 다른 데이터 형태일 수 있습니다. 데이터 프레임은,
각 행이 하나의 관측 단위이고 각 열은 이 관측단위에서 얻어진 연속형 또는 이산형 변수인 &lsquo;데이터 행렬&rsquo;이라고 생각해도 무방할 것
입니다. 예를들어, 실험의 처리 수준을 범주화(categorical)해서 나타내고, 각 처리에서 얻어진 결과물(반응 변수)은 연속형일
경우, 데이터 프레임을 사용하는 것이 이 실험을 가장 잘 기록할 수 있는 방법일 것입니다. See <a href="#Data-frames-_0028_b370_c774_d130-_d504_b808_c784_0029">Data frames (데이터 프레임)</a>.

</li><li> R에서 <em>functions</em>(함수)는 그 자체로 프로젝트의 작업공간 내에 저장 될 수 있는 객체이기도 합니다. 함수의
사용은 R의 기능을 좀 더 간편하게 확장할 수 있게 합니다. See <a href="#Writing-your-own-functions-_0028_c0ac_c6a9_c790-_c815_c758_d568_c218-_c791_c131_d558_ae30_0029">Writing your own functions (사용자 정의함수 작성하기)</a>.

</li></ul>

<hr>
<a name="Objects"></a>
<a name="gaegceyi-jeojangbangsiggwa-sogseong"></a>
<h2 class="chapter">3 객체의 저장방식과 속성</h2>
<a name="index-Objects"></a>
<a name="index-Attributes"></a>



<hr>
<a name="The-intrinsic-attributes-mode-and-length"></a>
<a name="goyusogseong_003a-jeojangbangbeob-geurigo-gili"></a>
<h3 class="section">3.1 고유속성: 저장방법 그리고 길이</h3>

<p>R에서 정보처리 (연산 및 수행)의 기본단위는 전문용어로 <em>objects</em>(객체)라고 부르는 요소들입니다.이러한 객체의
종류에는 (실수) 수치형 및 복소수형, 논리형 그리고 문자형 벡터등이 있습니다.이러한 벡터의 구조를 &ldquo;atomic&rdquo; 이라고 하는데,
그 이유는 이들 벡터의 구성요소는 반드시 <em>numeric</em> <a name="DOCF9" href="#FOOT9"><sup>9</sup></a>, <em>complex</em>, <em>logical</em>, <em>character</em>, 그리고 <em>raw</em> 중
하나의 타입 혹은  <em>mode</em>(모드)로만 되어있기 때문입니다. 
</p>
<p>벡터는 반드시 <em>같은 모드에서 나온</em> 값들로만 이루어져야 합니다.따라서 어떠한 벡터라도 반드시
<em>logical</em>(논리형), <em>numeric</em>(수치형), <em>complex</em>(복소수형),
<em>character</em>(문자형) 또는 <em>raw</em> 중의 하나의 모드이어야 합니다.(이 규칙에 대한 유일하고 명백한 예외가
있다면 그것은 <code>NA</code>로 표기되는 결측값일 것 입니다.하지만, 사실 여러 이유로 <code>NA</code> 값이 생성 됩니다).벡터는
empty(아무런 구성요소 없이 비어 있는) 상태라고 하더라도 모드를 가질 수 있습니다. 예를들어, 비어있는 문자열 벡터
<code>character(0)</code>나, 비어있는 수치형 벡터 <code>numeric(0)</code> 등이 있습니다. 
</p>
<p>R은 또한 <em>list</em>(리스트)라는 모드를 가진 <em>lists</em>(리스트) 객체들을 대상으로 연산을 수행할 수
있습니다. 리스트에는 동일하지 않은 모드를 가진 여러 객체들을 일정한 순서대로 나열할 수 있습니다. <em>lists</em>(리스트)는
또한 atomic structure (가장 단순한 기본구조)이기 보다는 &ldquo;recursive&rdquo;(재귀)구조를 가지는데, 그 이유는
리스트의 구성요소 그 자체가 리스트 안에 포함될 수 있기 때문입니다. 
</p>
<p>또 다른 재귀구조는 모드가 <em>function</em>(함수) 또는 <em>expression</em>(표현식)인 경우 입니다.함수는 나중에
설명하게 될 사용자 정의 함수와 함께 R 시스템의 일부를 구성하는 객체입니다.표현식은 R에서 모델링에 사용되는
<em>formulae</em>(공식)을 언급할 때 간접적으로 등장하는 것을 제외하고는 이 문서에서는 다루지 않을 것이지만, 이 역시
R시스템의 고급 활용을 위해 필요한 객체 입니다.
</p>
<p>한 객체의 <em>mode</em>(모드)를 확인하여, 우리는 이 객체를 구성하는 요소들의 기본형(basic type)을 알 수
있습니다. 모드는 한 객체의 속성 (property) 중 특별한 하나의 예 입니다. 모든 객체가 갖는 또 다른 속성에
<em>length</em>(길이)가 있습니다.명령문 <code>mode(<var>object</var>)</code>와
<code>mode(<var>object</var>)</code>를 사용하여 객체의 모드와 길이를 알 수 있습니다. <a name="DOCF10" href="#FOOT10"><sup>10</sup></a>
</p>
<p>객체에 대한 더 많은 속성들은 <code>attributes(<var>object</var>)</code>를 사용해서 볼 수 있으며, 궁금한 점은
<a href="#Getting-and-setting-attributes-_0028_c18d_c131_c744-_c124_c815_d558_ace0-_d655_c778_d558_ae30_0029">Getting and setting attributes (속성을 설정하고 확인하기)</a>를 참고하시길 바랍니다.이러한 이유로,
<em>mode</em>(모드)와 <em>length</em>(길이)는 객체의 &ldquo;intrinsic attributes&rdquo;(본질적 속성)이라고
합니다.
<a name="index-mode"></a>
<a name="index-length-1"></a>
</p>
<p>예를 들어, 만약 <code>z</code>가 길이 100인 복소수형 벡터라고 한다면, 표현식 <code>mode(z)</code>는 문자열
<code>&quot;complex&quot;</code>(복소수)을 출력하고, <code>length(z)</code>은 <code>100</code>을 출력 합니다.
</p>
<p>R에서는 어디든 필요한 곳에서 모드를 변경할 수 있습니다.  예제를 통해 살펴보면,
</p>
<div class="example">
<pre class="example">&gt; z &lt;- 0:9
</pre></div>

<p>위에서 생성한 0 부터 9까지의 숫자로 이루어진 수열 <code>z</code>는 <code>c(&quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &hellip;,
&quot;9&quot;)</code>의 값을 갖는 문자형 벡터 digits으로 전환될 수 있습니다.
</p>
<div class="example">
<pre class="example">&gt; digits &lt;- as.character(z)
</pre></div>

<p>이 문자형 벡터는 다음과 같은 방법으로 수치형 벡터로 <em>coercion</em>(강제형변환) 또는 모드 변환할 수 있습니다:
</p>
<div class="example">
<pre class="example">&gt; d &lt;- as.integer(digits)
</pre></div>

<p>이제 <code>d</code>와 <code>z</code>는 동일한 벡터 입니다.<a name="DOCF11" href="#FOOT11"><sup>11</sup></a>  이와 같이 객체의 모드를 변경하거나, 한 객체가 현재 지정된 모드 이외의 다른 속성을 가질 수 있는지 확인하기 위해
<code>as.<var>something</var></code> 형태의 다양한 함수 모음을 이용할 수 있습니다.이러한 함수들을 능숙하게 사용하기 위해서는
다양한 도움말이 필요할 것 입니다.
</p>

<hr>
<a name="g_t_ac1d_ccb4_c758-_ae38_c774-_bcc0_acbd"></a>
<a name="gaegceyi-gili-byeongyeong"></a>
<h3 class="section">3.2 객체의 길이 변경</h3>

<p>An &ldquo;empty&rdquo; object may still have a mode.  For example
</p>
<div class="example">
<pre class="example">&gt; e &lt;- numeric()
</pre></div>

<p>위의 명령문은 수치형 모드를 갖는 비어있는 벡터 <code>e</code>를 생성합니다.마찬가지로, <code>character()</code>은 비어있는
문자형 벡터를 생성합니다.일단 임의의 크기를 갖는 객체가 생성하고 나면,이전 범위 밖에 인덱스 값을 지정하는 것으로  새 구성요소를
간단히 추가할 수 있습니다.
</p>
<div class="example">
<pre class="example">&gt; e[3] &lt;- 17
</pre></div>

<p>위의 명령문으로 길이가 3인 벡터 <code>e</code>가 생성 됩니다. (별도 지정이 없었으므로, 처음 두 개의 구성요소들은
<code>NA</code>가 될 것입니다.) 이런 방식으로 구성요소를 추가하는 것은 새로 추가되는 구성요소가 이미 존재하는 구성요소들과 모드만
일치한다면, 어떤 구조의 객체라도 모두 적용 가능합니다. 
</p>
<p>때로는, 데이터를 입력할 때 사용하는 <code>scan()</code> 함수처럼, 자동적으로 객체의 길이가 조정될 때가 있습니다. 
</p>
<p>반대로, 객체의 크기를 직접 조정하고 싶다면, 그렇게 하기 위한 할당문을 사용하면 됩니다.예를들어, 길이가 10인
<code>alpha</code>라는 객체가 있다면,아래의 할당문은 길이가 5이고, 이전 <code>alpha</code>의 구성성분 중 짝수번 째에 해당하는
요소들만을 선택하여 새로운 객체인   <code>alpha</code>를 생성합니다. (이전 인덱스는 더 이상 남아있지 않습니다.) 
</p>
<div class="example">
<pre class="example">&gt; alpha &lt;- alpha[2 * 1:5]
</pre></div>

<p>이 중 처음 세 개의 구성요소만을 포함하는 <code>alpha</code>를 생성하고자하면, 다음 문장과 같이 하면 됩니다. 
</p>
<div class="example">
<pre class="example">&gt; length(alpha) &lt;- 3
</pre></div>

<p>비슷한 방법으로 벡터의 길이를 늘리는 것도 가능합니다. (늘어난 길이만큼 결측값으로 채워지겠지만요.) 
</p>
<hr>
<a name="Getting-and-setting-attributes-_0028_c18d_c131_c744-_c124_c815_d558_ace0-_d655_c778_d558_ae30_0029"></a>
<a name="Getting-and-setting-attributes-_0028sogseongeul-seoljeonghago-hwaginhagi_0029"></a>
<h3 class="section">3.3 Getting and setting attributes (속성을 설정하고 확인하기)</h3>
<a name="index-attr"></a>
<a name="index-attributes"></a>

<p>함수 <code>attributes(<var>object</var>)</code>는 해당 객체에 현재 지정되어 있는 모든 (내재형이
아닌,non-intrinsic) 속성들을 리스트로 나열해 줍니다.
<a name="index-attributes-1"></a>
또 함수 <code>attr(<var>object</var>, <var>name</var>)</code>는 객체의 좀 더 구체적인 속성을 선택하는데 사용 됩니다.
<a name="index-attr-1"></a>
그러나, 이러한 함수들은, R 객체에 작성날짜나 특별한 연산자를 연결시킬 때와 같은 아주 특별한 경우를 제외하고는 거의 사용되지
않습니다. 하지만, 이와 관련된 개념을 알아두는 것은 매우 중요합니다.
</p>
<p>객체에 속성을 새로 추가하거나 삭제할 때는 특별히 주의를 기울이시길 바랍니다. 이런 속성 변경의 대상이 되는 객체들이  R에서
사용되는 객체 시스템의 매우 중요한 부분이기 때문입니다.
</p>
<p>할당문의 좌측에 함수 <code><var>object</var></code>를 사용하면, 새로운 속성을 할당하거나 존재하는 속성을 변경할 수
있습니다. 아래와 같이 입력하면, R은 벡터 <code>z</code>를 마치 크기가 10행 10열인 행렬처럼 다룰 수 있게 됩니다.
</p>
<div class="example">
<pre class="example">&gt; attr(z, &quot;dim&quot;) &lt;- c(10,10)
</pre></div>

<p>allows R to treat <code>z</code> as if it were a 10-by-10 matrix.
</p>
<hr>
<a name="g_t_ac1d_ccb4_c758-_d074_b798_c2a4"></a>
<a name="gaegceyi-keulraeseu"></a>
<h3 class="section">3.4 객체의 클래스</h3>
<a name="index-Classes"></a>

<p>R에 존재하는 모든 객체들은 <em>class</em>(클래스)라는 것을 갖습니다.이 클래스의 종류는 함수 <code>class</code>를
사용해서 확인할 수 있습니다.간단한 벡터의 경우, 클래스는 <code>&quot;numeric&quot;</code>, <code>&quot;logical&quot;</code>,
<code>&quot;character&quot;</code> 또는 <code>&quot;list&quot;</code>와 같이 단순히 벡터의 모드를 의미 합니다.그러나,
<code>&quot;matrix&quot;</code>, <code>&quot;array&quot;</code>, <code>&quot;factor&quot;</code> 그리고 <code>&quot;data.frame&quot;</code>는
클래스로 다른 값을 가질 수 있습니다.
</p>
<p>객체의 <em>class</em>(클래스)가 가진 특별한 속성 중 하나는 R의 object-oriented style (객체지향스타일)
<a name="DOCF12" href="#FOOT12"><sup>12</sup></a> 프로그래밍을 가능하게 한다는 점입니다.예를 들어, 만약 객체가 <code>&quot;data.frame&quot;</code>을 그 클래스로
가진다면,이 객체를 출력은 정해진 특정한 방식대로 이루어집니다. 이 객체에 <code>plot()</code> 함수를 적용할 경우, 이미 정해진
그래픽의 형태로 시각화하게 되고, 또  <code>summary()</code>와 같이 일반(generic)함수를 사용할 경우, 객체가 가지고 있는
클래스를 인자의 형태로 받아, 클래스에 따른 정의대로 결과물을 출력합니다. 
</p>
<p>클래스 효과를 일시적으로 제거하기 위해서는 <code>unclass()</code>라는 함수를 사용하면 됩니다.
<a name="index-unclass"></a>
예를들어 만약 <code>winter</code>라는 객체가 클래스 <code>&quot;data.frame&quot;</code>(데이터 프레임)을 가지고 있다면, 아래의
명령문을 실행하면 행렬이라기 보다는 데이터 프레임의 형식을 갖추어 데이터를 출력하게 됩니다. 
</p>
<div class="example">
<pre class="example">&gt; winter
</pre></div>

<p>반면에 아래의 명령문을 실행해서 클래스 효과를 지우면 일반적인 리스트의 형식으로 출력됩니다.
</p>
<div class="example">
<pre class="example">&gt; unclass(winter)
</pre></div>

<p>이러한 클래스의 활용은 매우 특별한 경우에 한해서만 필요하므로, 여기서는 단순히 클래스와 일반함수의 기본 개념에만 익숙해지면 됩니다.
</p>
<p>일반함수와 클래스에 대해서는 <a href="#Object-orientation-_0028_ac1d_ccb4_c9c0_d5a5_c801-_bc29_bc95_0029">Object orientation (객체지향적 방법)</a> 부분에서 더 자세히 다루겠지만, 여기에서는
이쯤에서 간단히 마치겠습니다.
</p>
<hr>
<a name="Factors-_0028_c694_c778_0029"></a>
<a name="sunseohyeonggwa-bisunseohyeong-yoin"></a>
<h2 class="chapter">4 순서형과 비순서형 요인</h2>
<a name="index-Factors-_0028yoin_0029"></a>
<a name="index-sunseohyeong-yoin"></a>

<p><em>factor</em>(요인)은 같은 길이를 가진 다른 벡터의 다른 구성요소들을 이산형으로 구분(Classification) 또는
그룹핑(grouping)된 것을 표현해주는 벡터형 객체입니다.R에서는 <em>ordered</em>(순서형)과
<em>unordered</em>(비순서형) 요인을 모두 사용 가능합니다.요인의 활용이 정말 필요한 것은 see <a href="#Contrasts">Contrasts</a>
부분에서 설명할 model formulae(모형 공식)을 사용할 때이지만, 여기에서는 좀 더 간단한 예제를 우선 다루겠습니다.
</p>
<a name="gucejeogin-yeje"></a>
<h3 class="section">4.1 구체적인 예제</h3>

<p>예를들어, Australia(오스트레일리아, 호주)의 모든 지역(호주에는 Australian Capital Territory, New
South Wales, the Northern Territory, Queensland, South Australia, Tasmania,
Victoria and Western Australia 라는 총 8개의 행정 구역이 있습니다)으로부터 온 30명의 회계사 샘플과 그들의
출신 지역에 대한 정보가 문자형 벡터인 state에 약자로 다음과 같이 기록되어있습니다. 
</p>
<div class="example">
<pre class="example">&gt; state &lt;- c(&quot;tas&quot;, &quot;sa&quot;,  &quot;qld&quot;, &quot;nsw&quot;, &quot;nsw&quot;, &quot;nt&quot;,  &quot;wa&quot;,  &quot;wa&quot;,
             &quot;qld&quot;, &quot;vic&quot;, &quot;nsw&quot;, &quot;vic&quot;, &quot;qld&quot;, &quot;qld&quot;, &quot;sa&quot;,  &quot;tas&quot;,
             &quot;sa&quot;,  &quot;nt&quot;,  &quot;wa&quot;,  &quot;vic&quot;, &quot;qld&quot;, &quot;nsw&quot;, &quot;nsw&quot;, &quot;wa&quot;,
             &quot;sa&quot;,  &quot;act&quot;, &quot;nsw&quot;, &quot;vic&quot;, &quot;vic&quot;, &quot;act&quot;)
</pre></div>

<p>문자형 벡터의 경우에는 &ldquo;sorted&rdquo;(정렬)이라는 것은 알파벳순서로 나열된 것을 의미합니다.
</p>
<p>여기에 대한 <em>factor</em>(요인)은 <code>factor()</code> 함수를 이용하여 아래와 같이 생성합니다:
<a name="index-factor"></a>
</p>
<div class="example">
<pre class="example">&gt; statef &lt;- factor(state)
</pre></div>

<p><code>print()</code> 함수를 사용해서 요인을 출력할 경우, 다른 객체들과는 다소 다른 방식으로 출력됩니다:
</p>
<div class="example">
<pre class="example">&gt; statef
 [1] tas sa  qld nsw nsw nt  wa  wa  qld vic nsw vic qld qld sa
[16] tas sa  nt  wa  vic qld nsw nsw wa  sa  act nsw vic vic act
Levels:  act nsw nt qld sa tas vic wa
</pre></div>

<p>요인의 수준(levels)을 확인하기 위해서는 함수 <code>levels()</code>를 사용하면 됩니다.
<a name="index-levels"></a>
</p>
<div class="example">
<pre class="example">&gt; levels(statef)
[1] &quot;act&quot; &quot;nsw&quot; &quot;nt&quot;  &quot;qld&quot; &quot;sa&quot;  &quot;tas&quot; &quot;vic&quot; &quot;wa&quot;
</pre></div>


<hr>
<a name="The-function-tapply_0028_0029-and-ragged-arrays"></a>
<a name="hamsu-tapply_0028_0029wa-bijeonghyeong-baeyeol"></a>
<h3 class="section">4.2 함수 <code>tapply()</code>와 비정형 배열</h3>
<a name="index-tapply"></a>

<p>앞부분에서 사용된 예제를 계속해서, 이제 30명의 회계사의 수입(income)에 대한 정보가 아래와 같이 벡터로 (적당한 화폐단위로
기록되어) 제공되었다고 가정합시다.
</p>
<div class="example">
<pre class="example">&gt; incomes &lt;- c(60, 49, 40, 61, 64, 60, 59, 54, 62, 69, 70, 42, 56,
               61, 61, 61, 58, 51, 48, 65, 49, 49, 41, 48, 52, 46,
               59, 46, 58, 43)
</pre></div>

<p>각 주(state) 별 평균소득을 계산하고 싶다면 아래와 같이 <code>tapply()</code> 함수를 사용하면 됩니다.
</p>
<div class="example">
<pre class="example">&gt; incmeans &lt;- tapply(incomes, statef, mean)
</pre></div>

<p>위 명령어를 실행하면 아래와 같이 (state의) 각 수준(levels)에 해당하는 평균이 벡터로 출력 됩니다.
</p>
<div class="example">
<pre class="example">   act    nsw     nt    qld     sa    tas    vic     wa
44.500 57.333 55.500 53.600 55.000 60.500 56.000 52.250
</pre></div>

<p>함수 <code>tapply()</code>를 사용하면 이 함수의 첫번째 인자인 <code>incomes</code>에 대해, 이 함수의 두번째 인자인
<code>statef</code>에 정의된 요인의 수준별로, 세번째 인자인 함수 <code>mean()</code>을 계산합니다. 마치 각각의 두번째 요인의
수준별로 별개의 벡터가 존재하는 것 처럼 말이지요. <a name="DOCF13" href="#FOOT13"><sup>13</sup></a>따라서, 결과로 생성된 벡터의 길이는 반드시 요인 수준의 개수와 같아야 합니다.이러한 연산에 대해 더 자세히 알고 싶은 분은
도움말을 참고하시길 바랍니다.
</p>
<p>어쩌면 여러분은 이 예제에서 평균소득에 대한 표준오차(standard error)를 계산해보고 싶을 수도 있을 것 입니다.이를 위해,
아래와 같이 주어진 벡터의 표준오차를 계산하는 R 함수를 작성할 수 있습니다.<code>var()</code>라는 샘플 분산을 계산하는
빌트인(built-in) 함수가 존재하기 때문에, 이 함수는 아래와 같이 간단한 한줄짜리 함수로 표현 가능합니다:
</p>
<div class="example">
<pre class="example">&gt; stderr &lt;- function(x) sqrt(var(x)/length(x))
</pre></div>

<p>(함수를 작성하는 방법에 대해서는 추후에 <a href="#Writing-your-own-functions-_0028_c0ac_c6a9_c790-_c815_c758_d568_c218-_c791_c131_d558_ae30_0029">Writing your own functions (사용자 정의함수 작성하기)</a> 편에서
다룰 것입니다. 또 위의 함수작성 예제는 실제로는 별로 의미는 없는데, R에는 이미 <code>sd()</code>라는 표준오차 계산 함수가
포함되어 있기 때문입니다).
<a name="index-sd"></a>
<a name="index-var-1"></a>
위의 함수에 할당을 하면, 아래와 같이 표준오차가 계산되며, 
</p>
<div class="example">
<pre class="example">&gt; incster &lt;- tapply(incomes, statef, stderr)
</pre></div>

<p>그 결과는 다음과 같습니다.
</p>
<div class="example">
<pre class="example">&gt; incster
act    nsw  nt    qld     sa tas   vic     wa
1.5 4.3102 4.5 4.1061 2.7386 0.5 5.244 2.6575
</pre></div>

<p>연습삼아 state 별 평균소득에 대한 95% 신뢰구간을 구해보고 싶은 분도 있을 것입니다.이를 위해서는, <code>tapply()</code>
함수와 함께 <code>length()</code>, <code>qt()</code>와 같은 함수들을 사용해야 할 것이라 생각되는데,
<code>length()</code>는 샘플 크기를, <code>qt()</code>는 t-분포에서 95% 에 해당하는 분위수를 찾아주는 함수
입니다.(참고로 R에 포함된 <em>t</em>-테스트 관련 함수들을 이용하는 것도 가능할 것입니다).
</p>
<p>위의 예제에서 살펴 본 <code>tapply()</code> 함수에 여러 개의 범주를 표시하기 위해 좀 더 복잡하게 표현된 인덱스 벡터를 사용하는
것도 가능합니다. 예를들어, 위 예제에서 state 와 성별이라는 두 가지 요인을 동시에 고려하여 회계사의 수입을 보고 싶다고
가정합시다.이 경우, (한 개의 요인을 고려할 때 처럼) 다음과 같은 식으로 연산이 처리 됩니다.우선, 벡터의 구성요소들이 요인의 수준
별로 그룹화 됩니다. 그리고 이 그룹화된 벡터 구성요소 별로 함수가 각각 적용 됩니다. 즉, 각 요인 수준별로 계산된 결과값에, 해당
요인의 <code>levels</code> 속성을 각각 레이블링 하는 것 입니다.
</p>
<p>하나의 벡터와 하나의 레이블링 요인을 조합하는 것은 <em>ragged array</em>(비정형 배열)의 하나의 예시로 볼 수
있는데,그것은 그룹화 된 부분의 크기가 서로 다른 경우가 대부분이기 때문입니다.만약 그룹화 된 각 부분의 크기가 모두 같다면, 다음
섹션에서 살펴보게 될 방법을 사용하여 훨씬 효율적으로 연산을 수행할 수 있습니다.
</p>

<hr>
<a name="g_t_c21c_c11c_d615-_c694_c778"></a>
<a name="sunseohyeong-yoin"></a>
<h3 class="section">4.3 순서형 요인</h3>
<a name="index-ordered"></a>

<p>요인(factor)의 수준(levels)들은 기본적으로 알파벳 순서로 저장되지만, <code>factor</code> 함수를 이용하면 사용자가
별도의 순서를 지정하는 것도 가능합니다.
</p>
<p>어떤 경우에는 수준들이 우리가 원하는대로 이미 지정되어 있거나, 통계분석 시 필요한 형태로 되어있는 경우도 있습니다. 
<a name="index-ordered-1"></a>
<code>ordered()</code> 함수는 요인을 순서형으로 생성한다는 점을 빼면 <code>factor</code>와 다르지 않습니다.대부분의 경우,
순서형과 비순서형 요인의 차이는 순서형 요인만 수준을 일정한 순서대로 출력하는 점 뿐이지만, 선형 모형 적합에서 요인을  이용하여
contrasts(대조)를 생성할 경우, 서로 다른 순서가 다른 결과물을 산출하게 된다는 점을 기억하시기 바랍니다.
</p>

<hr>
<a name="Arrays-and-matrices-_0028_bc30_c5f4_acfc-_d589_b82c_0029"></a>
<a name="Arrays-and-matrices-_0028baeyeolgwa-haengryeol_0029"></a>
<h2 class="chapter">5 Arrays and matrices (배열과 행렬)</h2>


<hr>
<a name="g_t_bc30_c5f4"></a>
<a name="baeyeol"></a>
<h3 class="section">5.1 배열</h3>
<a name="index-baeyeol"></a>
<a name="index-Matrices"></a>

<p>배열(array)이라는 것은 쉽게 말해 다차원상에 데이터가 저장될 수 있도록 데이터 엔트리(data entry, 데이터가 위치하는
하나하나를 공간 또는 한개의 데이터을 의미함)를 구조화한 것 입니다. 다차원이라는 것은 우리 머릿속에 개념상으로 존재하지만, 데이터를
일렬로 벡터와 같은 형태로 읽어들이는 컴퓨터에는 다차원의 개념이 없습니다.그래서 데이터에 다차원 구조를 주기 위해서는 이 배열이라는
개념을 이용 해야하며, R은 행렬과 같이 일정한 형태로 된 배열을 생성하고 조작할 수 있는 간편한 기능들을 제공합니다. 
</p>
<p>이러한 다차원 구조의 실제적인 구현을 위해서는 차원벡터 (dimension vector)라는 것을 활용하게 되는데, 이는 음의 값이 아닌
정수(non-negative) 벡터로 되어 있습니다. 차원벡터의 길이가 <em>k</em>인 경우, 데이터는 <em>k</em>-차원의 배열이
됩니다. 좀 더 구체적으로, 하나의 행렬은 <em>2</em>-차원 배열의 예라고 볼 수 있습니다. 각 차원(즉, 차원벡터의 구성요소)은
양의 정수를 인덱스 값으로 갖습니다.
</p>
<p>R에서 배열로 사용되기 위해서는 해당 벡터의 <em>dim</em> 속성(attribute)으로 차원벡터가 지정되어 있어야만
합니다.이해를 돕기 위해서 아래의 예제를 살펴보도록 합니다. <code>z</code>는 1500개의 구성요소를 갖는 벡터라고 가정합시다.
</p>
<div class="example">
<pre class="example">&gt; dim(z) &lt;- c(3,5,100)
</pre></div>
<a name="index-dim"></a>

<p>다음의 할당문을 실행하면, 이 벡터는 <em>3</em>-차원 구조의, <em>3</em> by <em>5</em> by <em>100</em> 크기의
배열로 지정 됩니다. 여기서 첫번째 차원은 <em>3</em>개의 구성요소를 가지므로, <em>1</em>, <em>2</em>, <em>3</em>
세 개의 인덱스에 의해 표현되며, 마찬가지로 두번째 차원은 5개의 인덱스를, 마지막으로 세번째 차원은 100개의 인덱스를 갖습니다. 즉,
차원벡터의 각 구성요소는 각 차원이 갖는 인덱스의 길이를 의미합니다.   
</p>
<p>이렇게 <code>dim</code>이라는 속성을 이용하는 방법 외에도 <code>matrix()</code>와 <code>array()</code>와 같은 함수를
사용하면 <a href="#array_0028_0029-_d568_c218">array() 함수</a>편의 예제들처럼  좀 더 간단하고 쉽게 배열을 지정할 수 있습니다. 
</p>
<p>배열을 구성하는 데이터 벡터의 구성요소의 값들은 FORTRAN 프로그램에서처럼 &ldquo;column major order&rdquo; 방법에 의해 나열
됩니다. 이 방법은 차원벡터의 첫번째 인덱스부터 순서대로 배열되기 시작해서 마지막 인덱스가 가장 나중에 사용되는 배열되는 방식 입니다. 
</p>
<p>좀 더 구체적인 예를 들면, <code>a</code>라는 배열의 차원벡터가 <code>c(3,4,2)</code>이라고 가정합시다.이 배열
<code>a</code>에는 총 3 * 4 * 2 = 24 개의 데이터 엔트리가 포함되어
있고, 이 데이터 벡터는 <code>a[1,1,1], a[2,1,1], &hellip;, a[2,4,2], a[3,4,2]</code>의 순서로
엔트리들을 배열 안에 나열하고 있습니다.
</p>
<p>1차원일 배열의 경우 (출력을 포함하여) 거의 벡터와 같은 방식으로 처리됩니다만, 몇 가지 예외가 있어서 사용에 주의가 필요합니다.
</p>
<hr>
<a name="Array-indexing"></a>
<a name="baeyeol-indegsing_0028array-indexing_0029gwa-guseongyosoyi-seontaegjeog-jijeong_0028subsections_0029"></a>
<h3 class="section">5.2 배열 인덱싱(array indexing)과 구성요소의 선택적 지정(subsections)</h3>
<a name="index-Indexing-of-and-by-arrays"></a>

<p>배열의 각 구성요소들은 배열 이름 바로 뒤에 대괄호([])사이에 컴마로 구분된 첨자(subscript)를 사용하여 선택할 수
있습니다. 이러한 선택을 좀 더 일반화하면, 한 배열의 첨자를 사용할 위치에 <em>index vectors</em>(인덱스 벡터)의
시퀀스를 사용하면 해당 배열의 어떤 부분이라도 선택할 수 있습니다; 하지만 인덱스 벡터의 구성요소가 아무것도 선택되지 않으면 (즉,
empty 상태), 해당 첨자가 가질 수 있는 모든 값이 범위로 선택 됩니다.
</p>
<p>More generally, subsections of an array may be specified by giving a
sequence of <em>index vectors</em> in place of subscripts; however <em>if
any index position is given an empty index vector, then the full range of
that subscript is taken</em>.
</p>
<p>이해를 돕기 위해 앞의 예제의 <code>a</code>라는 벡터를 다시 사용하면, <code>a[2,,]</code>는 <code>c(4,2)</code>의 차원벡터를
갖는 4 * 2 배열이며, 순서대로 다음의 값들을 포함하는 데이터 벡터이기도 합니다.이것은 원래 배열
<code>a</code>의 차원이 선택되기 때문입니다. 따라서 차원벡터의 길이에 맞추어 <em>4</em>행 <em>2</em>열을 가진 행렬처럼 출력된 것 입니다.
</p>
<div class="example">
<pre class="example">c(a[2,1,1], a[2,2,1], a[2,3,1], a[2,4,1],
  a[2,1,2], a[2,2,2], a[2,3,2], a[2,4,2])
</pre></div>

<p><code>a[,,]</code>는 배열 <code>a</code> 그 자체를 의미하는데, 이것은 첨자를 전혀 사용하지 않고 그냥 <code>a</code>만 사용한
것과 같습니다.
</p>
<p>어떤 배열이 주어지면, 예를 들어 <code>Z</code>라는 배열이 있다면, 이 배열의 차원벡터는 함수 <code>dim(Z)</code>를 사용하여 확인
가능합니다. 
</p>
<p>또, 만약 배열의 이름 뒤에 <em>a[3]</em> 또는 <em>a[3:10]</em>과 같이 <em>오직 한개의 첨자 또는 인덱스
벡터</em>가 사용되면, 이 첨자와 인덱스에 해당하는 데이터 엔트리로만 구성된 벡터가 선택 됩니다: 따라서, 이 경우에는 차원벡터가
무시됩니다. 하지만, 인덱스가 벡터가 아니라 배열로 지정될 수도 있으며, 여기에 대해서는 다음 부분에서 다루겠습니다. 
</p>

<hr>
<a name="Index-matrices-_0028_c778_b371_c2a4-_d589_b82c_0029"></a>
<a name="Index-matrices-_0028indegseu-haengryeol_0029"></a>
<h3 class="section">5.3 Index matrices (인덱스 행렬)</h3>

<p>배열의 첨자가 오는 위치에 인덱스 벡터 뿐 아니라, 행렬 형태인 <em>index matrix</em>(인덱스 행렬)을 사용할 수 있으며,
배열 내 (같은 행이나 열이 아니라)여러 위치에 흩어져 있는 여러 개의 구성 요소들에 하나의 벡터 안에 든 여러 개의 새로운 값들을
동시에 입력하거나, 배열 내 여러 위치의 구성요소들을 하나의 벡터로 읽어내기 위해 사용합니다.
</p>
<p>다음의 행렬을 사용한 예제를 통해 좀 더 자세히 설명하겠습니다. 이중(doubly) 인덱스를 사용하는 배열의 경우, 이 배열의 인덱스
행렬을 2개의 열과 필요한 만큼(데이터의 길이)의 행으로 구성됩니다. 이 인덱스 행렬의 엔트리들은 이중 인덱스 된 배열의 행과 열의
인덱스에 해당합니다. 예를 들어, 크기가 <em>4</em>행 <em>5</em>열인 배열 <code>X</code>가 있다고 가정하고, <code>X</code>에
대해서 다음의 연산을 수행한다고 합시다:
</p>
<ul>
<li> <code>X[1,3]</code>, <code>X[2,2]</code> 그리고 <code>X[3,1]</code>의 위치에 해당하는 구성요소들로만 구성된 벡터를
만듭니다.
</li><li> 그리고, 이렇게 따로 추출한 <code>X</code>의 엔트리를 모두 <em>0</em>으로 대체 합니다. 
</li></ul>
<p>위의 작업을 수행하기 위해서는 아래 예제와 같이 첨자의 위치에 사용될 <em>3</em> 행 <em>2</em> 열의 첨자 배열이 필요합니다. 
</p>
<div class="example">
<pre class="example">&gt; x &lt;- array(1:20, dim=c(4,5))   # <span class="roman">Generate a 4 by 5 array.</span>
&gt; x
     [,1] [,2] [,3] [,4] [,5]
[1,]    1    5    9   13   17
[2,]    2    6   10   14   18
[3,]    3    7   11   15   19
[4,]    4    8   12   16   20
&gt; i &lt;- array(c(1:3,3:1), dim=c(3,2))
&gt; i                             # <span class="roman"><code>i</code> is a 3 by 2 index array.</span>
     [,1] [,2]
[1,]    1    3
[2,]    2    2
[3,]    3    1
&gt; x[i]                          # <span class="roman">Extract those elements</span>
[1] 9 6 3
&gt; x[i] &lt;- 0                     # <span class="roman">Replace those elements by zeros.</span>
&gt; x
     [,1] [,2] [,3] [,4] [,5]
[1,]    1    5    0   13   17
[2,]    2    0   10   14   18
[3,]    0    7   11   15   19
[4,]    4    8   12   16   20
&gt;
</pre></div>
<p>인덱스 행렬의 구성요소는 음의 값을 가질 수 없으나, <code>NA</code>와 <em>0</em>은 사용할 수 있습니다.만약, 인덱스 행렬에
<em>0</em>을 포함한 행이 있다면, 해당 행은 무시될 것입니다. 이와 유사하게, <code>NA</code>를 포함하는 행이 있다면, 해당 행은
모두 <code>NA</code>로 출력될 것 입니다.
</p>

<p>중요한 예제는 아니지만, <code>b</code> 개의 수준을 가진 <code>blocks</code>이라는 요인과 <code>v</code> 개의 수준을 가지고 있는
<code>varieties</code> 변수로 정의되는 블록 디자인(block design)에 사용될 (비환원) 디자인 매트릭스(design
matrix)를 생성한다고 가정합시다. 더 나아가, 이 실험은 <code>n</code>개의 구획(plot)을 포함한고 가정합시다. 이 실험의
디자인 매트릭스는 아래와 같이 생성합니다:
</p>
<div class="example">
<pre class="example">&gt; Xb &lt;- matrix(0, n, b)
&gt; Xv &lt;- matrix(0, n, v)
&gt; ib &lt;- cbind(1:n, blocks)
&gt; iv &lt;- cbind(1:n, varieties)
&gt; Xb[ib] &lt;- 1
&gt; Xv[iv] &lt;- 1
&gt; X &lt;- cbind(Xb, Xv)
</pre></div>

<p>만약 <code>N</code>이라는 인시던스 행렬(incidence matrix)를 생성하고자 한다면, 아래와 같이 할 수 있습니다.
</p>
<div class="example">
<pre class="example">&gt; N &lt;- crossprod(Xb, Xv)
</pre></div>
<a name="index-crossprod"></a>

<p>그러나, 다음과 같이 <code>table()</code>함수를 이용하면 좀 더 쉽게 위에서 얻은 것과 동일한 행렬을 얻을 수 있습니다.
<a name="index-table"></a>
</p>
<div class="example">
<pre class="example">&gt; N &lt;- table(blocks, varieties)
</pre></div>

<p>인덱스 행렬은 반드시 수치형으로 구성되어야 합니다: 만약, 논리형이나 문자형 같이 다른 형식으로 된 행렬이 입력되면 인덱스 벡터로 간주
됩니다.
</p>
<hr>
<a name="array_0028_0029-_d568_c218"></a>
<a name="array_0028_0029-hamsu"></a>
<h3 class="section">5.4 <code>array()</code> 함수</h3>
<a name="index-array"></a>

<p>배열은 벡터에 <code>dim</code>이라는 속성을 부여하여 생성하는 방법 외에도, 아래와 같이 <code>array</code> 함수를 이용하여 생성할
수도 있습니다.
</p>
<div class="example">
<pre class="example">&gt; Z &lt;- array(<var>data_vector</var>, <var>dim_vector</var>)
</pre></div>

<p>예를 들어, 벡터 <code>h</code>가 24개 또는 그 보다 적은 수의 숫자로 구성되어 있다면, 아래 명령문은 <em>3</em> 행
<em>4</em> 열로 구성된 <em>2</em>개의 3차원 배열을 <code>Z</code>로 지정합니다. 
</p>
<div class="example">
<pre class="example">&gt; Z &lt;- array(h, dim=c(3,4,2))
</pre></div>

<p>특히  <code>h</code>가 정확히 24개의 구성요소를 가지고 있다면, 위 명령문의 실행 결과는 아래 명령문의 실행 결과와 같습니다.
</p>
<div class="example">
<pre class="example">&gt; Z &lt;- h ; dim(Z) &lt;- c(3,4,2)
</pre></div>

<p>하지만, 벡터 <code>h</code>가 24 개 보다 적은 수의 구성요소를 가지면, <code>array</code> 함수 사용시 24로 지정된 배열의
크기를 맞추기위해 벡터 <code>h</code>의 첫번째 원소부터 재사용하게 됩니다.이런 재활용 규칙(recycling rule)에 대해서는
see <a href="#The-recycling-rule">The recycling rule</a>를 살펴보시길 바랍니다.그러나, <code>dim(h) &lt;- c(3,4,2)</code>와 같이
<code>dim</code> 속성을 변경하고자 할 때는 지정된 길이가 다르기 때문에 에러 메세지가 나타날 것 입니다.아래는 다소 극단적이긴
하지만, 흔히 볼 수 있는 예제 입니다.
</p>
<div class="example">
<pre class="example">&gt; Z &lt;- array(0, c(3,4,2))
</pre></div>

<p>makes <code>Z</code> an array of all zeros.
</p>
<p>여기에서 <code>dim(Z)</code>은 차원벡터 <code>c(3,4,2)</code>를 의미하며, <code>Z[1:24]</code>는 벡터 <code>h</code>와
동일한 데이터 벡터를 의미 합니다. 또, <code>Z[]</code>와 같이 아무런 첨자를 갖지 않는 경우나 단순히 <code>Z</code>라고 배열
이름만 사용하는 것은 <code>Z</code>의 모든 구성요소로 이루어진 배열 그 자체를 의미 합니다.
</p>
<p>배열에 산술연산을 적용하면 기본적으로 배열을 구성하는 데이터 벡터안에 든 원소 단위별로 연산이 이루어집니다.이때 연산에 사용되는 각
배열(피연산자, operand)의 <code>dim</code> 속성이 모두 일치해야만, 원래와 동일한 차원벡터를 가진 결과물을 얻을 수
있습니다.따라서 만약 <code>A</code>, <code>B</code>, <code>C</code>가 모든 같은 <code>dim</code> 속성을 가진 배열이면, 아래와
같이 데이터 벡터의 원소 단위별로 연산을 수행한 결과가 같은 차원벡터를 가진 배열 <code>D</code>로  저장 됩니다. 
</p>
<div class="example">
<pre class="example">&gt; D &lt;- 2*A*B + C + 1
</pre></div>

<p>하지만 배열과 벡터를 함께 사용하는 연산을 정확히 사용하기 위해서는 좀 더 주의해야할 부분이 많습니다.
</p>

<hr>
<a name="The-recycling-rule"></a>
<a name="begteowa-baeyeoleul-hamgge-iyonghayeo-yeonsanhaneun-bangbeob-geurigo-jaehwalyong-gyucig"></a>
<h4 class="subsection">5.4.1 벡터와 배열을 함께 이용하여 연산하는 방법 그리고 재활용 규칙</h4>
<a name="index-Recycling-rule-1"></a>

<p>벡터와 배열을 동시에 사용해서 원소 단위별로 연산을 수행할 때 적용되는 정확한 규칙을 설명하는 것은 꽤 까다롭고 어려운 편
입니다. 하지만 지금까지의 경험을 바탕으로 한 다음의 내용은 꽤 쓸만한 길잡이가 될 것 입니다.
</p>
<ul>
<li> 표현식에 사용된 수식은 왼쪽부터 오른쪽으로 입력 됩니다.
</li><li> 연산에 사용되는 벡터들의 길이가 서로 다른 경우, 길이가 짧은 벡터의 원소를 재활용하여 길이가 긴 벡터의 길이를 맞추게 됩니다.
</li><li> 비교적 길이가 짧은 벡터와 배열들만 연산에 사용될 경우에는, 모든 배열이 같은 <code>dim</code> 속성을 갖지 않으면 에러가 발생합니다.
</li><li> 피연산자 벡터의 길이가 다른 피연산자 행렬이나 배열의 길이 보다 긴 경우에도 에러가 발생합니다. 
</li><li> 연산 중 배열의 구조가 그대로 유지되고, 에러나 벡터로의 강제 전환 같은 일이 일어나지 않는다면, 연산의 결과물은 피연산자 배열들이
공통으로 갖는 <code>dim</code> 속성을 그대로 유지하는 배열이 될 것 입니다.
</li></ul>

<hr>
<a name="g_t_b450-_bc30_c5f4_c758-_c678_c801"></a>
<a name="du-baeyeolyi-oejeog"></a>
<h3 class="section">5.5 두 배열의 외적</h3>
<a name="index-baeyeolyi-oejeog_0028outer-products_0029"></a>

<p>배열에 적용되는 연산 중 중요한 것 중 하나는 <code>%o%</code>로 정의된 연산자를 사용하는 <em>외적 (outer
product)</em>일 것 입니다. 예를 들어, <code>a</code>와 <code>b</code>이라는 두개의 수치형 배열이 존재할 경우, 이 두 배열에
외적(outer product)은 이 두 배열의 차원을 모두 포함한 <code>c(dim(a), dim(b))</code>를 차원 벡터로 갖고,
배열 <code>a</code>의 구성요소와 배열 <code>b</code>의 구성요소의 모든 가능한 조합을 곱한 값을 데이터 벡터로 갖는 배열 입니다.
<a name="index-_0025o_0025"></a>
</p>
<div class="example">
<pre class="example">&gt; ab &lt;- a %o% b
</pre></div>

<p>다음은 또 다른 방법입니다.
</p>
<div class="example">
<pre class="example">&gt; ab &lt;- outer(a, b, &quot;*&quot;)
</pre></div>
<a name="index-outer"></a>

<p>이 외적(outer product)에서의 곱하기 연산은 두 개의 변수를 대상으로 수행하는 다른 어떤 함수로도 대체 가능합니다.예를 들어,
R에서  두 개의 벡터 <code>x</code>- 와 <code>y</code>- 를 각각의 축으로 정의한 좌표 평면상 존재하는  모든 점들에 대해
f(x; y) = cos(y)/(1 + x^2)과 같은 함수를 적용하는 방법은
다음과 같습니다. 
</p>
<div class="example">
<pre class="example">&gt; f &lt;- function(x, y) cos(y)/(1 + x^2)
&gt; z &lt;- outer(x, y, f)
</pre></div>

<p>두 개의 벡터를 사용해서 외적을 할 때 주의할 점은, 결과물이 이중 첨자(doubly subscriped) 배열이라는 점입니다. (이것은
행렬이기도 합니다.) 외적 연산에 대해서는 교환법칙이 성립하지 않는다(non-commutative)는 점을 주의하시기 바랍니다. 사용자
정의 R 함수를 만드는 법에 대해서는 <a href="#Writing-your-own-functions-_0028_c0ac_c6a9_c790-_c815_c758_d568_c218-_c791_c131_d558_ae30_0029">Writing your own functions (사용자 정의함수 작성하기)</a>에서 더
다루게 될 것입니다.
</p>
<a name="yeje_003a-2haeng-2yeolin-haengryeolyi-haengryeolsig-_0028determinant_0029-gyesanhagi"></a>
<h4 class="subsubheading">예제: 2행 2열인 행렬의 행렬식 (determinant) 계산하기</h4>

<p>다소 작위적이긴 하지만, 이해하기 쉬운 예를 하나 들어봅시다.먼저, <em>[a, b; c, d]</em>의 형태를 갖는 <em>2</em> 행
<em>2</em> 열의 행렬을 가정하고, 이 행렬의 각 구성요소는 음수가 아닌 (nonegative) <em>0, 1, &hellip;,
9</em> 범위의 한자리의 정수값이라고 합시다.
</p>
<p>여기서 우리의 과제는 모든 존재 가능한 행렬들에 대해 <em>ad - bc</em>으로 계산되는 행렬식(determinant)을 계산해서,
행렬식이 갖는 모든 값의 빈도를  <em>하이 확률 빈도 (high density)</em> 플롯으로 그리는 것입니다. 여기서 만약 각
정수들(행렬의 구성요소)의 선택은 균등한 확률(uniformly at random)로 독립적(independently)으로 이루어졌다고
가정하면, 이 작업은 행렬식(determinant)의 확률 분포를 찾는 것이 됩니다. 
</p>
<p>이 복잡한 과제를 간단히 수행하는 방법 중 하나는 아래와 같이 <code>outer()</code> 함수를 두번 사용하는 것 입니다:
</p>
<div class="example">
<pre class="example">&gt; d &lt;- outer(0:9, 0:9)
&gt; fr &lt;- table(outer(d, d, &quot;-&quot;))
&gt; plot(as.numeric(names(fr)), fr, type=&quot;h&quot;,
       xlab=&quot;Determinant&quot;, ylab=&quot;Frequency&quot;)
</pre></div>

<p>여기서 행렬식이 갖는 모든 값의 도수분포표인 <code>fr</code>의 <code>names</code> 속성이 행렬식이 갖는 값들의 범위를 나타내기 위해
수치형으로 강제형변환 되었다는 점을 주의깊게 살펴보시기 바랍니다. 이러한 수치로의 전환하는 가장 &quot;쉬운&quot; 방법은 아마도
<a href="#Loops-and-conditional-execution-_0028_bc18_bcf5-_bc0f-_c870_ac74_bd80-_c2e4_d589_0029">Loops and conditional execution (반복 및 조건부 실행)</a> 편에서 다루게 될<code>for</code>라는
반복문을 이용하는 것인데, 이 방법은 매우 비효율적이라 실용적이지 못합니다. 
</p>
<p>아마도 전환하게 될 행렬이 20개 중의 하나 꼴로 특이(singular)행렬이라는 점 역시 놀라울 것 같네요. 
</p>
<hr>
<a name="g_t_bc30_c5f4_c758-_c804_ce58_c5d0-_c0ac_c6a9_b418_b294-_c77c_bc18_d654_b41c-_bc29_bc95"></a>
<a name="baeyeolyi-jeoncie-sayongdoeneun-ilbanhwadoen-bangbeob"></a>
<h3 class="section">5.6 배열의 전치에 사용되는 일반화된 방법</h3>
<a name="index-baeyeolyi-jeoncie-sayongdoeneun-ilbanhwadoen-bangbeob"></a>

<p>함수 <code>aperm(a, perm)</code>
<a name="index-aperm"></a>
배열 <code>a</code>를 차원 별로 순서를 재배치하는 (permutating)하는 함수 입니다. <code>perm</code> 입력
인자(argument,함수의 parameter와 거의 비슷한 의미)는 반드시 <em>{1, &hellip;, k}</em> 범위 내의
정수들의 조합이어야 합니다. 여기서 <em>k</em>는 배열 <code>a</code>이 갖는 첨자들의 개수입니다. 따라서, 이 함수를 실행한 결과는
배열 <code>a</code>와 같은 크기를 갖지만, 원래의 배열 <code>a</code>의 차원을 사용해서 지정한 <code>perm[j]</code>의 순서대로
<code>j</code>의 차원을 갖는 새로운 재배치된 배열입니다.이 함수가 수행하는 연산이 어떤 것인지를 좀 더 쉽게 이해하기 위해 행렬의
전치(transpose)가 좀 더 일반화된 것이라고 생각하시면 도움이 될 것입니다. 즉, <code>A</code>라는 행렬(행렬은 결국 이중
첨자로 된 (doubly subscripted) 배열이도 합니다.)이 주어지면, 아래의 연산을 수행한 결과인 <code>B</code>는
<code>A</code>를 전치한 행렬입니다. 
</p>
<div class="example">
<pre class="example">&gt; B &lt;- aperm(A, c(2,1))
</pre></div>

<p>이 경우의 연산은 좀 더 간단한 함수인 <code>t()</code>를 사용한 것과 같습니다. 
<a name="index-t"></a>
따라서, <code>B &lt;- t(A)</code>를 사용하면 동일한 결과를 얻을 수 있습니다. 
</p>
<hr>
<a name="g_t_d589_b82c_c758-_ae30_b2a5_b4e4"></a>
<a name="haengryeolyi-gineungdeul"></a>
<h3 class="section">5.7 행렬의 기능들</h3>



<p>위에서 살짝 언급했듯이, 행렬은 이중 첨자를 사용하는 배열입니다. 하지만, 행렬이라는 것은 배열 섹션과 분리해서 따로 설명해야할만큼
중요한 개념입니다. R은 행렬에 특화된 다양한 연산기능과 함수들을 제공합니다.몇가지 예를들면, 위에서 설명했던
<code>t(X)</code>는 행렬을 전치하는데 사용되는 함수이며, <code>nrow(A)</code>와 <code>ncol(A)</code>은 각각 행렬
<code>A</code>의 행과 열의 개수를 알려주는 함수입니다.
<a name="index-nrow"></a>
<a name="index-ncol"></a>
</p>

<hr>
<a name="Multiplication"></a>
<a name="haengryeolyi-gobsem"></a>
<h4 class="subsection">5.7.1 행렬의 곱셈</h4>

<a name="index-haengryeolyi-gobsem"></a>
<p>The operator <code>%*%</code> is used for matrix multiplication.
<a name="index-_0025_002a_0025"></a>
보통은 <em>n</em>행  <em>1</em>열의 행렬이나 <em>1</em>행 <em>n</em>열의 행렬은 상황에 따라 적절히
<em>n</em>-벡터로 사용될 수 있습니다. 하지만, 행렬의 곱셈식에서 사용되는 벡터는 곱셈을 수행하기 적합한 조건을 갖추기위해 (행렬의
곱셈을 수행하기 위해서는 앞 행렬의 행의 길이가 뒷행령의 열의 길이가 같아야 합니다.) 행벡터나 열백터로 자동적으로
변환됩니다. (그러나, 나중에 보게 되겠지만, 이러한 행이나 열 벡터로의 변환이 항상 가능한 것은 아닙니다.)
</p>
<p>만약, <code>A</code>와 <code>B</code> 모두 정방(square)행렬이라면, 다음의 식을 사용해서 원소단위별 곱셈을 수행할 수 있습니다.
</p>
<div class="example">
<pre class="example">&gt; A * B
</pre></div>

<p>하지만, 아래의 표현은 원소단위별 곱셈이 아닌 행렬의 곱셈이라는 것을 구분하셔야 합니다.
</p>
<div class="example">
<pre class="example">&gt; A %*% B
</pre></div>

<p>만약, <code>x</code>가 벡터라면 아래의 표현은 이차식(quadratic form)을 나타냅니다.
</p>
<div class="example">
<pre class="example">&gt; x %*% A %*% x
</pre></div>

<p><a name="DOCF14" href="#FOOT14"><sup>14</sup></a>
</p>
<a name="index-crossprod-1"></a>
<p>함수 <code>crossprod()</code>는 &ldquo;외적, 크로스프로덕트 (crossproduct)&rdquo;라고하며, 연산을 위해
<code>corssprod(X, y)</code>의 형태로 입력하면, 좀 더 효율적인 방법으로 <code>t(X) %*% y</code>와 같은 연산을
수행합니다.만약 함수 <code>crossprod()</code>에 두번째가 인자가 생략되어 있다면, 첫번째 인자를 두 번 사용하여 연산을 수행하게
됩니다.
</p>
<a name="index-diag"></a>
<p>함수 <code>diag()</code>는 입력받는 인자에 따라 다른 결과를 출력합니다. 만약 <code>diag(v)</code>와 같이 <code>v</code>라는
벡터 인자가 입력되면, 벡터 <code>v</code>의 각 구성요소를 대각원소로 갖는 대각행렬을 생성합니다.반면에 <code>diag(M)</code>과
같이 <code>M</code>라는 행렬 인자가 입력되면, 행렬 <code>M</code>이 가지는 대각원소들을 벡터의 형식으로 출력하게 됩니다.이것은
<small>MATLAB</small>에서 사용하는 함수 <code>diag()</code>과 비슷하게 작동한다고 보시면 됩니다.다소 혼란스러울 수도 있겠지만,
<code>diag(k)</code>와 같이 <code>k</code>라는 스칼라 인자가 입력되면, <code>k</code>행 <code>k</code>열을 가지는
단위행렬(identity matrix)이 생성된다는 점도 기억하시기 바랍니다.
</p>
<hr>
<a name="g_t_c120_d615_bc29_c815_c2dd_acfc-_c5ed_d589_b82c"></a>
<a name="seonhyeongbangjeongsiggwa-yeoghaengryeol"></a>
<h4 class="subsection">5.7.2 선형방정식과 역행렬</h4>

<a name="index-Linear-equations"></a>
<a name="index-solve"></a>
<p>선형방정식을 푼다는 것의 의미는 역행렬을 곱하는 것과 같습니다. 아래의 표현식이 주어지고, 행렬 <code>A</code>와 벡터 <code>b</code>만
알고 있는 경우, 벡터 <code>x</code>가 선형방정식의 해가 됩니다.
</p>
<div class="example">
<pre class="example">&gt; b &lt;- A %*% x
</pre></div>

<p>R에서는 아래와 같은 방법으로 선형방정식을 풀어서, <code>x</code>를 해로 구합니다. (약간의 정확도의 차이가 발생하는 경우도
있습니다.)
</p>
<div class="example">
<pre class="example">&gt; solve(A,b)
</pre></div>

<p>선형방정식을 좀 더 수학적으로 표현하면 <code>x
= A^{-1} %*% b</code> 입니다. 여기에서 <code>A^{-1}</code>은 행렬
<code>A</code>의 역행렬이며, 아래의 함수로 계산할 수 있습니다.
</p>
<div class="example">
<pre class="example">solve(A)
</pre></div>

<p>하지만, 위와 같이 역행렬을 이용하여 <code>x &lt;- solve(A) %*% b</code>를 계산하는 것은 함수
<code>solve(A,b)</code>를 사용하는 것보다 비효율적인데다 에러 발성이 가능성도 많아 실제로 많이 사용하지는 않습니다.
</p>
<p>다변량의 연산에 사용되는 이차행렬식(quadratic form) &nbsp;<code>x
%*% A^{-1} %*% x</code> &nbsp;은 <code>A</code>의 역행렬을 이용하는 것 보단 <code>x %*% solve(A,x)</code>으로
계산하는 편이 낫습니다. <a name="DOCF15" href="#FOOT15"><sup>15</sup></a> 
</p>
<hr>
<a name="g_t_ace0_c720_ac12_acfc-_ace0_c720_bca1_d130"></a>
<a name="goyugabsgwa-goyubegteo"></a>
<h4 class="subsection">5.7.3 고유값과 고유벡터</h4>
<a name="index-goyugabsgwa-goyubegteo"></a>

<a name="index-eigen"></a>
<p>함수 <code>eigen(Sm)</code>는 대칭행렬 (symmetric matrix) <code>Sm</code> 의 고유값(eigenvalues)과
고유벡터 (eigenvectors)를 계산해주며 아래처럼 사용합니다.
</p>
<div class="example">
<pre class="example">&gt; ev &lt;- eigen(Sm)
</pre></div>

<p>위 식을 실행한 결과로 <code>ev$val</code>라는 <code>Sm</code>의 고유값 벡터와 여기에 대응되는 <code>ev$vec</code>라는
고유벡터의 행렬을 구성요소로 갖는 리스트를 객체 ev에 저장합니다. 만약 단순히 고유값만 필요하다면 아래와 같이 하시면 됩니다: 
</p>
<div class="example">
<pre class="example">&gt; evals &lt;- eigen(Sm)$values
</pre></div>

<p><code>evals</code>이라는 객체는 고유값의 벡터만 포함하고 있을 뿐, 고유벡터는 저장되지 않았습니다.
</p>
<div class="example">
<pre class="example">&gt; eigen(Sm)
</pre></div>

<p>행렬의 크기가 큰 경우에는, 다음과 같이 식을 사용함으로써 고유벡터의 계산을 생략하는 편이 나을 수 있습니다.
</p>
<div class="example">
<pre class="example">&gt; evals &lt;- eigen(Sm, only.values = TRUE)$values
</pre></div>


<hr>
<a name="g_t_d2b9_c774_ac12-_bd84_d574-_bc0f-_d589_b82c_c2dd"></a>
<a name="teugigabs-bunhae-mic-haengryeolsig"></a>
<h4 class="subsection">5.7.4 특이값 분해 및 행렬식</h4>
<a name="index-Singular-value-decomposition"></a>

<a name="index-svd"></a>
<p>함수 <code>svd(M)</code>는 <code>M</code>이라는 임의의 행렬을 인자로 가지며 이 행렬에 대한 특이값 분해(the singular
value decomposition)를 수행합니다.이 연산의 결과는 세가지 부분으로 구성됩니다; 첫째는 <code>M</code>행렬의
열공간(column space)과 동일한 공간을 생성(span)하는 정규직교(orthonormal)열 벡터들로 구성된 행렬
<code>U</code>이고; 둘째는 이 행렬의 열공간(column space)이 <code>M</code> 행렬의 행공간(row space)과 동일한
공간을 생성(span)하는 정규직교(orthonormal)열 벡터들로 구성된 행렬 <code>V</code>; 셋째는 <code>M = U %*%
D %*% t(V)</code>라는 조건을 만족하는 양의 숫자들로 구성된 대각행렬 <code>D</code>입니다. <code>svd(M)</code>의 실행결과는 위의
세가지를 구성요소로 갖는 하나의 리스트이며, 각 구성요소들은 정의된대로 <code>d</code>, <code>u</code>, <code>v</code>라는 이름을
가집니다.
</p>
<p>만약 행렬 <code>M</code>이 정방(square)행렬이라면, 아래처럼 표현식을 사용하여 행렬 <code>M</code>의
행렬식(determinant)의 절대값을 계산할 수 있습니다.
</p>
<div class="example">
<pre class="example">&gt; absdetM &lt;- prod(svd(M)$d)
</pre></div>

<p>또한, 여러 행렬에 같은 계산을 반복적으로 사용하고 싶다면 아래와 같이 사용자 정의함수 <code>abdet()</code>를 작성하는 것도 가능할
것입니다. 이렇게  <code>absdet()</code> 함수를 정의해두면, 다른 R 함수처럼 필요할 때마다 사용할 수 있습니다. 
</p>
<div class="example">
<pre class="example">&gt; absdet &lt;- function(M) prod(svd(M)$d)
</pre></div>

<a name="index-Determinants"></a>
<p>약간은 단순하지만 유용하게 사용할 수 있는 또 다른 예로, 정방(square) 행렬의 트레이스(trace)를 계산해주는
<code>tr()</code> 함수를 작성하는 것도 생각해 볼 수 있습니다.[힌트:이 함수를 작성할 때 loop 문장을 사용할 필요가
없습니다. <code>diag()</code> 함수를 다시 찾아 보세요.]  
</p>
<a name="index-det"></a>
<a name="index-determinant"></a>
<p>R은 행렬식(determinant)과 그 부호(sign)을 구하는데 사용하는 <code>det</code>를 빌트인(builtin)함수로
제공합니다. 또다른 함수 <code>determinant</code>는 행렬식의 부호 뿐 아니라 모듈러스(modulus)(그리고 옵션으로 선택시
log 스케일에서의 모듈러스까지)의 결과도 함께 출력합니다. 이러한 함수들에 대해서는 나중에 좀 더 자세히 다루겠습니다.
</p>

<hr>
<a name="g_t_cd5c_c18c_c81c_acf1_bc95_acfc-QR-_bd84_d574_bc95"></a>
<a name="coesojegobbeobgwa-QR-bunhaebeob"></a>
<h4 class="subsection">5.7.5 최소제곱법과 QR 분해법</h4>
<a name="index-Least-squares-fitting"></a>
<a name="index-QR-decomposition"></a>

<p>함수 <code>lsfit()</code>은 최소제곱법 적합(least squares fitting)을 수행하여 얻은 결과들을 리스트 형태로
돌려줍니다.
</p>
<div class="example">
<pre class="example">&gt; ans &lt;- lsfit(X, y)
</pre></div>
<a name="index-lsfit"></a>

<p>만약, <code>y</code>가 관측값 벡터이고, <code>X</code>는 디자인 행렬이라고 할때, 아래와 같이 사용된 함수
<code>lsfit()</code>는 최소 제곱법 (least square)을 이용하여 적합한 값을 <code>ans</code>에 할당합니다.더 자세한
사항은 도움말을 참조하시길 바랍니다. 특히, 최소제곱법을 이용한 회귀분석에 대한 모형진단이 필요하시면 함수
<code>ls.diag()</code>를 찾아보시길 바랍니다. 특히, 이 함수를 사용해서 회귀모형을 적합하면, 원래 <code>X</code>의 열에
포함되지 않는 전체 평균이 하나의 항으로 포함된다는 점을 주의하시기 바랍니다. 더욱이 회귀분석을 수행할 때는 거의 대부분의 경우
<code>lsfit()</code> 보다는 <code>lm(.)</code>를 사용하는 것이 더욱 편리하다는 점도 알아두시면 좋을 것입니다. 
</p>
<a name="index-qr"></a>
<p>최소제곱법과 연관되어 있는 함수로는 <code>qr()</code>과 그에 연관된 함수족(allies)이 있습니다. 아래의 예제를 살펴보세요.
</p>
<div class="example">
<pre class="example">&gt; Xplus &lt;- qr(X)
&gt; b &lt;- qr.coef(Xplus, y)
&gt; fit &lt;- qr.fitted(Xplus, y)
&gt; res &lt;- qr.resid(Xplus, y)
</pre></div>

<p>위 문장들은 벡터 <code>y</code>를 <code>X</code> 공간 위에 직사영(orthogonal projection)시킨 값(즉, fitted
된 값)을  <code>fit</code>에, 그리고 그 직교여공간에 사영(the projection onto the orthogonal
complement)시킨 값 (즉, 잔차)를 <code>res</code>에, 그리고 사영을 통해 얻은 회귀계수(coefficient)의 벡터는
<code>b</code>에 저장합니다. 특히, <code>b</code>의 값은 <small>MATLAB</small>에서 &lsquo;백슬래쉬&rsquo; 연산자를 이용해서 얻은 것과
동일합니다.
</p>
<p>위의 연산을 위한 <code>X</code>가 이 full column rank라는 조건을 만족해야 하는 것은 아닙니다.이 조건이 만족되지 않는
경우, 선형독립이 아닌 열들을 찾아서 이들을 제거하면 됩니다.
</p>
<p>이런식으로 회귀계수를 계산하는 것은 앞에서 소개된 함수들을 이용하는 것 보다 훨씬 오래되고, 덜 자동화된 (low-level) 방법으로
최소제곱 적합법을 이용하는 방법입니다. 이런 식의 계산이 필요한 경우가 아직 가끔 있긴하지만, 거의 대부분의 경우 앞으로
<a href="#Statistical-models-in-R-_0028R_c5d0_c11c-_c0ac_c6a9_b418_b294-_d1b5_acc4_baa8_d615_b4e4_0029">Statistical models in R (R에서 사용되는 통계모형들)</a>에서 좀 더 설명하게 될 통계 모형 함수들을 사용하는
것으로 대체되고 있습니다.
</p>

<hr>
<a name="Forming-partitioned-matrices"></a>
<a name="cbind_0028_0029wa-rbind_0028_0029reul-iyonghayeo-bunhaldoen-haengryeoleul-johabhagi"></a>
<h3 class="section">5.8 <code>cbind()</code>와 <code>rbind()</code>를 이용하여 분할된 행렬을 조합하기</h3>
<a name="index-cbind"></a>
<a name="index-rbind"></a>

<p>위에서도 잠깐 언급했었지만, <code>cbind()</code>와 <code>rbind()</code>라는 함수는 벡터와 행렬을 묶어 새로운 행렬을 생성할
때 사용됩니다. 간단히 말해, <code>cbind()</code> 함수는 여러 행렬들을 세로로, 혹은 열방향으로 묶어서, 그리고
<code>rbind()</code> 함수는 가로로, 혹은 행방향으로 묶어서 새로운 행렬을 생성합니다. 
</p>
<p>아래 함수 <code>cbind()</code>에 사용될 입력인자는 임의의 길이를 가진 벡터이거나 같은 길이의 열,또는 같은 수의 행을 가진
행렬이어만 합니다. 이 함수를 적용하면 입력된 <var>arg_1</var>, <var>arg_2</var>, &hellip;이 각각의 열로 하는 하나의
행렬이 생성됩니다. 
</p>
<div class="example">
<pre class="example">&gt; X &lt;- cbind(<var>arg_1</var>, <var>arg_2</var>, <var>arg_3</var>, &hellip;)
</pre></div>

<p><code>cbind()</code>의 입력인자가 함께 입력된 다른 행렬의 열 길이 보다 짧은 길이를 가진 벡터인 경우가 있을 수 있습니다.이
경우, 길이가 더 짧은 벡터들은 행렬의 열의 길이(만약 행렬이 입력되지 않은 경우에는 가장 길이가 긴 벡터)에 맞추기 위해 그 구성요소를
반복 사용합니다.
</p>
<p>함수 <code>rbind()</code>는 함수 <code>cbind()</code>와 유사한 기능을 행에 대해 수행힙니다.
</p>
<p>이 함수의 경우, 입력된 벡터가 무엇이든 간에, 길이가 다를 경우 위와 같이 반복 사용되서 길이를 맞추는 것은 물론이고, 모든 인자를
행벡터로서 처리합니다. 
</p>
<p><code>X1</code>과 <code>X2</code>라는 두 행렬이 같은 개수의 행을 가지고 있다고 가정합니다. <code>1</code>로 구성된 열과 함께 위
둘을 열 방향으로 결합하여 새 행렬 <code>X</code>를 생성하기 위해, 아래와 같은 명령문을 사용할 수 있습니다.
</p>
<div class="example">
<pre class="example">&gt; X &lt;- cbind(1, X1, X2)
</pre></div>

<p><code>rbind()</code>이나 <code>cbind()</code>를 사용하면 얻어지는 결과는 항상 행렬입니다. 따라서,
<code>cbind(x)</code>와 <code>rbind(x)</code>는 벡터 <code>x</code>를 각각 하나의 열 혹은 하나의 행으로 구성된 행렬로
바꾸는 가장 단순한 방법일 것입니다.
</p>
<hr>
<a name="g_t_bc30_c5f4_c5d0-_c0ac_c6a9_b418_b294-_acb0_d569_d568_c218-c_0028_0029"></a>
<a name="baeyeoleseo-sayonghaneun-gyeolhab_0028concatenation_0029-hamsu-c_0028_0029"></a>
<h3 class="section">5.9 배열에서 사용하는 결합(concatenation) 함수 <code>c()</code></h3>

<p><code>cbind()</code>와 <code>rbind()</code> 함수의 경우 행렬이 가진 <code>dim</code> 속성에 기반해서 여러개의 행렬을
하나로 연결하는 반면, 함수 <code>c()</code>는 <code>dim</code>과 <code>dimnames</code> 속성 모두를 무시한 채 결합시킨다고
할 수 있습니다. 따라서, 경우에 따라서는 <code>c()</code>를 이용해야만 할 수 있습니다.
</p>
<p>이런식으로 배열의 속성을 무시하고 단순 벡터로 강제형변환하는 공식적으로 알려진 방법은 다음과 같이 <code>as.vector()</code>
함수를 이용하는 것입니다.
</p>
<div class="example">
<pre class="example">&gt; vec &lt;- as.vector(X)
</pre></div>
<a name="index-as_002evector"></a>

<p>하지만, 이와 비슷한 결과를 함수 <code>c()</code>의 이러한 부가적 성질을 활용함으로써 얻을 수도 있습니다. 
</p>
<div class="example">
<pre class="example">&gt; vec &lt;- c(X)
</pre></div>
<a name="index-c-2"></a>

<p>실제로는 다소 차이점이 있기는 하지만, 둘 중 어떤 함수를 이용하여 이 작업을 수행할 것인가는 단순히 프로그래밍 스타일의 차이일
뿐입니다.
</p>
<hr>
<a name="g_t_c694_c778_c744-_c774_c6a9_d558_c5ec-_b3c4_c218_bd84_d3ec_d45c-_c0dd_c131_d558_ae30"></a>
<a name="yoineul-iyonghayeo-dosubunpopyo-saengseonghagi"></a>
<h3 class="section">5.10 요인을 이용하여 도수분포표 생성하기</h3>
<a name="index-Tabulation"></a>

<p>우리는 앞부분에서 데이터를 그룹화하는데 요인 (factor)을 사용할 수 있음을 배웠습니다. 마찬가지로 만약 2개의 요인을 사용하면
2차원 분류(two way cross classification)를 정의할 수 있을 것이고, 더 나아가 k 개의 요인으로 k-차원의
분류가 가능할 것입니다.
<a name="index-table-1"></a>
함수 <code>table()</code>은 같은 길이를 가진 요인들을 분류해서 빈도분포표를 생성합니다.  즉, <em>k</em>개의 요인이 입력될
경우, 이 함수를 사용한 결과로 <em>k</em> 차원의 빈도의 배열이 생성됩니다. 
</p>
<p>예를 들어, 입력된 각 데이터가 지역(state)코드인 데이터 벡터인 <code>statef</code>라는 하나의 요인이 존재한다고
가정합시다. 아래의 명령문은 <code>statefr</code>라는 이름으로 샘플의 각 주별 빈도를 요약하는 표를 저장합니다.
</p>
<div class="example">
<pre class="example">&gt; statefr &lt;- table(statef)
</pre></div>

<p>이 표에 각 주 별 도수는 수준 (level)의 알파벳 이름순으로 정렬됩니다. 이와 같은 작업을 수행하는 좀 더 간단한 방법은 다음과
같습니다.
</p>
<div class="example">
<pre class="example">&gt; statefr &lt;- tapply(statef, statef, length)
</pre></div>

<p>이번에는 입련된 각 데이터가  소득수준 (&ldquo;income class&rdquo;)을 의미하는 <code>incomef</code>라는 요인을 가정
합시다. 이 소득수준의 경우, 함수 <code>cut()</code>를 사용해서 다음과 같이 생성할 수 있습니다.
</p>
<div class="example">
<pre class="example">&gt; factor(cut(incomes, breaks = 35+10*(0:7))) -&gt; incomef
</pre></div>
<a name="index-cut"></a>

<p>위에서 정의한 두 개의 요인에 대해 2차원 빈도표를 생성하면 다음과 같습니다:
</p>
<div class="example">
<pre class="example">&gt; table(incomef,statef)
         statef
incomef   act nsw nt qld sa tas vic wa
  (35,45]   1   1  0   1  0   0   1  0
  (45,55]   1   1  1   1  2   0   1  3
  (55,65]   0   3  1   3  2   2   2  1
  (65,75]   0   1  0   0  0   0   1  0
</pre></div>

<p>좀 더 많은 차원을 대상으로 빈도표를 작성하는 것도 이것과 크게 다르지 않습니다.
</p>
<hr>
<a name="g_t_b9ac_c2a4_d2b8_c640-_b370_c774_d130-_d504_b808_c784"></a>
<a name="riseuteuwa-deiteo-peureim"></a>
<h2 class="chapter">6 리스트와 데이터 프레임</h2>


<hr>
<a name="Lists-_0028_b9ac_c2a4_d2b8_0029"></a>
<a name="Lists-_0028riseuteu_0029"></a>
<h3 class="section">6.1 Lists (리스트)</h3>
<a name="index-Lists-_0028riseuteu_0029"></a>

<p>R에서 <em>리스트(list)</em>라는 것은 <em>컴포넌트 (components)</em>라고 불리는 일정한 순서로 정렬된 여러
객체들의 집합입니다.
</p>
<p>각각의 컴포넌트는 반드시 같은 모드(mode)나 형태(type)일 필요는 없습니다. 예를 들어, 하나의 리스트는 수치형 벡터, 논리형
벡터, 행렬, 복소수 벡터, 문자형 벡터, 함수 이외의 어떤 형태라도 컴포넌트로 포함할 수 있습니다. 리스트를 생성하는 아래의 간단한
예를 살펴보시기 바랍니다:   
</p>
<div class="example">
<pre class="example">&gt; Lst &lt;- list(name=&quot;Fred&quot;, wife=&quot;Mary&quot;, no.children=3,
              child.ages=c(4,7,9))
</pre></div>
<a name="index-list"></a>

<p>리스트에 포함된 컴포넌트들은 항상 <em>숫자로 구분(numbered)</em>되어 있으며, 따라서 각각의 컴포넌트를 이에 해당하는 숫자
(즉, 컴포넌트 인덱스)로 불러내는 것이 가능합니다. 따라서, <code>Lst</code>가 4개의 컴포넌트를 갖는 리스트라면, 각각의 컴포넌트는
각각 <code>Lst[[1]]</code>,<code>Lst[[2]]</code>, <code>Lst[[3]]</code> 그리고 <code>Lst[[4]]</code>로 불러낼
수 있습니다. 특히, <code>Lst[[4]]</code>가 첨자로 표현되는 구성요소를 가진 벡터인 경우, <code>Lst[[4]][1]</code>는 이
컴포넌트의 첫번째 구성요소를 의미합니다.   
</p>
<p>또 <code>Lst</code>가 리스트인 경우, <code>length()</code> 함수를 사용하면 (top level) 컴포넌트의 개수를 알 수
있습니다. 위의 예제를 계속 사용하면, <code>length(Lst)</code>는 4라는 값을 출력할 것입니다.
</p>
<p>리스트에 포함된 컴포넌트는 <em>이름(named)</em>으로 불러낼 수도 있는데, 이 경우 해당 컴포넌트의 이름에 해당하는 문자열을
위에서 숫자를 사용할 때 처럼 한 쌍의 이중대괄호 안에 넣어 사용하며, 좀 더 쉽게는 아래와 같은 표현식을 사용하는 것도 가능합니다.
</p>
<div class="example">
<pre class="example">&gt; <var>name</var>$<var>component_name</var>
</pre></div>

<p><var>name</var>는 리스트의 이름이고, 스트링 연산자($) 뒤의 <var>component_name</var>는 컴포넌트의 이름입니다.
</p>
<p>이렇게 이름으로 직접 불러내는 방법은 사용자가 해당 컴포넌트의 번호(인덱스)를 기억할 필요없이, 쉽고 정확하게 컴포넌트를 불러낼 수 있는
방법입니다.
</p>
<p>위의 예제로 다시 돌아가면, 
</p>
<p><code>Lst$name</code>이라는 것은 <code>Lst[[1]]</code>와 동일하고, <code>&quot;Fred&quot;</code>라는 값을 가집니다.
</p>
<p>또 <code>Lst$wife</code>는 <code>Lst[[2]]</code>와 동일하고 <code>&quot;Mary&quot;</code>라는 값을 가집니다.
</p>
<p><code>Lst$child.ages[1]</code>의 경우, <code>Lst[[4]][1]</code>와 동일하며, <code>4</code>라는 값을 가집니다.
</p>
<p>또한, 리스트의 컴포넌트 이름을 이중대괄호 안에 사용하는 것고 가능하며, 따라서 <code>Lst[[&quot;name&quot;]]</code>와
<code>Lst$name</code>은 동일합니다.이러한 사용법은 아래와 같이 리스트 컴포넌트의 이름이 다른 변수로 저장되어 있는 경우에 유용하게
사용될 수 있습니다.
</p>
<div class="example">
<pre class="example">&gt; x &lt;- &quot;name&quot;; Lst[[x]]
</pre></div>

<p>리스트를 사용하는데 있어 <code>Lst[[1]]</code>와 <code>Lst[1]</code>를 구분하는 것은 매우
중요합니다. &lsquo;<samp><code>[[<var>&hellip;</var>]]</code></samp>&rsquo;은 리스트 안의 한 개의 컴포넌트를 선택하기위해 사용하는 연산자인
반면,&lsquo;<samp><code>[<var>&hellip;</var>]</code></samp>&rsquo;은 일반적인 첨자로 사용되는 연산자입니다.따라서, 전자는 <em>리스트
<code>Lst</code>의 첫번째 컴포넌트</em>를 나타내므로, 만약 그 컴포넌트에 이름이 있어도 이름과 상관없이 해당 컴포넌트만을
불러냅니다. 하지만 후자는 리스트 <code>Lst</code>의 첫번째 구성요소만을 갖는 서브리스트(sublit)이므로, 이 구성요소에 이름이
있다면, 이름이 해당 서브리스트와 함께 불러집니다.
</p>
<p>컴포넌트들의 이름은 각각의 이름이 구분할 수 있는 최소한의 글자수로 된 약어로 나타내질 수 있습니다. 예를들면, 리스트
<code>Lst</code>가 <code>coefficients</code>와 <code>covariance</code>라는 이름의 두 개의 컴포넌트로 구성된 경우,
<code>Lst$coe</code>와 <code>Lst$cov</code>으로 간소화하여 불러낼 수 있습니다. 
</p>
<p>사실 컴포넌트들의 이름으로 구성된 벡터는 단순히 리스트의 속성 중 하나라고 볼 수 있으며, 다른 속성들처럼 다룰 수 있습니다. 물론
리스트를 제외한 다른 객체들 역시 <em>names</em>을 속성의 하나로 포함할 수 있습니다. 
</p>
<hr>
<a name="g_t_b9ac_c2a4_d2b8_b97c-_c0dd_c131_acfc-_c218_c815"></a>
<a name="riseuteureul-saengseonggwa-sujeong"></a>
<h3 class="section">6.2 리스트를 생성과 수정</h3>

<p>이미 만들어놓은 여러개의 객체를 <code>list()</code> 함수를 사용하여 새로운 리스트로 생성할 수 있습니다. 
</p>
<div class="example">
<pre class="example">&gt; Lst &lt;- list(<var>name_1</var>=<var>object_1</var>, <var>&hellip;</var>, <var>name_m</var>=<var>object_m</var>)
</pre></div>

<p>아래와 같은 할당문을 사용하면, (사용자가 자유롭게 선택한) <var>object_1</var>, <var>&hellip;</var>,
<var>object_m</var>와 같은 이름을 갖는 <em>m</em> 개의 컴포넌트로 구성된 리스트 <code>Lst</code>를 생성합니다. 만약
이렇게 이름을 할당하는 과정이 생략되면, 컴포넌트들은 숫자로만 구분됩니다.  새로운 리스트가 생성될 때 기존의 객체들은 단순히
컴포넌트로서 <em>복사된 것</em>이기 때문에 새로운 리스트의 생성이 기존의 객체에 아무런 영향을 주지 않습니다.
</p>
<p>리스트에 새로운 컴포넌트를 추가하고 싶을 경우, 아래와 같이 첨자를 이용하는 것도 가능합니다.
</p>
<div class="example">
<pre class="example">&gt; Lst[5] &lt;- list(matrix=Mat)
</pre></div>


<hr>
<a name="Concatenating-lists-_0028_b9ac_c2a4_d2b8-_c5f0_acb0_d558_ae30_0029"></a>
<a name="Concatenating-lists-_0028riseuteu-yeongyeolhagi_0029"></a>
<h4 class="subsection">6.2.1 Concatenating lists (리스트 연결하기)</h4>
<a name="index-Concatenating-lists-_0028riseuteu-yeongyeolhagi_0029"></a>

<a name="index-c-3"></a>
<p>여러개의 리스트를 하나로 묶고 싶은 경우, 아래와 같이 함수 <code>c()</code>를 이용하면 입력된 순서대로 하나로 묶인 리스트가
생성됩니다.
</p>
<div class="example">
<pre class="example">&gt; list.ABC &lt;- c(list.A, list.B, list.C)
</pre></div>

<p>앞 부분에서 연결함수를 사용해서 입력인자인 벡터들을 모두 연결해서 하나의 벡터로 생성했던 것과 비슷합니다. 다만, 리스트를 연결할 경우,
<code>dim</code>을 포함한 모든 리스트의 속성이 무시된 채 작업된다는 점 정도의 차이가 있을 뿐 입니다. 
</p>

<hr>
<a name="Data-frames-_0028_b370_c774_d130-_d504_b808_c784_0029"></a>
<a name="Data-frames-_0028deiteo-peureim_0029"></a>
<h3 class="section">6.3 Data frames (데이터 프레임)</h3>
<a name="index-Data-frames-_0028deiteo-peureim_0029"></a>

<p><em>데이터 프레임 (data frame)</em>은 <code>&quot;data.frame&quot;</code>이라는 클래스를 가진 리스트입니다.하지만 데이터
프레임을 리스트와 구분짓는 다음과 같은 몇가지 특징이 있습니다.
</p>
<ul>
<li> 우선, 데이터 프레임에 입력될 수 있는 자료는 반드시 (수치형, 문자형 또는 논리형) 벡터, 요인, 수치형 행렬, 리스트, 또는 다른
데이터 프레임 중 하나이어야만 합니다.
</li><li> 또 데이터 프레임을 구성하는 각각의 열은 변수로 인식되므로, 입력되는 행렬의 열의 개수, 리스트의 구성요소의 개수, 또는 데이터 프레임의
변수의 개수를 더한만큼 데이터 프레임의 크기가 확장됩니다. 
</li><li> 데이터 프레임에 입력되는 수치형 벡터, 논리형, 그리고 문자형 벡터들을은 모두 디폴트로 요인으로 강제형변환 되도록 지정되어 있으며,
입력된 벡터의 중복없이 정렬된 값을 그 수준으로 갖습니다. <a name="DOCF16" href="#FOOT16"><sup>16</sup></a>.
</li><li> 데이터 프레임 내의 벡터형 변수(즉, 열벡터)는 모두 <em>동일한 길이 (same length)</em>를 가져야하며, 행렬형 변수는 모두
같은 <em>행의 개수 (row size)</em>를 가져야합니다. 
</li></ul>

<p>많은 경우, 데이터 프레임이라는 것은 모드(mode)와 속성(attribute)이 조금 다른 행렬이 하나로 보아도 무방합니다. 따라서
행렬에서 했던 것 처럼, 행렬 인덱스를 사용하여 데이터 프레임을 행이나 열 중 일부를 임의로 선택할 수 있습니다.
</p>

<hr>
<a name="g_t_b370_c774_d130-_d504_b808_c784-_c0dd_c131_d558_ae30"></a>
<a name="deiteo-peureim-saengseonghagi"></a>
<h4 class="subsection">6.3.1 데이터 프레임 생성하기</h4>

<p>데이터 프레임의 열 (또는 컴포넌트)를 구성하게 될 객체들의 위에서 언급한 조건들을 충족시키면, 다음과 같이
<code>data.frame</code> 함수를 사용하여 데이터 프레임을 생성할 수 있습니다. 
<a name="index-data_002eframe"></a>
</p>
<div class="example">
<pre class="example">&gt; accountants &lt;- data.frame(home=statef, loot=incomes, shot=incomef)
</pre></div>

<p>위의 예제에서 사용된 <code>statef</code>는 이산형 데이터 벡터이고, <code>incomes</code>는 연속형 데이터 벡터, 그리고
<code>incomef</code>는 범주화된 값을 갖는 벡터입니다. 따라서 새로 생성될 데이터 프레임 <code>accountants</code>은
<code>home</code>, <code>loot</code>, 그리고 <code>shot</code>라는 세 변수로 구성되는데, 벡터 <code>statef</code>는
<code>home</code>라른 변수로, 벡터 <code>incomes</code>는 <code>loot</code>라는 변수로, 마지막으로 벡터
<code>incomef</code>는  <code>shot</code>라는 변수로 저장됨을 의미합니다.컴포넌트들이 위와 같은 데이터 프레임으로써의 요건을
만족하는 리스트라면 함수 <code>as.data.frame()</code>를 사용하여 데이터 프레임으로 <em>강제형변환
(coerced)</em>시키는 것이 가능합니다. 
<a name="index-as_002edata_002eframe"></a>
</p>
<p>이미 저장된 데이터를 가져와 데이터 프레임을 생성하기 위한 가장 쉬운 방법은 외부 파일에서 데이터를 읽어들일 때 사용하는
<code>read.table()</code> 함수를 사용하는 것 겁니다.이 함수에 대해서는 <a href="#Reading-data-from-files-_0028_d30c_c77c_b85c_bd80_d130-_b370_c774_d130-_c77d_c5b4_c624_ae30_0029">Reading data from files (파일로부터 데이터 읽어오기)</a>편에서 더 자세히 다루도록 하겠습니다.
</p>
<hr>
<a name="attach_0028_0029_c640-detach_0028_0029"></a>
<a name="attach_0028_0029-and-detach_0028_0029"></a>
<h4 class="subsection">6.3.2 <code>attach()</code> and <code>detach()</code></h4>
<a name="index-attach"></a>
<a name="index-detach"></a>

<p>스트링(<code>$</code>) 연산자는, <code>accountants$home</code>와 같이 리스트의 컴포넌트를 불러내기 위해 사용하지만 이
방법이 언제나 가장 편리한 것은 아닙니다. (특히 구성요소가 많은 경우라면,) 리스트나 데이터 프레임의 구성요소들의 이름을 필요한 동안만
변수이름처럼 나열해서 쓸 수 있도록하면, 한번에 하나씩 리스트 상의 이름을 사용해서 컴포넌트를 불러내는 번거로움을 피할 수 있습니다. 
</p>
<p><code>attach()</code> 함수의 경우, 리스트나 데이터 프레임과 같은 형태의  &rsquo;데이터베이스(database)&rsquo;를 인자로
받습니다. 따라서, 세개의 변수 <code>lentils$u</code>, <code>lentils$v</code>, <code>lentils$w</code>로 구성된
데이터 프레임<code>lentils</code>을 존재하고 여기에 <code>attach()</code> 함수를 사용하면, 해당 데이터 프레임의
탐색경로(search path)가 position&nbsp;2<!-- /@w -->로 바뀌며, 이것은 변수 <code>u</code>, <code>v</code>, <code>w</code>를
담지 않는  경로인 position&nbsp;1,작업&nbsp;<!-- /@w -->와 별개이므로, attach 함수가 적용된 데이터 프레임의 구성요소인
<code>u</code>, <code>v</code>, <code>w</code>변수들을 이들의 이름만으로(별도의 스트링 연산자나 인덱스를 사용하지 않고) 불러내는
것이 가능해집니다.   
</p>
<div class="example">
<pre class="example">&gt; attach(lentils)
</pre></div>

<p><code>attach()</code>를 사용시 주의할 점은, 다음과 같이 할당문을 사용할 경우, 이미 존재하던 데이터 프레임 내 컴포넌트인
<code>u</code>가 연산의 결과물로 대체된다기 보다는, 탐색경로 상의 position&nbsp;1,<!-- /@w -->에서 현재 작업 디렉토리에 새로운 변수
<code>u</code>가 생성되어 이미 존재하는 변수를 가로막게된다는 것 입니다. (따라서 위 명령문을 실행하면 <code>lentils</code>내
변수 <code>v</code>와 <code>w</code>의 더하기 연산의 결과가 <code>u</code>라는 이름의 객체가 되지만, 이 객체가 데이터 프레임
<code>lentils</code>내의 <code>u</code>로 저장되지는 않습니다. <code>attach()</code> 사용이후의 연산은 최상위 탐색경로인
position&nbsp;1<!-- /@w -->에서 이루어지므로 데이터 프레임이 위치하는 position&nbsp;2<!-- /@w -->에 있는<code>u</code>가 영향을 받지 않기
때문입니다.)
</p>
<div class="example">
<pre class="example">&gt; u &lt;- v+w
</pre></div>

<p>만약, 데이터 프레임 자체에 변경된 내용을 영구 저장하고싶다면, <code>$</code> 연산자를 사용하여 다음과 같이 따로 저장해야 합니다:
</p>
<div class="example">
<pre class="example">&gt; lentils$u &lt;- v+w
</pre></div>

<p>하지만, 이렇게 컴포넌트 <code>u</code>에 새로 저장된 값들은 데이터 프레임을 (<code>detach()</code>함수를 사용해서)
분리(detach)한 후 다시 (<code>attach()</code> 함수로) 불러들이는(attach) 과정을 통해서 확인할 수 있습니다.
</p>
<p>데이터 프레임을 현재 경로에서 다시 분리(detach)시키기 위해, 다음과 같이 <code>detach()</code> 함수를 사용할 수
있습니다.)
</p>
<div class="example">
<pre class="example">&gt; detach()
</pre></div>

<p>좀 더 정확하게 설명하면, 이 함수는 position&nbsp;2<!-- /@w --> 상에 위치한 현재 작업 중인 개체(데이터 프레임)을 이 경로에서
분리시키는 역할을 합니다. (즉, 경로가 position&nbsp;1<!-- /@w -->로 재변경 됩니다.) 따라서, 데이터 프레임을 분리하고 난 후의 현재
작업상황(context)에서는, 따로 <code>lentils$u</code>와 같이 지정하지 않는한, 변수 <code>u</code>, <code>v</code>
and <code>w</code>을 사용하는 것이 더이상 가능하지 않습니다. 개체(데이터 프레임)들이 탐색 경로 상 2 보다 큰 숫자의
position<!-- /@w -->에 위치할 경우, 이들을 해당 경로에서 분리(detach)하기위해  <code>detach</code> 함수에 경로 번호를
지정하는 것이 가능합니다. 하지만, 언제나<code>detach(lentils)</code> 또는 <code>detach(&quot;lentils&quot;)</code>과
같이 데이터 프레임의 이름을 직접 입력하는 편이 실수를 줄일 수 있는 보다 안전한 방법입니다.
</p>
<blockquote>
<p><b>Note:</b> R에서 리스트나 데이터 프레임은 반드시 position 2 또는 그 이상의 위치에만 연결할(attach) 수 있습니다. 또,
연결한다(attach)는 것은 존재하는 객체를 <em>복사(copy)</em>해서 가져온다는 의미입니다. 이렇게 연결된(attach)
개체들은<code>할당(assign)을 통하여</code> 변경하는 것이 가능합니다. 하지만, 이 경우 원래의 리스트나 데이터 프레임은 변경된 값에
영향을 받지 않습니다.
</p></blockquote>

<hr>
<a name="g_t_b370_c774_d130-_d504_b808_c784-_d65c_c6a9_d558_ae30"></a>
<a name="deiteo-peureim-hwalyonghagi"></a>
<h4 class="subsection">6.3.3 데이터 프레임 활용하기</h4>

<p>하나의 작업 디렉토리에서 여러 개의 작업을 동시에 수행하는데 도움이 될만한 팁을 하나 드리자면,
</p>
<ul>
<li> 데이터 프레임 내의 변수들은 잘 정의된 (well defined) 그리고 분명히 구분되는(separate) 개념을 담고있어야 하며,
이름만으로도 충분히 그 의미를 짐작할 수 있는 변수명을 사용해야 한다는 것 입니다.  
</li><li> position&nbsp;2<!-- /@w --> 상에서 적절한 데이터 프레임을 불러들여서(attach) 작업 중이라면, 연산의 결과물과 작업 중인
임시(temporary)변수들은 작업 디렉토리가 위치한 level&nbsp;1<!-- /@w -->에서 사용하도록 합니다;   
</li><li> 해당 작업을 끝내기 전, 작업 중인 변수들 중 나중에 다시 사용하기 위해 데이터 프레임 내에 저장하고 싶은 것이 있다면 <code>$</code>를
이용한 할당문으로 해당 변수를 저장한 다음, <code>detach()</code> 함수를 사용합니다;
</li><li> 마지막으로 아직 작업 디렉토리에 남아있는 임시로 사용했지만 더 이상 필요없는 변수들은 모두 삭제해서 작업 디렉토리를 깨끗하게 유지합니다.
</li></ul>

<p>이렇식으로 작업 공간을 유지하면, 같은 디렉토리 내에서 <code>x</code>, <code>y</code>, <code>z</code>와 같은 (매우 흔한 이름의)
변수들을 이용해서 여러 작업을 동시에 수행해야 하는 겅우라도 비교적 쉽게 변수들을 다룰 수 있습니다.
</p>
<hr>
<a name="Attaching-arbitrary-lists-_0028_c784_c758_c801_c778-_b9ac_c2a4_d2b8_b97c-_c5f0_acb0_d558_ae30_0029"></a>
<a name="Attaching-arbitrary-lists-_0028imyijeogin-riseuteureul-yeongyeolhagi_0029"></a>
<h4 class="subsection">6.3.4 Attaching arbitrary lists (임의적인 리스트를 연결하기)</h4>

<p>일반함수(generic function)의 하나인 <code>attach()</code>함수는 디렉토리나 데이터 프레임 뿐만 아니라 다른 클래스의
객체를 대상으로도 탐색경로(search path)를 연결(attach)하는 작업을 수행합니다. 특히, 객체의 모드가
<code>&quot;list&quot;</code>인 경우는 데이터프레임과 동일한 방법으로 사용 가능합니다:
</p>
<div class="example">
<pre class="example">&gt; attach(any.old.list)
</pre></div>

<p><code>attach()</code>에 의해서 연결된 객체는 <code>detach</code> 함수에 의해서 분리되며, 이때 해당 위치의 번호나, 좀 더
바람직하게는 해당 객체의 이름을 사용하여 분리될 대상을 구체적으로 지정할 수 있습니다.
</p>
<hr>
<a name="g_t_d0d0_c0c9_acbd_b85c_b97c-_ad00_b9ac_d558_ae30"></a>
<a name="tamsaeggyeongroreul-gwanrihagi"></a>
<h4 class="subsection">6.3.5 탐색경로를 관리하기</h4>
<a name="index-search"></a>
<a name="index-Search-path"></a>

<p><code>search</code> 함수는 현재 탐색경로를 보여줌으로서 사용자가 현재 연결하여 작업하고 있는 데이터 프레임 및 리스트 (그리고
패키지들)를 확인할 수 있도록 해줍니다. 처음으로 <code>search</code>를 수행하면 아래와 같은 결과가 출력됩니다. 여기서
<code>.GlobalEnv</code>라는 것은 현재 작업 중인 작업공간(workspace)을 의미합니다.
</p>
<div class="example">
<pre class="example">&gt; search()
[1] &quot;.GlobalEnv&quot;   &quot;Autoloads&quot;    &quot;package:base&quot;
</pre></div>
<p><a name="DOCF17" href="#FOOT17"><sup>17</sup></a>.
</p>
<p>데이터프레임 <code>lentils</code>을 연결(attached)하고나면, <code>search()</code>는 아래와 같은 결과를 보여줍니다.
</p>
<div class="example">
<pre class="example">&gt; search()
[1] &quot;.GlobalEnv&quot;   &quot;lentils&quot;      &quot;Autoloads&quot;    &quot;package:base&quot;
&gt; ls(2)
[1] &quot;u&quot; &quot;v&quot; &quot;w&quot;
</pre></div>

<p><code>ls</code> 혹은 <code>objects</code> 함수를 이용하여 탐색경로(serach path) 내의 어떤 위치(position
1,2,..)에서나 어떤 객체가 사용 중인지 확인할 수 있습니다. 위에서 함수 <code>ls()</code>안에 사용된 숫자 <em>2</em>는
position&nbsp;2<!-- /@w -->를 대상으로 한다는 의미입니다.
</p>
<p>마지막으로, 사용중인 데이터프레임을 분리(detach)하고나서  탐색경로(search path)에서 정말로 사라졌는지 확인합니다.
</p>
<div class="example">
<pre class="example">&gt; detach(&quot;lentils&quot;)
&gt; search()
[1] &quot;.GlobalEnv&quot;   &quot;Autoloads&quot;    &quot;package:base&quot;
</pre></div>

<hr>
<a name="Reading-data-from-files-_0028_d30c_c77c_b85c_bd80_d130-_b370_c774_d130-_c77d_c5b4_c624_ae30_0029"></a>
<a name="Reading-data-from-files-_0028pailrobuteo-deiteo-ilgeoogi_0029"></a>
<h2 class="chapter">7 Reading data from files (파일로부터 데이터 읽어오기)</h2>
<a name="index-Reading-data-from-files-_0028pailrobuteo-deiteo-ilgeoogi_0029"></a>

<p>용량이 큰 데이터 객체는 현재 작업하고 있는 R 세션에서 키보드로 입력하는 것보다는 외부에 저장되어 있는 데이터파일을 불러들이는
것이 편리하고 빠른 방법입니다. R의 입력 도구는 단순하여 요구조건이 다소 엄격하고 유연하지 않습니다. R 설계자들에 의해
R에서 데이터를 읽어들일 수 있는 요구사항을 충족시키기 위해 파일에디터(file editor) 혹은 Perl<a name="DOCF18" href="#FOOT18"><sup>18</sup></a>과 같은 다른 도구를 이용하여 여러분의 입력 파일을 수정할 수 있는 명백한 추측이
있습니다. 일반적으로 이것은 매우 단순합니다.
</p>
<p>만약 변수들이 데이터 프레임에서 다루어질 것이라면 (우리가 그렇게 될 것이라고 강하게 가정하는 것과 같이), 전체 데이터 프레임은
<code>read.table()</code> 함수에 의해 직접적으로 읽을 수 있습니다. 직접적으로 호출할 수 있는 보다 근본적인 입력 함수인
<code>scan()</code>도 있습니다.
</p>
<p>데이터의 입출력에 관한 더 자세한 사항에 대해서는 <em>R Data Import/Export</em> 문서를 참조하시길 바랍니다.
</p>

<hr>
<a name="The-read_002etable_0028_0029-function"></a>
<a name="read_002etable_0028_0029-hamsu"></a>
<h3 class="section">7.1 <code>read.table()</code> 함수</h3>
<a name="index-read_002etable"></a>

<p>데이터 프레임 전체를 한번에 불러오기 위해서는, 외부 파일이 특정한 형식을 가지고 있어야만 합니다.
</p>
<ul>
<li> 파일내의 첫번째 행은 데이터 프레임에서 각 변수들에 대해 <em>변수명</em>을 가져야 합니다. 

</li><li> 파일내의 첫 번째 행 다음 부터는 <em>행레이블(row label)</em>과 각 변수에 대한 변수값이 있어야 합니다. 
</li></ul>

<p>만약, 첫번째 행을 구성하는 항목들의 개수가 두번째 행을 구성하는 항목들의 개수보다 적을 경우, 강제적으로 첫번째 행의 구조에 따라
맞추어지게 됩니다. 따라서 데이터 프레임으로 읽어들일 파일의 처음 몇 줄은 다음과 같이 보여질 것입니다.
</p>
<blockquote>
<table class="cartouche" border="1"><tr><td>
<div class="example">
<pre class="example"><span class="roman">Input file form with names and row labels:</span>

     Price    Floor     Area   Rooms     Age  Cent.heat
01   52.00    111.0      830     5       6.2      no
02   54.75    128.0      710     5       7.5      no
03   57.50    101.0     1000     5       4.2      no
04   57.50    131.0      690     6       8.8      no
05   59.75     93.0      900     5       1.9     yes
...
</pre></div>
</td></tr></table>
</blockquote>

<p>기본적으로 R이 데이터 파일을 읽어올때, (행레이블를 제외하고) 예제와 같이 수치값(numeric item)은
숫자변수(numeric variables)로, 그렇지 않다면 <code>Cent.heat</code>와 같이 요인(factor)으로
비숫자변수(non-numeric variables)로 읽어들입니다. 
</p>
<p>함수 <code>read.table()</code>는 직접적으로 데이터 프레임을 읽어들이는데 사용될 수 있습니다.
</p>
<div class="example">
<pre class="example">&gt; HousePrice &lt;- read.table(&quot;houses.data&quot;)
</pre></div>

<p>여러분은 종종 행레이블을 직접적으로 포함하는 것을 생략하고 기본값을 사용하길 원하는 경우가 있습니다. 이러한 경우 그 파일에는 아래와
같이 행레이블 열이 생략되어 있을 것입니다. 
</p>
<blockquote>
<table class="cartouche" border="1"><tr><td>
<div class="example">
<pre class="example"><span class="roman">Input file form without row labels:</span>

Price    Floor     Area   Rooms     Age  Cent.heat
52.00    111.0      830     5       6.2      no
54.75    128.0      710     5       7.5      no
57.50    101.0     1000     5       4.2      no
57.50    131.0      690     6       8.8      no
59.75     93.0      900     5       1.9     yes
...
</pre></div>
</td></tr></table>
</blockquote>

<p>이런 경우에는 아래와 같이 <code>read.table()</code> 함수를 사용시 <code>header=TRUE</code> 옵션을 함께 사용합니다.
</p>
<div class="example">
<pre class="example">&gt; HousePrice &lt;- read.table(&quot;houses.data&quot;, header=TRUE)
</pre></div>

<p><code>header=TRUE</code> 옵션은 첫 번째 줄이 헤더 줄이라는 것을 특정하여 파일의 구조로부터의 의미에 의해 명시적인 행레이블이
주어지지 않았다는 것을 나타냅니다.
</p>

<hr>
<a name="The-scan_0028_0029-function"></a>
<a name="scan_0028_0029-hamsu"></a>
<h3 class="section">7.2 <code>scan()</code> 함수</h3>
<a name="index-scan"></a>

<p>데이터 벡터들이 같은 길이를 가지고 있고 이들은 동시에 병렬적으로 읽어들여진다고 가정해 보십시오. 그리고 벡터의 개수는 세개인데 첫번째
벡터는 문자형 모드를 가지고, 나머지 두 벡터는 수치형 모드를 가지며, 이 벡터들은 <code>input.dat</code>라는 파일내에 저장이
되어 있다고 가정합니다. <code>scan()</code>함수를 이용하여 세개의 벡터를 리스트 형식으로서 불러오는 첫 번째 단계는  다음과
같습니다.
</p>
<div class="example">
<pre class="example">&gt; inp &lt;- scan(&quot;input.dat&quot;, list(&quot;&quot;,0,0))
</pre></div>

<p><code>scan()</code>함수의 두번째 인자는 어떤 모드(mode)로서 그 세 가지 벡터들을 읽어올 것인가에 대한 더미 리스트
구조(dummy list structure)입니다. <code>inp</code>에 담겨진 결과는 그것의 구성요소가 읽혀진 세 벡터들인 리스트
입니다. 데이터 값들(data items)을 세 개의 구분된 벡터로 분해하기 위해서 다음과 같이 할당(assignments)을
이용합니다.
</p>
<div class="example">
<pre class="example">&gt; label &lt;- inp[[1]]; x &lt;- inp[[2]]; y &lt;- inp[[3]]
</pre></div>

<p>위에서 소개한 방법보다 더 편한 방법은 아래에서 보는 것과 같이 더미 리스트 구조를 사용할 때 바로 이름을 부여하는 것입니다. 그러한
경우 그 이름들은 읽혀진 벡터들에 접근하는데 사용될 수 있습니다. 예를 들어 다음과 같습니다.
</p>
<div class="example">
<pre class="example">&gt; inp &lt;- scan(&quot;input.dat&quot;, list(id=&quot;&quot;, x=0, y=0))
</pre></div>

<p>여러분이 각각의 변수들에 접근하길 원한다면 그것들은 다음과 같이 워킹프레임(the working frame)에서 변수들에
재할당(re-assigned)되거나 
</p>
<div class="example">
<pre class="example">&gt; label &lt;- inp$id; x &lt;- inp$x; y &lt;- inp$y
</pre></div>

<p>또는 그 리스트가 탐색경로의 position&nbsp;2<!-- /@w -->에 첨부될 수 있습니다(이에 대해서는 see <a href="#Attaching-arbitrary-lists-_0028_c784_c758_c801_c778-_b9ac_c2a4_d2b8_b97c-_c5f0_acb0_d558_ae30_0029">Attaching arbitrary lists (임의적인 리스트를 연결하기)</a>를 참고하시길 바랍니다).
</p>
<p>만약, 아래와 같이 두번째 인자가 리스트가 아닌 단일 숫자값이라면, 하나의 벡터가 읽혀지게 됩니다. 그리고 반드시 벡터의 모든 구성요소는
더미 값(dummy value)과 같이 동일한 모드를 가지고 있어야 합니다.
</p>
<div class="example">
<pre class="example">&gt; X &lt;- matrix(scan(&quot;light.dat&quot;, 0), ncol=5, byrow=TRUE)
</pre></div>

<p>더욱 정교한 입력 도구들이 사용가능하며 매뉴얼에 설명되어 있습니다.
</p>
<hr>
<a name="g_t_b0b4_c7a5_b41c-_b370_c774_d130_c14b_c744-_c774_c6a9_d558_ae30"></a>
<a name="naejangdoen-deiteoseseul-iyonghagi"></a>
<h3 class="section">7.3 내장된 데이터셋을 이용하기</h3>
<a name="index-naejangdoen-deiteoseseul-iyonghagi"></a>
<a name="index-data"></a>

<p>R은 기본적으로 대략 100여개의 데이터셋을 <strong>datasets</strong> 패키지를 통하여 제공하고 있고 (R과 함께 제공되는
추천 패키지를 포함하여) 다른 것들이 패키지들에 따라 사용가능합니다. 현재 사용가능한 데이터셋의 목록을 확인하고 싶으시다면 아래와 같이
<code>data()</code>함수를 이용하시면 됩니다.
</p>
<div class="example">
<pre class="example">data()
</pre></div>

<p>R 버전 2.0.0 부터 R과 함께 제공되는 모든 데이터셋은 아래에서 보여지는 것과 같이 데이터셋의 이름을 통하여 바로 접근이
가능합니다. 그러나 많은 패키지들이 아직 이전의 R로 데이터세트를 로드하는데 사용되었던 <code>data</code> 방법을 사용하고
있습니다. 예를 들어, 다음과 같습니다.
</p>
<div class="example">
<pre class="example">data(infert)
</pre></div>

<p>그리고 이것은 여기에서의 사례와 같이 표준패키지에서도 아직까지 사용될 수 있습니다. 대부분의 경우 이것은 동일한 이름의 R 객체를
로드할 것입니다. 그러나 몇몇의 사례에서 그것은 여러 객체를 로드하므로 로드될 것으로 기대되는 확인하기 위해 객체에 대한 온라인 도움말을
참고하시기 바랍니다.
</p>
<a name="dareun-R-paekijideulrobuteo-deiteoreul-rodinghagi"></a>
<h4 class="subsection">7.3.1 다른 R 패키지들로부터 데이터를 로딩하기</h4>

<p>만약 특정 패키지 내에 제공되어지는 데이터에 접근하고 싶다면 아래와 같이 <code>data()</code>함수의 <code>package</code>라는
인자를 사용합니다.
</p>
<div class="example">
<pre class="example">data(package=&quot;rpart&quot;)
data(Puromycin, package=&quot;datasets&quot;)
</pre></div>

<p>만약 특정 패키지가 <code>library</code> 함수를 이용하여 현재의 작업공간에 연결이 되어 있다면, 패키지에 내장된 데이터셋들은
자동으로 검색되게 됩니다.
</p>
<p>User-contributed packages can be a rich source of datasets.
</p>
<hr>
<a name="g_t_b370_c774_d130_b97c-_d3b8_c9d1_d558_ae30"></a>
<a name="deiteoreul-pyeonjibhagi"></a>
<h3 class="section">7.4 데이터를 편집하기</h3>

<a name="index-edit"></a>
<p>만약 사용자가 데이터 프레임이나 행렬의 일부내용을 수정 및 편집을 하고 싶을때 <code>edit</code>는 편집을 위하여 구분된 스프레드시트와
같은 환경을 가져옵니다. 이것은 한 번 불러온 데이터세트에 작은 변화를 주는데 유용합니다. 명령은 다음과 같습니다.
</p>
<div class="example">
<pre class="example">&gt; xnew &lt;- edit(xold)
</pre></div>

<p><code>edit()</code>함수는 데이터셋 <code>xold</code>을 편집한 뒤, 편집된 새로운 내용을 새로운 데이터셋 <code>xnew</code>로
저장한다는 의미입니다. 만약, 사용자가 원본 데이터셋 <code>xold</code> 자체를 변경하고자 한다면 가장 단순한 방법은
<code>fix(xold)</code> 함수를 이용하는 것인데 이것은 <code>xold &lt;- edit(xold)</code>와 동일한 표현입니다.
</p>
<p>Use
</p>
<div class="example">
<pre class="example">&gt; xnew &lt;- edit(data.frame())
</pre></div>

<p>만약에 여러분이 비어있는 데이터 프레임으로부터 윈도우즈 기반의 스프레드시트를 통하여 새로운 데이터를 입력하고자 한다면 아래와 같이 할 수
있습니다.
</p>

<hr>
<a name="g_t_d655_b960_bd84_d3ec_d568_c218"></a>
<a name="hwagryulbunpohamsu"></a>
<h2 class="chapter">8 확률분포함수</h2>
<a name="index-hwagryulbunpohamsu"></a>


<hr>
<a name="g_t_d1b5_acc4_bd84_d3ec_d45c_b4e4_c744-_d55c_b370-_bb36_c5b4-_b193_c740-R"></a>
<a name="tonggyebunpopyodeuleul-hande-muggeo-noheun-R"></a>
<h3 class="section">8.1 통계분포표들을 한데 묶어 놓은 R</h3>

<p>R의 많은 장점들 중 한가지는 다양한 통계분포표를 제공하는 것입니다. P(X &lt;= x)을 알려주는
누적확률(cumulative probability)값, 주어진 확률함수로부터 밀도(density)계산, 주어진 <em>q</em>에 해당하는
퀀타일(quantile)을 계산, P(X &lt;= x) &gt; q)라는 조건을 만족하는 <code>x</code>값
찾기 및 주어진 분포로부터의 난수를 생성할 수 있습니다.
</p>
<blockquote>
<table>
<thead><tr><th>Distribution</th><th>R name</th><th>additional arguments</th></tr></thead>
<tr><td>beta</td><td><code>beta</code></td><td><code>shape1, shape2, ncp</code></td></tr>
<tr><td>binomial</td><td><code>binom</code></td><td><code>size, prob</code></td></tr>
<tr><td>Cauchy</td><td><code>cauchy</code></td><td><code>location, scale</code></td></tr>
<tr><td>chi-squared</td><td><code>chisq</code></td><td><code>df, ncp</code></td></tr>
<tr><td>exponential</td><td><code>exp</code></td><td><code>rate</code></td></tr>
<tr><td>F</td><td><code>f</code></td><td><code>df1, df2, ncp</code></td></tr>
<tr><td>gamma</td><td><code>gamma</code></td><td><code>shape, scale</code></td></tr>
<tr><td>geometric</td><td><code>geom</code></td><td><code>prob</code></td></tr>
<tr><td>hypergeometric</td><td><code>hyper</code></td><td><code>m, n, k</code></td></tr>
<tr><td>log-normal</td><td><code>lnorm</code></td><td><code>meanlog, sdlog</code></td></tr>
<tr><td>logistic</td><td><code>logis</code></td><td><code>location, scale</code></td></tr>
<tr><td>negative binomial</td><td><code>nbinom</code></td><td><code>size, prob</code></td></tr>
<tr><td>normal</td><td><code>norm</code></td><td><code>mean, sd</code></td></tr>
<tr><td>Poisson</td><td><code>pois</code></td><td><code>lambda</code></td></tr>
<tr><td>signed rank</td><td><code>signrank</code></td><td><code>n</code></td></tr>
<tr><td>Student&rsquo;s t</td><td><code>t</code></td><td><code>df, ncp</code></td></tr>
<tr><td>uniform</td><td><code>unif</code></td><td><code>min, max</code></td></tr>
<tr><td>Weibull</td><td><code>weibull</code></td><td><code>shape, scale</code></td></tr>
<tr><td>Wilcoxon</td><td><code>wilcox</code></td><td><code>m, n</code></td></tr>
</table>
</blockquote>

<p>위의 표를 잘 살펴보면 하나의 규칙을 알 수 있습니다. &lsquo;<samp>d</samp>&rsquo;로 시작하는 함수명은 확률밀도(density)를 구하기 위해 사용이
되고,&lsquo;<samp>p</samp>&rsquo;로 시작하는 함수명은 누적확률값(cumulative probability)를 구하기 위해 사용이
되며,&lsquo;<samp>q</samp>&rsquo;로 시작하는 함수명은 퀀타일(quantile)을 구하며,&lsquo;<samp>r</samp>&rsquo;로 시작하는 함수명은 시뮬레이션을 위한 난수를
생성하는데 사용됩니다.또한, <code>d<var>xxx</var></code>의 첫번째 인자는 <code>x</code>이며,<code>p<var>xxx</var></code>는
<code>q</code>, <code>q<var>xxx</var></code>는 <code>p</code>,<code>r<var>xxx</var></code>는
<code>n</code>입니다(<code>rhyper</code>, <code>rsignrank</code> 그리고 <code>rwilcox</code>의 경우에는
<code>nn</code>입니다).모든 함수에 non-centrality parameter(비중심화 모수)인  <code>ncp</code>를 사용할 수
있는 것은 아니므로 보다 더 자세한 사항은 온라인 도움말을 참고하십시오.
</p>
<p><code>p<var>xxx</var></code>와 <code>q<var>xxx</var></code> 함수들은 모두 <code>lower.tail</code>와
<code>log.p</code>라는 논리인자(logical arguments)를 가지며, <code>d<var>xxx</var></code>는 인자
<code>log</code>를 가집니다. 이러한 옵션의 사용은 아래에서 보이는 바와 같은 방법으로 생존분석(survival analysis)에서
사용되는 H(t) = -log(1-F(t))이라는 누적 <em>hazard</em>
함수의 계산을 가능하게 합니다.
</p>
<div class="example">
<pre class="example"> - p<var>xxx</var>(t, ..., lower.tail = FALSE, log.p = TRUE)
</pre></div>

<p>또한, <code>d<var>xxx</var>(..., log = TRUE)</code>와 같은 인자의 설정은 직접적으로 더 정교한
로그우도(log-likelihood) 값을 얻을 수 있도록 해줍니다.
</p>
<p>더 나아가 정규분포로부터 얻은 샘플에 대해서 표준화된 범위에 대한 분포를 함수 <code>ptukey</code>와 <code>qtukey</code>를
통하여 얻을 수 있습니다. 또한, 멀티노미얼 (multinomial) 분포에 대한 밀도값과 난수생성은 <code>dmultinom</code>과
<code>rmultinom</code>이라는 함수를 통하여 얻을 수 있습니다. 더 많은 분포에 대해서는 <a href="http://CRAN.R-project.org/package=SuppDists"><strong>SuppDists</strong></a>라는
사용자개발패키지(contributed packages)를 찾아보시길 바랍니다.
</p>
<p>밀도함수를 활용하는 두 가지 예제입니다.
</p>
<div class="example">
<pre class="example">&gt; ## <span class="roman">2-tailed p-value for t distribution</span>
&gt; 2*pt(-2.43, df = 13)
&gt; ## <span class="roman">upper 1% point for an F(2, 7) distribution</span>
&gt; qf(0.01, 2, 7, lower.tail = FALSE)
</pre></div>

<p>R에서 어떻게 난수를 생성하는지 알고 싶으시다면 온라인 도움말 <code>RNG</code>를 살펴보시길 바랍니다.
</p>
<hr>
<a name="g_t_b370_c774_d130_c758-_bd84_d3ec-_c0b4_d3b4_bcf4_ae30"></a>
<a name="deiteoyi-bunpo-salpyeobogi"></a>
<h3 class="section">8.2 데이터의 분포 살펴보기</h3>

<p>많은 방법을 통하여 주어진 (일변량) 데이터세트의 분포를 확인해 볼 수 있습니다. 가장 쉬운 방법은 함수 <code>summary</code> 혹은
<code>fivenum</code>를 이용하여 약간 다른 의미의 수치적 요약정보를 살펴 보는 것입니다. 
<a name="index-summary"></a>
<a name="index-fivenum"></a>
그리고 <code>stem</code> 함수를 이용하여 &quot;줄기-잎&quot; 그림(&quot;stem and leaf&quot; plot)을 이용하여 확인해 볼수도 있습니다.
<a name="index-stem"></a>
</p>
<div class="example">
<pre class="example">&gt; attach(faithful)
&gt; summary(eruptions)
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max.
  1.600   2.163   4.000   3.488   4.454   5.100
&gt; fivenum(eruptions)
[1] 1.6000 2.1585 4.0000 4.4585 5.1000
&gt; stem(eruptions)

  The decimal point is 1 digit(s) to the left of the |

  16 | 070355555588
  18 | 000022233333335577777777888822335777888
  20 | 00002223378800035778
  22 | 0002335578023578
  24 | 00228
  26 | 23
  28 | 080
  30 | 7
  32 | 2337
  34 | 250077
  36 | 0000823577
  38 | 2333335582225577
  40 | 0000003357788888002233555577778
  42 | 03335555778800233333555577778
  44 | 02222335557780000000023333357778888
  46 | 0000233357700000023578
  48 | 00000022335800333
  50 | 0370
</pre></div>

<p>실은 줄기-잎 그림은 히스토그램과 비슷하며 R은 히스토그램을 제공하는 <code>hist</code> 함수를 가지고 있습니다.
<a name="index-hist"></a>
</p>
<div class="example">
<pre class="example">&gt; hist(eruptions)
## <span class="roman">make the bins smaller, make a plot of density</span>
&gt; hist(eruptions, seq(1.6, 5.2, 0.2), prob=TRUE)
&gt; lines(density(eruptions, bw=0.1))
&gt; rug(eruptions) # <span class="roman">show the actual data points</span>
</pre></div>

<a name="index-density"></a>
<a name="index-Density-estimation"></a>
<p>위의 예제에서 사용된 것과 같이 히스토그램보다 좀 더 정교한 밀도그림(density plot)은 <code>density</code> 함수에 의해서
얻을 수 있고 우리는 이 예제에서 <code>density</code>에 의해 만들어진 선을 추가하였습니다. <code>density</code>함수의
<code>bw</code>(bandwidth) 인자의 값은 trial-and-error를 통해 얻어집니다. (Bandwidth의 선택에 있어서
자동화된 방법이 있는데, <code>bw='SJ'</code>를 이용해보시길 바랍니다).
</p>
<img src="images/hist.png" alt="images/hist">

<p><code>ecdf</code> 함수를 이용하여 경험적 누적 분포 함수(empirical cumulative distribution
function)를 그려 볼 수 있습니다.
<a name="index-ecdf"></a>
<a name="index-Empirical-CDFs"></a>
</p>
<div class="example">
<pre class="example">&gt; plot(ecdf(eruptions), do.points=FALSE, verticals=TRUE)
</pre></div>

<p>이 분포는 표준정규분포와는 많은 차이가 있음을 명백히 알 수 있습니다. 하지만, 화산폭발이 3분이상 지속될 경우에 대한 분포는 어떨까요?
3분이상의 데이터으로부터의 생성된 누적분포를 만들어 본뒤 그 위에 정규분포와 겹쳐봄으로서 비교해봅니다.
</p>
<div class="example">
<pre class="example">&gt; long &lt;- eruptions[eruptions &gt; 3]
&gt; plot(ecdf(long), do.points=FALSE, verticals=TRUE)
&gt; x &lt;- seq(3, 5.4, 0.01)
&gt; lines(x, pnorm(x, mean=mean(long), sd=sqrt(var(long))), lty=3)
</pre></div>

<img src="images/ecdf.png" alt="images/ecdf">

<p>Q-Q 플랏을 이용하여 화산폭발 3분이상의 데이터에 대한 정규성을 검토해보는 것도 도움이 됩니다.
<a name="index-Quantile_002dquantile-plots"></a>
<a name="index-qqnorm"></a>
<a name="index-qqline"></a>
</p>
<div class="example">
<pre class="example">par(pty=&quot;s&quot;)       # arrange for a square figure region
qqnorm(long); qqline(long)
</pre></div>

<p>Q-Q 플랏으로부터 오른쪽 꼬리 부분이 생각보다 짧은 것을 제외하고는 정규분포를 대체적으로 따르는 것 같습니다. 그럼
<code>t</code>-분포함수로부터 생성된 난수의 분포와는 어떤 관계를 가질지 비교해 보십시오.
</p>
<img src="images/QQ.png" alt="images/QQ">

<div class="example">
<pre class="example">x &lt;- rt(250, df = 5)
qqnorm(x); qqline(x)
</pre></div>

<p><code>t</code>-분포로부터 얻어진 난수의 분포가 정규분포의 꼬리보다 길다는 것을 알 수 있습니다. 우리는 다음과 같은 방법으로 생성된
분포에 대한 Q-Q plot을 만들어 볼 수 있습니다.
</p>
<div class="example">
<pre class="example">qqplot(qt(ppoints(250), df = 5), x, xlab = &quot;Q-Q plot for t dsn&quot;)
qqline(x)
</pre></div>

<p>마지막으로 정규성과 얼마나 따르는지를 확인하는 테스트를 수행하고자 할 것입니다. R은 아래와 같은 Shpiro-Wilk 테스트를
제공합니다.
<a name="index-Shapiro_002dWilk-test"></a>
<a name="index-shapiro_002etest"></a>
</p>
<div class="example">
<pre class="example">&gt; shapiro.test(long)

Shpiro-Wilk 테스트 외에도 Kolmogorov-Smirnov 테스트를 이용하여 정규성을 확인해 볼 수 있습니다.data:  long
W = 0.9793, p-value = 0.01052
</pre></div>

<p>and the Kolmogorov-Smirnov test
<a name="index-Kolmogorov_002dSmirnov-test"></a>
<a name="index-ks_002etest"></a>
</p>
<div class="example">
<pre class="example">&gt; ks.test(long, &quot;pnorm&quot;, mean = mean(long), sd = sqrt(var(long)))

         One-sample Kolmogorov-Smirnov test

data:  long
D = 0.0661, p-value = 0.4284
alternative hypothesis: two.sided
</pre></div>

<p>(여기에서는 우리가 같은 표본으로부터 정규분포의 모수를 추정해왔던 것과 같은 분포 이론은 적용되지 않음에 유의하십시오.)
</p>
<hr>
<a name="g_t_c77c_d45c_bcf8_acfc-_c774_d45c_bcf8-_ac80_c815"></a>
<a name="ilpyobongwa-ipyobon-geomjeong"></a>
<h3 class="section">8.3 일표본과 이표본 검정</h3>
<a name="index-ilpyobongwa-ipyobon-geomjeong"></a>

<p>지금까지 하나의 표본을 정규분포와 비교해 보았습니다. 두 개의 샘플을 비교하고자 한다면 더 많은 작업이 요구될 것입니다. R에서는
다음 예제에 사용되는 통계적 테스트를 포함하여 모든 전형적인 테스트들을 <strong>stats</strong> 패키지에 넣어두었습니다.
</p>
<p>1995년에 Rice가 the latent heat of the fusion of ice (<em>cal/gm</em>)에 대해서 연구한
논문의 490 쪽에 게재된 내용을 고려해 보시기 바랍니다. 다음 두 개의 데이터셋이 이용되었습니다.
</p>
<div class="example">
<pre class="example">Method A: 79.98 80.04 80.02 80.04 80.03 80.03 80.04 79.97
          80.05 80.03 80.02 80.00 80.02
Method B: 80.02 79.94 79.98 79.97 79.97 80.03 79.95 79.97
</pre></div>

<p>박스플랏(boxplot)은 두 개의 샘플에 대하여 간단한 시각적 비교를 제공합니다.
</p>
<div class="example">
<pre class="example">A &lt;- scan()
79.98 80.04 80.02 80.04 80.03 80.03 80.04 79.97
80.05 80.03 80.02 80.00 80.02

B &lt;- scan()
80.02 79.94 79.98 79.97 79.97 80.03 79.95 79.97

boxplot(A, B)
</pre></div>
<a name="index-boxplot"></a>
<a name="index-Box-plots"></a>

<p>첫번째 그룹이 두번째 그룹보다 더 높은 결과를 보여주는 것같습니다.
</p>
<img src="images/ice.png" alt="images/ice">

<p>각각의 데이터의 평균이 같은지를 테스트하기 위해서 아래와 같이 <em>unpaired</em> <em>t</em>-테스트를 수행해 봅니다.
<a name="index-Student_0027s-t-test"></a>
<a name="index-t_002etest"></a>
</p>
<div class="example">
<pre class="example">&gt; t.test(A, B)

         Welch Two Sample t-test

data:  A and B
t = 3.2499, df = 12.027, p-value = 0.00694
alternative hypothesis: true difference in means is not equal to 0
95 percent confidence interval:
 0.01385526 0.07018320
sample estimates:
mean of x mean of y
 80.02077  79.97875
</pre></div>

<p>테스트의 결과는 평균의 차이가 정규분포를 따른다고 가정할때 통계적으로 의미가 있음을 나타내고 있습니다. 여기에서 한가지 알아야 할 점은
R은 기본적으로 두 데이터의 분산이 같다고 가정하지 않는다는 것입니다. 이것은 <small>S-PLUS</small>에서 제공하는
<code>t.test</code>와 동일합니다. 따라서 두 데이터의 분산이 같은지에 대해서 F-테스트를 시행해 보아야 할 것입니다. 이 때, 두
데이터는 정규분포로부터 얻어진 샘플이라고 가정합니다.
</p>
<div class="example">
<pre class="example">&gt; var.test(A, B)

         F test to compare two variances

data:  A and B
F = 0.5837, num df = 12, denom df =  7, p-value = 0.3938
alternative hypothesis: true ratio of variances is not equal to 1
95 percent confidence interval:
 0.1251097 2.1052687
sample estimates:
ratio of variances
         0.5837405
</pre></div>
<a name="index-var_002etest"></a>

<p>테스트의 결과는 두 데이터의 분산은 통계적으로 차이가 없음을 의미하므로, 두 데이터의 분산이 같다고 가정하는 전형적인 t-테스트를
사용해도 무방합니다.
</p>
<div class="example">
<pre class="example">&gt; t.test(A, B, var.equal=TRUE)

         Two Sample t-test

data:  A and B
t = 3.4722, df = 19, p-value = 0.002551
alternative hypothesis: true difference in means is not equal to 0
95 percent confidence interval:
 0.01669058 0.06734788
sample estimates:
mean of x mean of y
 80.02077  79.97875
</pre></div>

<p>모든 테스트들이 두 데이터가 정규분포로부터 얻어진 샘플임을 가정하고 있으나, two-sample Wilcoxon 혹은
Mann-Whitney 테스트에 필요한 가정은 분포가 단순히 연속형이어야 한다는 것입니다.
</p>
<a name="index-Wilcoxon-test"></a>
<a name="index-wilcox_002etest"></a>
<div class="example">
<pre class="example">&gt; wilcox.test(A, B)

         Wilcoxon rank sum test with continuity correction

data:  A and B
W = 89, p-value = 0.007497
alternative hypothesis: true location shift is not equal to 0

Warning message:
Cannot compute exact p-value with ties in: wilcox.test(A, B)
</pre></div>

<p>테스트를 수행한 결과에 경고가 있음을 알 수 있습니다. 이것은 아마도 각각의 샘플안에 동일한 값을 가지는 데이터들이 존재하기
때문일것입니다. 따라서 연속형 분포를 가정하기 보다는 데이터가 이산형분포로부터 나왔다고 생각하는게 올바를 것입니다(혹은 이것은
rounding 으로부터 나온 결과일 수 도 있습니다).
</p>
<p>두 개의 샘플을 시각적으로 비교해 보는데 여러가지 방법이 있을 수 있습니다. 그 중에서 두 개의 박스플랏을 동시에 비교해보는 것은 이미
해 보았습니다.
</p>
<div class="example">
<pre class="example">&gt; plot(ecdf(A), do.points=FALSE, verticals=TRUE, xlim=range(A, B))
&gt; plot(ecdf(B), do.points=FALSE, verticals=TRUE, add=TRUE)
</pre></div>

<p>위에서 사용된 코드는 두개의 emprical CDFs (누적확률분포)를 비교할 것입니다. 또한 <code>qqplot</code> 함수를 이용하여
두 개의 샘플에 대한 Q-Q 플랏을 생성할 수도 있습니다. 아래의 코드는 일반 연속 분포를 가정하여 두 개의 <code>ecdf</code>의
최대수직거리차이(the maximal vertical distance)에 대하여 Kolmogorov-Smirnov 테스트를 수행합니다.
</p>
<div class="example">
<pre class="example">&gt; ks.test(A, B)

         Two-sample Kolmogorov-Smirnov test

data:  A and B
D = 0.5962, p-value = 0.05919
alternative hypothesis: two-sided

Warning message:
cannot compute correct p-values with ties in: ks.test(A, B)
</pre></div>

<hr>
<a name="Loops-and-conditional-execution-_0028_bc18_bcf5-_bc0f-_c870_ac74_bd80-_c2e4_d589_0029"></a>
<a name="geurubhwa_002c-banbogmun_002c-geurigo-jogeonbu-silhaeng"></a>
<h2 class="chapter">9 그룹화, 반복문, 그리고 조건부 실행</h2>
<a name="index-Loops-and-conditional-execution-_0028banbog-mic-jogeonbu-silhaeng_0029"></a>


<hr>
<a name="g_t_adf8_b8f9_d654_b41c-_d45c_d604"></a>
<a name="geurubhwadoen-pyohyeon"></a>
<h3 class="section">9.1 그룹화된 표현</h3>
<a name="index-geurubhwadoen-pyohyeon"></a>

<p>R은 명령어 형식으로 결과값을 반환하는 함수 또는 표현을 사용하는 점에서 표현언어(expression
language)입니다.결과값를 재사용할 수 있도록 표현식에 할당하며, 이 표현식을 어느 곳에서든지 재사용할수도 있고 다중할당도
가능합니다.
</p>
<p>또한, <code>{<var>expr_1</var>; <var>&hellip;</var>; <var>expr_m</var>}</code>와 같이 여러개의 명령들을 중괄호로
한데 묶어 이것을 또한 표현식으로도 사용할 수 있습니다. 이렇게 중괄호로 묶은 것을 그룹화된 표현식이라고 하고, 이것의 결과는 그룹내의
맨 마지막 명령문이 실행되었을때 얻어지게 됩니다. 이렇게 그룹화된 표현식 역시 더 큰 표현식의 일부분으로도 사용될 수 있습니다.
</p>
<hr>
<a name="g_t_c81c_c5b4_bb38"></a>
<a name="jeeomun"></a>
<h3 class="section">9.2 제어문</h3>
<a name="index-jeeomun"></a>


<hr>
<a name="Conditional-execution"></a>
<a name="jogeonbu-silhaeng_003a-if-mun"></a>
<h4 class="subsection">9.2.1 조건부 실행: <code>if</code> 문</h4>
<a name="index-if"></a>

<p>조건문은 아래와 같은 형식을 가집니다.
</p>
<div class="example">
<pre class="example">&gt; if (<var>expr_1</var>) <var>expr_2</var> else <var>expr_3</var>
</pre></div>
<a name="index-if-1"></a>
<a name="index-else"></a>

<p><var>expr_1</var>은 반드시 참 혹은 거짓이라는 단 하나의 논리형 값을 가져야만 합니다.
</p>
<a name="index-_0026_0026"></a>
<a name="index-_007c_007c"></a>
<p><code>&amp;&amp;</code>와 <code>||</code>는 종종 <code>if</code>이라는 조건문과 함께 쓰이는 &ldquo;short-circuit&rdquo;
연산자입니다.<code>&amp;</code>와 <code>|</code>가 벡터내 구성요소 단위의 연산을 수행하는 반면, <code>&amp;&amp;</code>와 <code>||</code>는
길이가 1인 벡터들에만 적용되고 필요한 경우 그것의 두 번째 인자만 평가합니다(evaluate).
</p>
<a name="index-ifelse"></a>
<p>R은 벡터라이즈(vectorized)된 버전의 <code>if</code>/<code>else</code> 조건문인 <code>ifelse</code> 함수를
제공하고 있습니다. 이것은 <code>ifelse(condition, a, b)</code>의 형식을 가지고 만약
<code>condition[i]</code> 이 참이면 <code>a[i]</code>를, 거짓이면 <code>b[i]</code>를 결과값으로 가지게 됩니다.
</p>

<hr>
<a name="Repetitive-execution"></a>
<a name="banbogjeog-silhaeng_003a-forreul-iyonghan-banbog_002c-repeat-geurigo-while"></a>
<h4 class="subsection">9.2.2 반복적 실행: <code>for</code>를 이용한 반복, <code>repeat</code> 그리고 <code>while</code></h4>
<a name="index-for"></a>

<p>다음은 <code>for</code> 루프를 이용한 반복문에 대한 형식입니다.
</p>
<div class="example">
<pre class="example">&gt; for (<code><var>name</var></code> in <var>expr_1</var>) <var>expr_2</var>
</pre></div>

<p><code><var>name</var></code>은 루프(loop) 변수입니다. <var>expr_1</var>은 흔히 <code>1:20</code>과 같이 사용되는 계열로
벡터표현식이고 <var>expr_2</var>는 더미(dummy) <em>name</em>의 방법으로 씌여진
하위표현식(sub-expressions)과 함께 그룹화된 표현식인 경우가 종종 있습니다. <var>expr_2</var>는
<var>expr_1</var>의 벡터결과에서의 값을 통해 <var>name</var> 처럼 반복적으로 평가됩니다(evaluated).
</p>
<p>예를들어, 만약 <code>ind</code>가 그룹멤버쉽을 나타낸다면, 각 그룹별로 <code>y</code>와 <code>x</code>의 관계를 살펴 볼 수 있는
플랏(plot)을 생성하고자 하는 경우를 가정해 봅니다.이를 수행하기 위한 한가지 옵션은 어떤 특정 요인이 가지고 있는 수준별로 플랏을
생성해주는 함수 <code>coplot()</code> <a name="DOCF19" href="#FOOT19"><sup>19</sup></a> 을 이용하는 것입니다. 또 다른 방법으로는 아래와 같이 하는 것입니다.
</p>
<div class="example">
<pre class="example">&gt; xc &lt;- split(x, ind)
&gt; yc &lt;- split(y, ind)
&gt; for (i in 1:length(yc)) {
    plot(xc[[i]], yc[[i]])
    abline(lsfit(xc[[i]], yc[[i]]))
  }
</pre></div>

<a name="index-split"></a>

<p>위에서 사용된 함수 <code>split()</code>는 주어진 데이터를 특정 요인이 가지는 수준별로 분리한 뒤, 각각의 수준별 데이터를
컴포넌트로 가지는 리스트를 생성합니다.이것은 박스플랏과 많은 연관이 있는 매우 유용한 함수입니다.더 자세한 사항은 도움말
<code>help</code> 기능을 이용하시길 바랍니다.
</p>
<blockquote>
<p><strong>Warning</strong>: R에서는 <code>for()</code>를 이용한 반복문은 다른 컴파일된 언어들에 비하여 자주 사용되지
않습니다. 그 이유는 전체 데이터 객체를 이용하여 벡터라이징 테크닉을 적절히 활용하는 것이 R에서는 <code>for()</code>를 이용한
반복문보다도 더 빠른 연산속도를 가지며, 프로그래머의 입장에서 프로그램을 직관적으로 읽기 쉽고 이해가 빠르게 도와줍니다.
</p></blockquote>

<p>다른 반복기능들은 
</p>
<div class="example">
<pre class="example">&gt; repeat <var>expr</var>
</pre></div>
<a name="index-repeat"></a>

<p>문과
</p>
<div class="example">
<pre class="example">&gt; while (<var>condition</var>) <var>expr</var>
</pre></div>
<a name="index-while"></a>

<p>문을 가지고 있습니다.
</p>
<p><code>break</code>와 <code>next</code>라는 두 명령문은 반복문을 중단할 때 쓰이지만, 중요한 차이가
있습니다. <code>break</code>는 반복문을 무조건 중단하고 반복문 이후의 명령들을 실행하고자 할때 쓰입니다. 따라서
<code>repeat</code>을 사용하여 <code>expr</code>를 반복하던 중, 이를 중단하고자 할때는 <code>break</code> 명령문을 사용하면
됩니다.
<a name="index-break"></a>
</p>
<p>그러나, <code>next</code>는 현재 진행하고 있는 반복 단계만을 건너뛰고 다음 단계의 반복단계로 넘어가라는 의미입니다. 
<a name="index-next"></a>
</p>
<p>실제로 프로그램의 흐름을 제어하는 것은 대개 사용자 정의함수를 작성할때 다루어집니다. 이에 관련된 예제들에 대해서는 다음의
<a href="#Writing-your-own-functions-_0028_c0ac_c6a9_c790-_c815_c758_d568_c218-_c791_c131_d558_ae30_0029">Writing your own functions (사용자 정의함수 작성하기)</a> 에서 다룰 것입니다.
</p>

<hr>
<a name="Writing-your-own-functions-_0028_c0ac_c6a9_c790-_c815_c758_d568_c218-_c791_c131_d558_ae30_0029"></a>
<a name="Writing-your-own-functions-_0028sayongja-jeongyihamsu-jagseonghagi_0029"></a>
<h2 class="chapter">10 Writing your own functions (사용자 정의함수 작성하기)</h2>
<a name="index-Writing-functions"></a>

<p>R은 방대한 양의 함수를 지원하고 있으나, 사용자가 직접 <em>function(함수)</em>라는 모드를 가진 객체를 생성할 수
있도록 지원합니다. R이 사전에 미리 제공하는 함수들은 내장(built-in)함수라고 하며, 사용자가 직접 정의하는 함수를 사용자
정의함수라고 합니다. 이를 작성하는 것은 사용자가 R을 더 효율적으로, 기능적으로, 그리고 생산적인 통계분석처리를 할 수 있도록
도와줍니다.
</p>
<p><code>mean()</code>, <code>var()</code>, <code>postscript()</code>와 같이 R시스템에 미리 내장된 많은 함수들
역시 R로 쓰여졌기 때문에, 대다수의 내장함수들이 사용자 정의함수라고 할 수도 있습니다.
</p>
<p>다음은 함수를 정의하는 방법입니다.
</p>
<div class="example">
<pre class="example">&gt; <var>name</var> &lt;- function(<var>arg_1</var>, <var>arg_2</var>, &hellip;) <var>expression</var>
</pre></div>
<a name="index-function"></a>

<p>여기에서 <var>expression</var> 이란 어떤 값을 계산하기 위해 사용되는 <var>arg_i</var>를 이용하여 작성되는 R표현식
(일반적으로 그룹화된 표현식)입니다.
</p>
<p>그리고, <var>expression</var>을 수행함으로 얻어진 최종적인 결과를 함수의 반환값이라고 합니다.이렇게 정의된 함수를 사용하는
방법은 어느 곳에서나 <code><var>name</var>(<var>expr_1</var>, <var>expr_2</var>, &hellip;)</code>이라고 사용하면
됩니다.
</p>

<hr>
<a name="g_t_ac04_b2e8_d55c-_c608_c81c"></a>
<a name="gandanhan-yeje"></a>
<h3 class="section">10.1 간단한 예제</h3>

<p>첫번째 예제를 살펴봅니다.  두개의 샘플로부터 t-통계량을 구하는 함수를 다음과 같이 정의할 수 있습니다.
</p>
<p>The function is defined as follows:
</p>
<div class="example">
<pre class="example">&gt; twosam &lt;- function(y1, y2) {
    n1  &lt;- length(y1); n2  &lt;- length(y2)
    yb1 &lt;- mean(y1);   yb2 &lt;- mean(y2)
    s1  &lt;- var(y1);    s2  &lt;- var(y2)
    s &lt;- ((n1-1)*s1 + (n2-1)*s2)/(n1+n2-2)
    tst &lt;- (yb1 - yb2)/sqrt(s*(1/n1 + 1/n2))
    tst
  }
</pre></div>

<p>이렇게 함수를 정의한 뒤, 이 정의한 함수 <code>twosam</code>을 아래와 같은 방법으로 사용할 수 있습니다.
</p>
<div class="example">
<pre class="example">&gt; tstat &lt;- twosam(data$male, data$female); tstat
</pre></div>

<p>두번째 예제는 <small>MATLAB</small>에서 최소제곱법을 이용하여 회귀모델의 회귀계수를 구해주는 백슬래쉬(backslash)라는 명령어를
구현해보는 것입니다.본래 이것은 <code>qr()</code>함수를 이용하여 할 수도 있으나, 어떤 경우에는 직접적으로 활용하기가 곤란한 경우가
있습니다. 따라서, 다음과 같은 방식을 사용하는 것을 권장합니다.
</p>
<p>만약, <em>n</em>개의 원소를 가지는 열벡터 <em>y</em>가 있고, 사이즈가 <em>n</em>행 <em>p</em>열을 가진 디자인행렬
<em>X</em>가 있다면 <em>X\y</em>는 
(X&rsquo;X)^{-}X&rsquo;y, where (X&rsquo;X)^{-}
로 정의할 수 있으며, <em>(X'X)^{-}</em>는 <em>X'X</em>의 역행렬입니다.
</p>
<div class="example">
<pre class="example">&gt; bslash &lt;- function(X, y) {
  X &lt;- qr(X)
  qr.coef(X, y)
}
</pre></div>

<p>위와 같이 정의된 <code>bslahs</code> 함수는 아래와 같이 <code>regcoeff</code>라는 객체에 결과를 저장하게 됩니다.
</p>
<div class="example">
<pre class="example">&gt; regcoeff &lt;- bslash(Xmat, yvar)
</pre></div>

<p>and so on.
</p>
<p>이러한 기능은 R에서 제공하는 <code>lsfit()</code> 함수를 통하여 더 잘 수행될 수
있습니다.<a name="DOCF20" href="#FOOT20"><sup>20</sup></a>. 실제로, <code>qr()</code>과 <code>qr.coef()</code>의 사용은 회귀계수를 구하는데 있어서 직관적이라고
보기 어려우며, 사용에 번거롭기도 합니다. 보다 편리한 사용을 위해 사용자가 직접 정의하는 이항연산자(binary operator)라는
기능을 제공합니다.
</p>
<hr>
<a name="g_t_c0c8_b85c_c6b4-_c774_d56d_c5f0_c0b0_c790_b97c-_c815_c758_d558_ae30"></a>
<a name="saeroun-ihangyeonsanjareul-jeongyihagi"></a>
<h3 class="section">10.2 새로운 이항연산자를 정의하기</h3>
<a name="index-Binary-operators"></a>

<p>위에서 <code>bslash()</code> 함수를 작성하였습니다. 그러나 이러한 연산의 수행은 함수를 작성하는 것보다 아래와 같은 연산자의
형태를 지닌다면 훨씬 편리할 것입니다.
</p>
<div class="example">
<pre class="example">%<var>anything</var>%
</pre></div>

<p>예를 들어, <code>anything</code>이라는 부분에 느낌표(<code>!</code>)를 이용하여 <code>%!%</code>이라는 새로운 이항연산자를
아래와 같이 큰 따옴표를 이용하여 정의할 수 있습니다.
</p>
<div class="example">
<pre class="example">&gt; &quot;%!%&quot; &lt;- function(X, y) { &hellip; }
</pre></div>

<p>이렇게 새로이 정의된 연산자는 <code>X %!% y</code>와 같이 사용할 수 있습니다.
</p>
<p>행렬의 곱셈을 수행하는 연산자 <code>%*%</code>, 외적을 수행하는 연산자 <code>%o%</code>는 이러한 방법으로 정의된 이항연산자의
대표적인 경우입니다.
</p>
<hr>
<a name="g_t_c778_c790_ba85_acfc-_ae30_bcf8_ac12"></a>
<a name="injamyeonggwa-gibongabs"></a>
<h3 class="section">10.3 인자명과 기본값</h3>
<a name="index-Named-arguments"></a>
<a name="index-Default-values"></a>

<p><a href="#Generating-regular-sequences-_0028_addc_ce59_c131_c744-_c9c0_b2cc-_c77c_b828_c758-_c22b_c790_b4e4_c744-_c0dd_c131_d558_ae30_0029">Generating regular sequences (규칙성을 지닌 일련의 숫자들을 생성하기)</a>에서 설명했던 것과 같이 함수에
사용되는 인자들은 &ldquo;<code><var>name</var>=<var>object</var></code>&rdquo;와 같은 형식을 가지고 있습니다.이러한 방식으로 함수의
정의시 인자의 이름을 굳이 함께 정의하는 것은 프로그래밍의 논리적 오류를 줄이고자 하는 노력이라고 보시길 바랍니다.
</p>
<p>예를들어, 아래와 같이 정의된 함수 <code>fun1</code>가 있다고 가정한다면,
</p>
<div class="example">
<pre class="example">&gt; fun1 &lt;- function(data, data.frame, graph, limit) {
    <span class="roman">[function body omitted]</span>
  }
</pre></div>

<p>아래와 같이 세가지 방법으로 사용이 가능하며, 모두 같은 결과를 줍니다.
</p>
<div class="example">
<pre class="example">&gt; ans &lt;- fun1(d, df, TRUE, 20)
&gt; ans &lt;- fun1(d, df, graph=TRUE, limit=20)
&gt; ans &lt;- fun1(data=d, limit=20, graph=TRUE, data.frame=df)
</pre></div>

<p>are all equivalent.
</p>
<p>그런데, R에서 제공하는 모든 함수들은 아래에서 보여지는 것과 같이 함수의 인자에 기본값이라는 것이 부여되어 있음을 알 수
있습니다.
</p>
<div class="example">
<pre class="example">&gt; fun1 &lt;- function(data, data.frame, graph=TRUE, limit=20) { &hellip; }
</pre></div>

<p>따라서, 이 기본값들을 이용하여 함수의 모든 인자를 입력하지 않아도 함수는 연산을 수행하게 됩니다.아래와 같은 사용은 위의 세가지 다른
방법으로 사용했던것과 동일한 결과를 줍니다.
</p>
<div class="example">
<pre class="example">&gt; ans &lt;- fun1(d, df)
</pre></div>

<p><code>limit</code>의 기본값을 20에서 10으로 바꾸어 실행하고자 한다면 아래와 같이 할 수 있습니다.
</p>
<div class="example">
<pre class="example">&gt; ans &lt;- fun1(d, df, limit=10)
</pre></div>

<p>which changes one of the defaults.
</p>
<p>인자에 주어지는 기본값들이 본 예제에서 사용된 것과 같이 상수일 필요는 없으며, 임의의 표현식이 될 수 있습니다.
</p>
<hr>
<a name="The-three-dots-argument"></a>
<a name="The-_2026-argument"></a>
<h3 class="section">10.4 The &lsquo;<samp>&hellip;</samp>&rsquo; argument</h3>


<p>함수를 정의할 때 &lsquo;<samp>&hellip;</samp>&rsquo;라는 표현을 알아두면 매우 유용합니다.이는 한 함수의 인자들에 대한 설정을 다른 함수로
넘겨주는 것을 허용하는 역할을 합니다.예를들어, <code>plot()</code>과 같은 그래픽 함수들은 그래픽의 결과물을 정교히 조정하기 위한
방대한 양의 인자들이 포함하고 있는 함수 <code>par()</code>를 사용합니다. <code>par()</code>에 대해서 자세히 알고 싶으시다면
See <a href="#The-par_0028_0029-function">The par() function</a>를 살펴보시길 바랍니다.
</p>
<div class="example">
<pre class="example">fun1 &lt;- function(data, data.frame, graph=TRUE, limit=20, ...) {
  <span class="roman">[omitted statements]</span>
  if (graph)
    par(pch=&quot;*&quot;, ...)
  <span class="roman">[more omissions]</span>
}
</pre></div>

<p>따라서, 그래픽 함수들은 실제로는 par()라는 함수에 있는 인자를 사용함으로서 결과물의 수정 및 조정을 조정하고, 이러한 역할을 위한
인자를 따로 정의하고 있지 않습니다. 이렇게 외부에 정의에 되어 있는 함수 및 객체들의 인자들을 정의하고자 하는 함수로 불러들여와
활용하고자할 때, 아래의 코드에서 보이는 것과 같이 &lsquo;<samp>&hellip;</samp>&rsquo;를 함수 선언부에 나열된 인자들의 목록뒤에 붙여주면 됩니다.
</p>
<hr>
<a name="g_t_d568_c218_b0b4-_d560_b2f9"></a>
<a name="Assignments-within-functions"></a>
<h3 class="section">10.5 Assignments within functions</h3>

<p><em>함수 내부에서 이루어진 값에 대한 모든 할당은 함수내부내에서만 유효합니다</em>. 따라서, <code>X &lt;- qr(X)</code>은
호출하는 프로그램에 있는 인자들의 값에 아무런 영향을 미치지 않습니다.이렇게 변수가 가지는 값이 지정된 함수 내부에서만 사용되는것을
지역할당(local assignment) 이라고 합니다.
</p>
<p>R시스템내에서 할당범위 (the scope of assignment)에 대한 규칙들을 이해하기 위해서는
<em>프레임(frame)</em>이 어떻게 평가가 되는지에 대한 개념에 익숙해져야만 합니다.그러나, 이것은 이 안내서의 수준을 벗어나므로
설명하지 않겠습니다. 
</p>
<p>만약, 함수 내부에서 연산된 어떤 값을 함수 외부 및 작성하는 프로그램 전체에서 사용하고 싶다면, 슈퍼할당
(superassignment)이라는 연산자 <code>&lt;&lt;-</code>를 사용하거나, 함수 <code>assign()</code>를 이용하시길
바랍니다.이렇게 변수가 가지는 값이 특정 함수내에서 국한되지 않고 전체에서 활용되는 개념을 전역할당 (global assignment
혹은 permanent assignment) 라고 합니다. 이것에 대한 더 자세한 사항은 도움말 <code>help</code>을 참조하시길
바랍니다. <small>S-PLUS</small>사용자는 <code>&lt;&lt;-</code> 연산자가 R에서 다른 의미로 사용된다는 점을 반드시 알고 있어야
합니다. 이러한 다른 점들은 <a href="#Scope-_0028_c2a4_cf54_d504_0029">Scope (스코프)</a>에서 다루어질 것입니다.
</p>
<hr>
<a name="g_t_c880-_b354-_bc1c_c804_b41c-_c608_c81c_b4e4"></a>
<a name="jom-deo-baljeondoen-yejedeul"></a>
<h3 class="section">10.6 좀 더 발전된 예제들</h3>


<hr>
<a name="Efficiency-factors-in-block-designs"></a>
<a name="Efficiency-factors-in-block-designs-1"></a>
<h4 class="subsection">10.6.1 Efficiency factors in block designs</h4>

<p>함수에 대해서 좀 더 자세히 다루기 위해서 이번에는 블락 디자인에서 사용되는 효율성요인(efficiency factor)을 찾아보도록
하겠습니다. 이 문제에 대한 일부 내용은 이미 <a href="#Index-matrices-_0028_c778_b371_c2a4-_d589_b82c_0029">Index matrices (인덱스 행렬)</a>에서 다룬바 있습니다.
</p>
<p><code>b</code>수준을 가진 요인 <code>blocks</code>와 <code>v</code>수준을 가진 요인 <code>varieties</code>을 이용한 블락
디자인을 생각해 봅니다.그리고, <em>R</em>과 <code>K</code>가 각각 <em>v</em>행 <em>v</em>열인 행렬
<code>replications</code>과 <em>b</em>행 <em>b</em>열인 행렬 <code>block size</code>이라고
합니다.효율성요인(efficiency factor)은 아래와 같은 행렬의 기저값(eigenvalues)을 이용하여, 구할 수 있습니다.
E = I_v - R^{-1/2}N&rsquo;K^{-1}NR^{-1/2} = I_v - A&rsquo;A, where A =
K^{-1/2}NR^{-1/2}.
다음은 이를 산출하는 함수를 작성한 것입니다.
</p>
<div class="example">
<pre class="example">&gt; bdeff &lt;- function(blocks, varieties) {
    blocks &lt;- as.factor(blocks)             # <span class="roman">minor safety move</span>
    b &lt;- length(levels(blocks))
    varieties &lt;- as.factor(varieties)       # <span class="roman">minor safety move</span>
    v &lt;- length(levels(varieties))
    K &lt;- as.vector(table(blocks))           # <span class="roman">remove dim attr</span>
    R &lt;- as.vector(table(varieties))        # <span class="roman">remove dim attr</span>
    N &lt;- table(blocks, varieties)
    A &lt;- 1/sqrt(K) * N * rep(1/sqrt(R), rep(b, v))
    sv &lt;- svd(A)
    list(eff=1 - sv$d^2, blockcv=sv$u, varietycv=sv$v)
}
</pre></div>

<p>실제로 이경우에는 the singular value decomposition을 이용하는 것이 기저값(eigenvalue)를 이용한
방법보다 보다 나은 연산결과를 줍니다.
</p>
<p>위에서 작성된 함수는 효율성 요인만을 결과값으로 돌려주는 것만이 아니라 <code>block</code>과 <code>variety</code>
정준대비(canonical contrast) 또한 알려줍니다. 그 이유는 이 두가지 결과값들이 때때로 유용하기 때문입니다.
</p>
<hr>
<a name="Dropping-all-names-in-a-printed-array"></a>
<a name="Dropping-all-names-in-a-printed-array-1"></a>
<h4 class="subsection">10.6.2 Dropping all names in a printed array</h4>

<p>사이즈가 큰 행렬 혹은 배열의 출력이 주목적인 경우, 행렬과 배열의 구성요소의 위치를 알려주는 행, 열, 혹은 차원에 대한 정보를
나타내지 않고 오로지 데이터값만을 출력하는 것이 유용한 경우가 있습니다. 이런 경우에는 속성 <code>dimnames</code>이 가지는
문자열값들을 초기화 시켜주면 됩니다. 예를 들어 행렬 <code>X</code>의 행과 열의 정보 없이 데이터만 출력하고자 할 경우, 아래와 같이
할 수 있습니다.
</p>
<div class="example">
<pre class="example">&gt; temp &lt;- X
&gt; dimnames(temp) &lt;- list(rep(&quot;&quot;, nrow(X)), rep(&quot;&quot;, ncol(X)))
&gt; temp; rm(temp)
</pre></div>

<p>이와 같은 기능을 아래와 같이 <code>no.dimnames()</code>라는 사용자정의 함수를 작성함으로서 수행할 수 도 있습니다. 이것은
또한 이렇게 유용한 기능을 위한 사용자정의함수가 꼭 길지 않아도 됨을 잘 보여주고 있습니다.
</p>
<div class="example">
<pre class="example">no.dimnames &lt;- function(a) {
  ## <span class="roman">Remove all dimension names from an array for compact printing.</span>
  d &lt;- list()
  l &lt;- 0
  for(i in dim(a)) {
    d[[l &lt;- l + 1]] &lt;- rep(&quot;&quot;, i)
  }
  dimnames(a) &lt;- d
  a
}
</pre></div>

<p>위와 같이 정의된 함수는 아래와 같이 사용함으로서 배열이 가지는 데이터 값들만 출력해낼수 있습니다.
</p>
<div class="example">
<pre class="example">&gt; no.dimnames(X)
</pre></div>

<p>이번 섹션에서 다룬 내용은 배열 데이터 값 자체 보다 배열의 값들이 가지는 패턴을 분석하고자 할때 더 유용하므로 주로 사이즈가 큰 정수형
배열을 다룰때 사용됩니다
</p>
<hr>
<a name="Recursive-numerical-integration"></a>
<a name="Recursive-numerical-integration-1"></a>
<h4 class="subsection">10.6.3 Recursive numerical integration</h4>

<p>함수는 재귀적일 수 있으며, 함수 자신이 함수 자신내에 함수를 정의할 수도 있습니다.그러나, 이러한 함수들 (또는 실제로 변수들)은 마치
탐색경로(serach path)에 존재했던 것같은 상위평가프레임 (higer evaluation frames)내에서 불려진 함수에 의해
존재하는 것이 아니라는 점을 알고 있어야 합니다.
</p>
<p>아래의 예제는 1개의 변수만을 가지는 함수를 적분하는 기초적인 방법에 대해서 다루고 있습니다. 적분을 하는 기본 개념은 먼저 적분하고자
하는 범위의 양쪽 끝점과 그 중간점에 해당하는 함수들의 값을 얻어낸 후, 사다리꼴 공식을 이용하여 단일 패널에서 얻어진 결과가
이중패널에서 얻어진 결과와 매우 유사할 경우 이중패널로부터 얻어진 결과를 적분값으로 결정합니다. 만약, 그렇지 않다면 각각의 패널에
위에서 묘사한 프로세스를 다시 적용하되 값의 변화가 없을때까지 반복합니다.
</p>
<p>이 예제는 R 프로그래밍을 하는데 있어서 다소 복잡한 부분에 해당하므로 이해가 어려울 수 도 있습니다.
</p>
<div class="example">
<pre class="example">area &lt;- function(f, a, b, eps = 1.0e-06, lim = 10) {
  fun1 &lt;- function(f, a, b, fa, fb, a0, eps, lim, fun) {
    ## <span class="roman">function &lsquo;fun1&rsquo; is only visible inside &lsquo;area&rsquo;</span>
    d &lt;- (a + b)/2
    h &lt;- (b - a)/4
    fd &lt;- f(d)
    a1 &lt;- h * (fa + fd)
    a2 &lt;- h * (fd + fb)
    if(abs(a0 - a1 - a2) &lt; eps || lim == 0)
      return(a1 + a2)
    else {
      return(fun(f, a, d, fa, fd, a1, eps, lim - 1, fun) +
             fun(f, d, b, fd, fb, a2, eps, lim - 1, fun))
    }
  }
  fa &lt;- f(a)
  fb &lt;- f(b)
  a0 &lt;- ((fa + fb) * (b - a))/2
  fun1(f, a, b, fa, fb, a0, eps, lim, fun1)
}
</pre></div>


<hr>
<a name="Scope-_0028_c2a4_cf54_d504_0029"></a>
<a name="Scope-_0028seukopeu_0029"></a>
<h3 class="section">10.7 Scope (스코프)</h3>
<a name="index-Scope-_0028seukopeu_0029"></a>

<p>이번 섹션에서 다루어질 내용은 이 문서의 다른 부분들보다는 다소 어려운 기술적인 부분에 해당합니다. 그러나, 이 부분은 R과
<small>S-PLUS</small>간의 다른 점들 중 함수와 관련된 부분입니다.
</p>
<p>먼저 함수의 본체에 사용되는 기호는 형식인자 (formal parameters), 지역변수 (local variables), 그리고
자유변수 (free variables) 라는 세가지가 있습니다.형식인자 (formal parameters)라는 것은 함수 선언시 아직
값이 부여되지 않은 인자들의 목록을 의미합니다. 따라서 형식인자 (formal parameters)는 실제로 함수가 사용될 때 함수가
받아들이는 인자의 값을 가지게 됩니다. 이에 반해, 지역변수라는 것은 함수 본체에서 사용된 표현식의 결과값들을 가지게 됩니다. 만약,
어떤 변수가 형식인자 (formal parameters)도 아니고 지역변수도 아닌 경우, 이러한 변수를 바로 자유변수라고
합니다. 그러나, 상황에 따라서 자유변수에 값이 부여될 경우 이는 지역변수가 되기도 합니다. 더 정확한 개념의 이해를 위해서 다음의
예제를 살펴봅시다.
</p>
<div class="example">
<pre class="example">f &lt;- function(x) {
  y &lt;- 2*x
  print(x)
  print(y)
  print(z)
}
</pre></div>

<p>여기 정의되어 있는 함수 <code>f</code>는 <code>x</code>라는 형식인자 (formal parameter)를 가지며, <code>y</code>라는
지역변수를 가지는데 반해, 자유변수 <code>z</code>를 가지고 있습니다.
</p>
<p>R에서 자유변수에 대한 값의 할당은 변수가 관리가 되고 있는 함수에 우선권이 부여되며, 이것을 렉시컬 스코프 (lexical
scope)라고 합니다. 이해를 돕기 위해서 아래와 같이 정의된 함수 <code>cube</code>를 살펴봅니다.
</p>
<div class="example">
<pre class="example">cube &lt;- function(n) {
  sq &lt;- function() n*n
  n*sq()
}
</pre></div>

<p>함수 <code>sq</code>내에 있는 변수 <code>n</code>은 형식인자가 아닌 자유변수입니다.  이 자유변수가 어떠한 값을 가져야 하는가에
대해서 스코핑 규칙 (scoping rules)이 적용됩니다. 정적 스코핑 규칙(static scoping rule)을 가지는
<small>S-PLUS</small>에서는 자유변수가 가지는 값은 <code>n</code>이라는 이름을 가진 전역변수 (global variable)에 의해서 그 값이
결정됩니다. 이에 반해, 렉시컬 스코핑 규칙을 가지는 R은 자유변수에 함수 <code>cube</code>라는 실행될 때 가지는 인자의 값을
할당 합니다. 그 이유는 <code>n</code>은 함수 <code>sq</code>가 정의되기 &rsquo;바로 이전에&rsquo; 함수 <code>cube</code> 내부에서 정의되어
관리되는 변수이기 때문입니다. 이러한 스코핑 규칙의 차이는 R과 <small>S-PLUS</small>를 구분짓는 큰 특징들 중의 하나 입니다. 즉,
R의 기본적인 스코핑 규칙은 전역변수에 의한 관리가 아닌 지역에 촛점을 맞춘 렉시컬 스코핑을 따르는 것입니다.
</p>
<div class="example">
<pre class="example">## <span class="roman">first evaluation in S</span>
S&gt; cube(2)
Error in sq(): Object &quot;n&quot; not found
Dumped
S&gt; n &lt;- 3
S&gt; cube(2)
[1] 18
## <span class="roman">then the same function evaluated in R</span>
R&gt; cube(2)
[1] 8
</pre></div>

<p>다음의 예제는 R의 렉시컬 스코핑이 얼마나 효율적으로 은행계좌를 구현할 수 있는가를 보여줍니다. 은행계좌를 구현하기 위해서는 총계
(balance 혹은 total), 출금 (withdrawal), 입금 (deposits), 그리고 현재잔고(current
balance)이 필요합니다. 먼저, 출급, 입금, 그리고 잔고에 대한 함수를 먼저 만든 뒤, 이를 리스트형식으로 한데 묶어 함수
<code>account</code>를 정의합니다. 함수 <code>account</code>가 실제적으로 실행되었을때 <code>total</code>이라는 인자는
특정한 값을 가진 인자가 되어 리스트에 정의되어 있는 출금, 입금, 그리고 잔고라는 함수에 그 값을 전달하게 됩니다. 그 이유는 바로
<code>total</code>이라는 인자가 함수 <code>account</code>에 의해서 정의되어 관리되는 변수이기 때문입니다.
</p>
<p>The special assignment operator, <code>&lt;&lt;-</code>,
<a name="index-_003c_003c_002d"></a>
아래에서 보이는 것과 같이 <code>total</code>이라는 변수의 값을 변경하기 위해서 특별한 할당 연산자인 <code>&lt;&lt;-</code>를
사용하였습니다.이 연산자는 기호 <code>total</code>이 존재하는 환경(environment)을 둘러싼 환경 (enclosing
enviornment)을 살펴보고, 그러한 환경이 찾아졌을때 해당 환경에 존재하는 값으로 대체하게 됩니다. 만약, 기호
<code>total</code>을 프로그램 전역 또는 최상위 환경 (top-level environment)에 도달할때까지도 찾을 수 없었다면,
기호 <code>total</code>이 새로이 생성이 되고 그 값이 할당되게 됩니다.<a name="DOCF21" href="#FOOT21"><sup>21</sup></a>
</p>
<div class="example">
<pre class="example">open.account &lt;- function(total) {
  list(
    deposit = function(amount) {
      if(amount &lt;= 0)
        stop(&quot;Deposits must be positive!\n&quot;)
      total &lt;&lt;- total + amount
      cat(amount, &quot;deposited.  Your balance is&quot;, total, &quot;\n\n&quot;)
    },
    withdraw = function(amount) {
      if(amount &gt; total)
        stop(&quot;You don't have that much money!\n&quot;)
      total &lt;&lt;- total - amount
      cat(amount, &quot;withdrawn.  Your balance is&quot;, total, &quot;\n\n&quot;)
    },
    balance = function() {
      cat(&quot;Your balance is&quot;, total, &quot;\n\n&quot;)
    }
  )
}

ross &lt;- open.account(100)
robert &lt;- open.account(200)

ross$withdraw(30)
ross$balance()
robert$balance()

ross$deposit(50)
ross$balance()
ross$withdraw(500)
</pre></div>

<hr>
<a name="g_t_d658_acbd-_c124_c815_d558_ae30"></a>
<a name="hwangyeong-seoljeonghagi"></a>
<h3 class="section">10.8 환경 설정하기</h3>
<a name="index-hwangyeong-seoljeonghagi"></a>

<p>사용자는 사용자의 환경설정을 여러가지 방법으로 변경할 수 있습니다.먼저, 사이트 초기화 파일(site initialization
file)이라는 것이 있고, 각각의 디렉토리마다 특정역할을 하는 초기화 파일(special initialization file)이
있습니다. 그리고, <code>.First</code>와 <code>.Last</code>이라는 특수한 함수들이 있습니다.
</p>
<p>사이트 초기화 파일의 위치는 <code>R_PROFILE</code>이라는 환경변수의 값에 의해 정해집니다.  만약, 이 환경변수의 값이 정해지지
않았다면 R의 홈에 있는 <samp>etc</samp>라는 하위디렉토리에 있는 <samp>Rprofile.site</samp>의 값이 사용되게 됩니다.이
파일은 사용자의 시스템에서 R이 실행될때마다 반드시 실행되어야 할 명령어들을 포함하고 있습니다.두번째로
<samp>.Rprofile</samp><a name="DOCF22" href="#FOOT22"><sup>22</sup></a>이라는 개인프로파일이라는 파일은 어느 디렉토리에나 놓일
수 있습니다.만약, R이 해당 디렉토리에서 실행된다면 이 파일은 소스될(sourced, 즉 불러들어 읽힘) 것입니다.이 파일은 해당
작업공간에 대한 개인사용자 설정이며, 다른 디렉토리마다 다른 스타트업(startup) 절차를 수행할 수 있게 해줍니다.만약,
<samp>.Rprofile</samp>이라는 파일을 스타트업 디렉토리에 없다면, R은 사용자의 홈디렉토리에 있는 (만약 있다면)
<samp>.Rprofile</samp>을 사용하게 됩니다.만약, 환경설정변수 <code>R_PROFILE_USER</code>가 지정되어 있다면,
<samp>.Rprofile</samp>파일대신에 사용될 것입니다.
</p>
<p>사이트 프로파일, 사용자 프로파일, 그리고 <samp>.RData</samp>라는 이미지 내부에 <code>.First()</code>라고 이름이 붙은
함수들은 특정한 상태를 가지고 있습니다. 이것들은 R세션이 시작할 때 자동으로 작업환경을 초기화할 때 사용되게 됩니다. 아래의
코드를 살펴 보신다면 더 빠른 이해를 가지실 수 있습니다. 예를들어, 함수 <code>.First</code>의 정의중 <code>prompt</code>라는
인자 <code>$</code>를 다른 기호로 변경하여 R세션내내 사용자가 변경한 기호로 프롬프트를 사용할 수 있습니다.
</p>
<p>일반적으로 사용자의 환경설정을 위한 파일의 실행순서는 <samp>Rprofiles.site</samp>, 그리고 사용자 프로파일,
<samp>.RData</samp>, 그리고 <code>.First()</code> 순입니다.
</p>
<div class="example">
<pre class="example">&gt; .First &lt;- function() {
  options(prompt=&quot;$ &quot;, continue=&quot;+\t&quot;)  # <span class="roman"><code>$</code> is the prompt</span>
  options(digits=5, length=999)         # <span class="roman">custom numbers and printout</span>
  x11()                                 # <span class="roman">for graphics</span>
  par(pch = &quot;+&quot;)                        # <span class="roman">plotting character</span>
  source(file.path(Sys.getenv(&quot;HOME&quot;), &quot;R&quot;, &quot;mystuff.R&quot;))
                                        # <span class="roman">my personal functions</span>
  library(MASS)                         # <span class="roman">attach a package</span>
}
</pre></div>
<a name="index-_002eFirst"></a>

<p>위에서 정의된 <code>.First()</code>와 유사하게 함수 <code>.Last()</code>를 아래와 같이 정의할 수 있습니다.이는 보통 세션
종료시 사용됩니다.
</p>
<div class="example">
<pre class="example">&gt; .Last &lt;- function() {
  graphics.off()                        # <span class="roman">a small safety measure.</span>
  cat(paste(date(),&quot;\nAdios\n&quot;))        # <span class="roman">Is it time for lunch?</span>
}
</pre></div>
<a name="index-_002eLast"></a>

<hr>
<a name="Object-orientation-_0028_ac1d_ccb4_c9c0_d5a5_c801-_bc29_bc95_0029"></a>
<a name="keulraeseu_002c-jenerig-hamsu_002c-geurigo-gaegcejihyang-peurogeuraeming"></a>
<h3 class="section">10.9 클래스, 제네릭 함수, 그리고 객체지향 프로그래밍</h3>
<a name="index-Classes-1"></a>
<a name="index-Generic-functions"></a>
<a name="index-Object-orientation-_0028gaegcejihyangjeog-bangbeob_0029"></a>

<p>객체의 클래스라는 것은 <em>제네릭 함수 (generic function)</em>가 어떻게 그 객체를 처리할 것인지 대한 정보를
제공합니다. 즉, 제네릭 함수라는 것은 객체의 클래스정보를 인자로 가지기 때문에 만약 클래스 정보가 없거나, 제네릭 함수내에서 해당
클래스에 대한 처리방법이 정의되지 않았다면 <em>기본행동 (default action)</em>을 수행하게 됩니다.
</p>
<p>예를 들면 더욱 수월하게 이해가 가실 것입니다.클래스 메커니즘 (작동하는 방법)은 사용자가 제네릭 함수를 디자인하고 새로 정의할 수
있도록 도와줍니다. 단편적인 예로 <code>plot()</code>이라는 제네릭 함수는 여러가지 객체의 종류 (즉, 클래스)에 따른 다양한 시각화
방법을 제공합니다.또 다른 제네릭함수 <code>summary()</code>는 다양한 종류의 객체에 대한 통계분석의 결과를 요약해 주며,
<code>anova()</code>는 여러개의 통계 모델들을 비교할 때 사용됩니다.
</p>
<p>클래스를 특정한 방법으로 처리하는 제네릭 함수의 수는 매우 많습니다. 예를 들어, 클래스 <code>&quot;data.frame&quot;</code>의 객체를
처리하는 방법들에 대해서는 아래와 같은 내용들이 있습니다.
</p>
<div class="example">
<pre class="example">[     [[&lt;-    any    as.matrix
[&lt;-   mean    plot   summary
</pre></div>

<a name="index-methods"></a>
<p>이와 같이 어떤 처리 방법들이 제네릭 함수안에 구현이 되어 있는지 확인하고 싶다면 아래와 같이 <code>methods()</code>를
사용해보세요.
</p>
<div class="example">
<pre class="example">&gt; methods(class=&quot;data.frame&quot;)
</pre></div>

<p>이와 반대로, 제네릭 함수가 처리해 낼 수 있는 클래스의 종류 또한 많습니다. 예를 들어, 함수 <code>plot()</code>는
기본처리방법(default method)을 가지고 있고, <code>&quot;data.frame&quot;</code>, <code>&quot;density&quot;</code>,
<code>&quot;factor&quot;</code>, 그 밖의 클래스들로부터 파생되어진 다양한 종류의 객체들을 처리할 수 있습니다. 만약, 어떠한 종류의
객체들을 처리할 수 있는지 확인해 보고 싶으시다면 아래와 같이 <code>methods()</code>를 함수의 이름과 함께 사용하시면 됩니다.
</p>
<div class="example">
<pre class="example">&gt; methods(plot)
</pre></div>

<p>일반적으로 제네릭 함수의 본체는 아래에서 보는 것과 같이 매우 짧습니다. 
</p>
<div class="example">
<pre class="example">&gt; coef
function (object, ...)
UseMethod(&quot;coef&quot;)
</pre></div>

<p>여기에서 <code>UseMethod</code>라는 <code>coef</code>라는 함수가 제네릭 함수임을 의미하는 것입니다.따라서
<code>coef</code>라는 제네릭 함수에 대한 처리방식에 대한 내용을 확인하고 싶으시다면 <code>methods()</code>를 사용하시면
됩니다.
</p>
<div class="example">
<pre class="example">&gt; methods(coef)
[1] coef.aov*         coef.Arima*       coef.default*     coef.listof*
[5] coef.nls*         coef.summary.nls*

   Non-visible functions are asterisked
</pre></div>

<p>위의 예제는 6가지의 처리방식이 있으나, 위에서 보는 바와 같이 메소드들이 어떻게 작성되었는지에 대해서는 보여지지 않는다고 *를 이용하여
표기하고 있습니다. 그러나, 아래와 같은 방법으로 이러한 메소드들에 대한 알고리즘의 구현방법을 확인할 수 있습니다.
</p>
<a name="index-getAnywhere"></a>
<a name="index-getS3method"></a>
<div class="example">
<pre class="example">&gt; getAnywhere(&quot;coef.aov&quot;)
A single object matching 'coef.aov' was found
It was found in the following places
  registered S3 method for coef from namespace stats
  namespace:stats
with value

function (object, ...)
{
    z &lt;- object$coef
    z[!is.na(z)]
}

&gt; getS3method(&quot;coef&quot;, &quot;aov&quot;)
function (object, ...)
{
    z &lt;- object$coef
    z[!is.na(z)]
}
</pre></div>

<p>A function named <code><var>gen</var>.<var>cl</var></code> will be invoked by the generic
<code><var>gen</var></code> for class <code><var>cl</var></code>, so do not name functions in this
style unless they are intended to be methods.
</p>
<p>이 섹션의 내용을 더 정확히 이해하기 위해서는 <em>R Language Definition</em>라는 문서를 참고하셔야 합니다.
</p>

<hr>
<a name="Statistical-models-in-R-_0028R_c5d0_c11c-_c0ac_c6a9_b418_b294-_d1b5_acc4_baa8_d615_b4e4_0029"></a>
<a name="Statistical-models-in-R-_0028Reseo-sayongdoeneun-tonggyemohyeongdeul_0029"></a>
<h2 class="chapter">11 Statistical models in R (R에서 사용되는 통계모형들)</h2>
<a name="index-Statistical-models"></a>

<p>이번 섹션에서 다루게 될 내용은 여러분이 이미 회귀분석(regression analysis)이나 분산분석(analysis of
variance)등에 대해서 어느 정도 알고 있다고 가정한 상태에서 작성한 것입니다.  그리고, 후반부에서는 조금 더 욕심을 내서 일반화
선형 모형(generalised linear model)과 비선형 모형(nonlinear model)과 같은 내용에 대해서도 어느 정도
알고 계실거라고 가정하겠습니다.
</p>
<p>R은 다양한 통계모형을 매우 간단하게 적합시킬 수 있도록 해주는 여러 도구들을 완벽하게 조합해놓은 종합 도구 상자같은 것입니다.
</p>
<p>본 문서의 서두에서 언급했던 것 처럼, R은 분석 수행시 최소한의 결과물만을 출력하기 때문에 중간절차에 대한 상세한 내용을 확인하기
위해서는 추출계열의 함수(extractor functions)들을 사용하셔야 합니다. 
</p>

<hr>
<a name="g_t_c2dd_0028formulae_0029_c744-_d1b5_d55c-_d1b5_acc4_baa8_d615_c758-_c815_c758"></a>
<a name="Defining-statistical-models_003b-formulae"></a>
<h3 class="section">11.1 Defining statistical models; formulae</h3>
<a name="index-Formulae"></a>

<p>일반적인 통계모형의 템플릿(template)이라고 하면 독립(independent)이고 등분산(homoscedastic)인
오차(errors)를 가정하는 선형 회귀 모형을 떠올릴 것 입니다. 선형 회귀모형(linear regression model)은 보통
다음과 같이 표현됩니다.하나의 모형에는 <code>p</code>개의 설명변수가 있고, 이들은 <code>j</code>라는 첨자를 사용해서
구분합니다.따라서, <code>x_j</code>는 <code>j</code>번째 설명변수를 의미합니다. 또한, <code>n</code>개의 관측으로 데이터를
구성하며, 각 관측은 첨자 <code>i</code>로 구분합니다.따라서, <code>y_i</code>란 <code>i</code>번째 관측으로부터 얻은 종속변수의
값을 의미합니다.마지막으로 <code>e_i</code>를 사용해서 <code>i</code>번째 관측의 오차항을 표현합니다.이 식에서 오차항은
<code>e_i</code>은 IID(Independently, Identically Distributed/독립이며 같은 분포를 따르는)인 평균이
<em>0</em>이고 분산이  <code>sigma^2</code>인 정규(Normal)분포를 따릅니다. 여기서 독립이란 <code>i</code>번째 관측치와
<code>i</code>번째가 아닌 다른 관측치 사이에 아무런 관련이 없으며, 개별 관측이 따로 얻어졌다는 것을 의미합니다.
</p>
<div class="display">
<pre class="display">y_i = sum_{j=0}^p beta_j x_{ij} + e_i, &nbsp;&nbsp;&nbsp;&nbsp;i = 1, &hellip;, n,
</pre></div>
<p>where the e_i are NID(0, sigma^2).
위의 식은 행렬 형태로 아래와 같이 표현되며,
</p>
<div class="display">
<pre class="display">y = X &nbsp;beta + e
</pre></div>

<p><em>y</em>는 종속변수 벡터, 설명변수들로 구성된 <em>X</em>는 <em>모형 행렬(model matrix)</em> 또는
<em>디자인 행렬(design matrix)</em>이라고 불리며, 설명변수(또는 열)들을 <em>x_0, x_1, &hellip;,
x_p</em>의 형태로 포함합니다. 종종 <em>x_0</em>라는 <em>1</em>로만 구성된 열 하나가 여기에 더 추가되는데, 이는
<em>절편(intercept)</em>을 정의하기 위해서 사용된 것입니다.
</p>
<a name="Examples"></a>
<h4 class="subsubheading">Examples</h4>

<p>본격적으로 회귀모형의 사용을 다루기 전, 몇 가지 예제를 통해 이해를 돕도록 하겠습니다.
</p>
<p>먼저 <code>y</code>, <code>x</code>, <code>x0</code>, <code>x1</code>, <code>x2</code>, &hellip;는 모두 수치형 벡터,
<code>X</code>는 행렬, 그리고 <code>A</code>, <code>B</code>, <code>C</code>, &hellip;는 요인들을 나타낸다고
가정합니다.아래에서 우리가 살펴보고자 하는 통계 모형들은 왼편에 식으로 표기되어 있고, 그 아래는 해당 모형에 대한 설명이 제시되어
있습니다.
</p>
<dl compact="compact">
<dt><code>y ~ x</code></dt>
<dt><code>y ~ 1 + x</code></dt>
<dd><p>이 두가지 식은 모두 같은 모형을 나타내고 있으며, <code>y</code>를 <code>x</code>에 회귀시킨 단순 선형 회귀모형 (simple
linear regression model)을 의미합니다.여기에서 &quot;단순(simple)&quot;이라는 말은 모형에 포함된 설명변수가 1개임을
의미합니다.첫번째 식은 절편을 따로 표시하지 않았지만, 두번째 식은 절편을 따로 표시한 것 입니다.(절편항에 대해 따로 명시하지 않으면,
R에서는 디폴트(default)로 디자인 행렬에 절편항을 포함시킵니다.)
</p>
</dd>
<dt><code>y ~ 0 + x</code></dt>
<dt><code>y ~ -1 + x</code></dt>
<dt><code>y ~ x - 1</code></dt>
<dd><p>위 세 식은 원점(origin)을 지나는 <code>y</code>를 <code>x</code>에 회귀시킨 단순 선형 회귀모형을 의미합니다. (즉, 이는
절편을 포함하지 않는 회귀모형 입니다.)
</p>
</dd>
<dt><code>log(y) ~ x1 + x2</code></dt>
<dd><p>로 변환된 <code>y</code>를 두 개의 설명변수인 <code>x1</code>와 <code>x2</code>에 회귀시킨 다중회귀모델 (multiple
regression)입니다. (표시되지 않았지만 절편을 포함하는 모형입니다.)
log(y),
on <em>x1</em> and <em>x2</em> (with an implicit intercept term).
</p>
</dd>
<dt><code>y ~ poly(x,2)</code></dt>
<dt><code>y ~ 1 + x + I(x^2)</code></dt>
<dd><p>위 식들은 <em>y</em>를 <em>x</em>의 이차항에 회귀시킨 다차항 회귀(polynomial regression)모형
입니다. <em>x</em>의 이차항이라는 것은 <em>x^2</em>를 의미하는 것으로, 첫번째 식은 직교다차항(orthogonal
polynomials)을,두번째 식은 <em>x</em>의 0차, 1차, 2차항인 <em>x^0, x^1, x^2</em>를
베이시스(basis)로 사용하는 모형임을 표현하는 것 입니다.
</p>
</dd>
<dt><code>y ~ X + poly(x,2)</code></dt>
<dd><p>위 식은 행렬인 <em>X</em>와 <em>x</em>의 2차항으로 구성된 다중 회귀모형을 의미합니다.
</p>
</dd>
<dt><code>y ~ A</code></dt>
<dd><p>위 식은 <em>y</em>에 대한 요인 <em>A</em>와 공변량(covariate) <em>x</em>의 단순(single)
공분산분석(classification analysis of covariance/ANCOVA)를 의미합니다. 여기서 <em>A</em>의
수준이 <em>y</em>를 분석하기 위한 클래스(class)를 결정합니다. <a name="DOCF23" href="#FOOT23"><sup>23</sup></a>
</p>
</dd>
<dt><code>y ~ A + x</code></dt>
<dd><p>Single classification analysis of covariance model of <em>y</em>, with classes
determined by <em>A</em>, and with covariate <em>x</em>.
</p>
</dd>
<dt><code>y ~ A*B</code></dt>
<dt><code>y ~ A + B + A:B</code></dt>
<dt><code>y ~ B %in% A</code></dt>
<dt><code>y ~ A/B</code></dt>
<dd><p>위 식은 모두 <em>y</em>를 두 개의 요인 <em>A</em>와 <em>B</em>로 설명하는 이원배치(Two factor)
비가산(non-additive) 모형을 표현하고 있습니다. 처음 두 식은 모두 (교호작용(interaction)항을 포함하는) 이원배치
혼합모형(crossed classification)을 나타내며, 다음의 두 식은 모두 중첩모형 (nested
classification)을 나타냅니다. 하지만, 현대 대수학(abstract algebra)식으로  말하면, 네 가지 모형은 모두
같은 모형 서브스페이스(subspace)를 표현합니다. 
</p>
</dd>
<dt><code>y ~ (A + B + C)^2</code></dt>
<dt><code>y ~ A*B*C - A:B:C</code></dt>
<dd><p>위의 식은 모두 삼원배치(three factor) 실험을 표현하고 있지만,주효과(main effect/일차원 효과)와 두개 요인간의
교호작용(interaction)들만 포함하는 모형입니다. 두 식은 모두 같은 모형을 표현합니다.
</p>
</dd>
<dt><code>y ~ A * x</code></dt>
<dt><code>y ~ A/x</code></dt>
<dt><code>y ~ A/(1 + x) - 1</code></dt>
<dd><p>위의 세 식은 요인 <em>A</em>의 각 수준 별로 <em>y</em>를 <em>x</em>에 회귀시켜 여러개의 단순 선형 회귀모형(simple
linear regression)을 동시에 적합시키는 방법을 다른 코딩 방식으로 표현한 것입니다. 특히, 마지막 식을 사용할
경우,<em>A</em>의 수준의 개수만큼 서로 다른 절편(intercept)과 기울기(slope)의 추정치(estimate)가
계산됩니다. 
</p>
</dd>
<dt><code>y ~ A*B + Error(C)</code></dt>
<dd><p>위 식은 두 개의 처리 요인 <em>A</em>와 <em>B</em>를 갖는 실험을 나타내며, 이 모형의 오차는 요인 <em>C</em>의 수준
별로 계층화(strata)되어 있습니다. (역주-이 경우, 좀 더 전문적인 용어로 표현하면 오차가 요인 <em>C</em>에 의해
블록(block)화 된것이라 볼 수 있으며, 일종의 랜덤효과(random effects)로 가정된 것 입니다. 이렇게 처리 요인과
블록화된 요인을 모두 포함하는 실험은 혼합모형(mixed model)을 사용하여 분석할 수 있습니다.)
</p></dd>
</dl>

<a name="index-_007e"></a>
<p>R에서 모델식(model formula)을 정의할 때는 <code>~</code>(틸다) 연산자를 사용한 것을 확인하실 수 있을 것
입니다. (이 연산자는 식의 왼쪽과 오른쪽을 연결시키는 역할을 하며, 이러한 사용은 수학에서 식의 오른쪽과 왼쪽이 완전하게 동일하다는
의미를 나타내는 등호 (<code>=</code>)를 사용하는 것과는 다릅니다. 예를 들면, 간단한 일반(ordinary) 선형모형은 다음과 같이
정의할 수 있습니다. 
</p>
<div class="example">
<pre class="example"><var>response</var> ~ <var>op_1</var> <var>term_1</var> <var>op_2</var> <var>term_2</var> <var>op_3</var> <var>term_3</var> <var>&hellip;</var>
</pre></div>

<p>where
</p>
<dl compact="compact">
<dt><var>response</var></dt>
<dd><p>는 하나의 벡터 또는 행렬(경우에 따라서는 벡터나 행렬로 결과를 출력할 표현식)이 될 수 있습니다.
</p></dd>
<dt><var>op_i</var></dt>
<dd><p>는 <code>+</code> 또는 <code>-</code> 부호를 갖는 연산자로, 각각 모형식에서 i 번째 변수를 추가하거나 제거하기 위해
사용합니다. (식의 가장 처음에 오는 (첫번째 항을 받는) 연산자는 굳이 사용하지 않아도 됩니다.)</p></dd>
<dt><var>term_i (i 번째 항)</var></dt>
<dt><var>term_i</var></dt>
<dd><p>으로는 다음의 중 한가지가 가능합니다:
</p><ul>
<li> 벡터, 행렬, 또는 숫자 <em>1</em>
</li><li> 요인 (factor)
</li><li> <em>식 연산자(formula operator)</em>를 사용하여 요인, 벡터 또는 행렬 여러 개를 연결한 <em>모형식의
표현(formula expression)</em>입니다.
</li></ul>
<p>모형이 이런식으로 표현될 경우, 식에 포함되는 각 항은 모형행렬(model matrix)을 구성하는 각 열이 모형에서 추가될질지 혹은
제거될지를 나타내기위해 사용됩니다.위에서 <em>1</em>이라는 항은 회귀식에서 절편을 나타내기 위해 사용되었으며, 따로 이 항을 생략하기
위한 표현식을 사용하지 않는 한, 항상 디폴트(default)로 모형행렬에 포함됩니다.
</p>
</dd>
</dl>

<p><em>식 연산자(formula operator)</em>는 Glim 이나 Genstat 같은 프로그램에서 사용되는 Wilkinson과
Rogers의 표기법(notation) 과 거의 비슷하게 정의 되었습니다.한 가지 눈에 띄는 차이가 있다면, GLIM이나
Genstat에서는 &lsquo;<samp><code>.</code></samp>&rsquo;에 해당하는 연산자를 R에서는 &lsquo;<samp><code>:</code></samp>&rsquo; 연산자로 사용하고 있다는
점 일 것입니다. 이렇게 된 이유는 &lsquo;<samp><code>.</code></samp>&rsquo; 기호가 R에서는 변수이름으로 사용할 수 있는 문자 중 하나이기
때문입니다.
</p>
<p>이 표기법(notation)에 대해서는 Chambers &amp; Hastie (1991, p.29)를 바탕으로 다음과 같이 요약해 볼 수
있습니다:
</p>
<dl compact="compact">
<dt><code>앞서 설명드린 것 처럼 <code>~</code>(틸다) 연산자는 <var>Y</var>를 모형식(model formula)을 의미하는 <var>M</var> 부분과 연결시켜 줍니다.</code></dt>
<dd><p>앞서 설명드린 것 처럼 <code>~</code>(틸다) 연산자는 <var>Y</var>를 모형식(model formula)을 의미하는 <var>M</var> 부분과
연결시켜 줍니다. 
</p>
</dd>
<dt><code><var>M_1</var> + <var>M_2</var></code></dt>
<dd><p><var>M_1</var>와 <var>M_2</var>과 모두 모형에 포함합니다.
</p>
</dd>
<dt><code><var>M_1</var> - <var>M_2</var></code></dt>
<dd><p><var>M_1</var>은 모형에 포함되지만 <var>M_2</var> 부분은 모형에서 제외합니다.
</p>
</dd>
<dt><code><var>M_1</var> : <var>M_2</var></code></dt>
<dd><p><var>M_1</var>과 <var>M_2</var>를 텐서곱(tensor product) 합니다.만약, 두 개의 항 모두 요인이라면 tensor
product의 결과는 <var>M_1</var>과 <var>M_2</var>가 갖는 모든 수준(level)들의 조합으로 생성된 모든
서브클래스(&ldquo;subclasses&rdquo;)가 됩니다.
</p>
</dd>
<dt><code><var>M_1</var> %in% <var>M_2</var></code></dt>
<dd><p><code><var>M_1</var>:<var>M_2</var></code>와 비슷한 작업을 수행하는 다른 코딩 방법입니다.
</p>
</dd>
<dt><code><var>M_1</var> * <var>M_2</var></code></dt>
<dd><p><code><var>M_1</var> + <var>M_2</var> + <var>M_1</var>:<var>M_2</var></code>.
</p>
</dd>
<dt><code><var>M_1</var> / <var>M_2</var></code></dt>
<dd><p><code><var>M_1</var> + <var>M_2</var> %in% <var>M_1</var></code>.
</p>
</dd>
<dt><code><var>M</var>^<var>n</var></code></dt>
<dd><p><var>n</var>차항까지의 <var>M</var>에 포함된 모든 항들과 이들간의 모든 교호작용(&ldquo;interactions&rdquo;)을 의미합니다.
</p>
</dd>
<dt><code>I(<var>M</var>)</code></dt>
<dd><p><code>I()</code> 연산자는 insulate((식을) 보호함, 최근 버전에서는 Inhibit/(연산을)억제함으로 표현하기도 함)의
약자로서 모형식(model formula)에서, <var>M</var>에 작성된 표현식을 그 산술적(arithmetic) 의미대로 실행하여 그
결과가 모형행렬(model matrix)에서 하나의 항으로 포함될 수 있도록 해줍니다. 
</p></dd>
</dl>

<p>일반적으로 R에서는 <var>M</var>의 표현식에 포함된 모든 연산자들이 원래의 산술적 의미 그대로 사용됩니다. 하지만
모형연산자(model operators)로 사용되는 <code>+</code> 혹은 <code>-</code> 연산자는 해당 변수를 모델식(model
formula)에 포함할 것인지 제외할 것인지를 의미합니다. 하지만, 함수 <code>I()</code>는 일종의 아이덴티티(identity)
함수로 이 함수가 쓰인 해당 항이 모형식(model formulae) 내에서 산술 연산자를 포함할 수 있도록 해줍니다. 따라서, 모형식
안에서<code>I(M_1+M_2)</code>를 사용하면, <code>M_1</code>과 <code>M_2</code>을 더해진 결과가 하나의 항으로 식에
포함됩니다. 
</p>
<p>모형식(model formula)을 정의하는 데 있어, <em>모형행렬(model matrix)의 열</em>을 선택하는 것은 내재적으로
모형의 모수(parameters)를 선택하는 과정이기도 합니다.  하지만, 이런 내재적 의미는, 비선형(nonlinear)모형을 적합하는
것과 같은 다른 상황(context)에서는 성립하지 않는다는 점을 알아두시기 바랍니다.
</p>

<hr>
<a name="Contrasts"></a>
<a name="Contrasts-1"></a>
<h4 class="subsection">11.1.1 Contrasts</h4>
<a name="index-Contrasts"></a>

<p>이 부분에서는 최소한 모형식(model formula)을 지정하는 것이 모형 행렬(model matrix)의 열을 선택하는 것과 어떤
관련이 있는지 정도는 알고 있다고 가정하고 내용을 진행하겠습니다.  연속형 변수들이 각각의 열을 구성하는 모형 행렬(model
matrix)을 생각해보면 (사용할 모형이 절편(intercept)를 포함할 경우, 이 행렬은 <em>1</em>로만 이루어진 열을 하나 더
포함할 것입니다.), 이 관계를 이해하는 것이 전혀 어렵지 않을 것 입니다.
</p>
<a name="index-Factors-_0028yoin_0029-1"></a>
<a name="index-sunseohyeong-yoin-1"></a>
<p>그러나, <em>k</em>-개의 수준(level)을 가진 요인 <code>A</code>이 모형에 포함된다고 가정하면, 이 요인이
순서형(ordered)인지 비순서형(unordered)인지에 따라 이 관계가 조금 달라지게 됩니다.우선 <em>비순서형
요인(unordered factor)</em>의 경우, 두번째 수준부터 마지막 <em>k</em>번째 수준에 각각 대응되는
인디케이터(indicator/더미(dummy)변수)를 나타내기 위해 <em>k -1</em> 개의 열이 생성됩니다.(따라서, 이러한
모형화(parametrization)는 암묵적으로 각 수준이 첫번째 수준과 대조(contrast)시킵니다). 이와는 다르게,
<em>순서형 요인(ordered factor)</em>의 경우, <em>k-1</em>개의 열들은 상수항을 제외한 <em>1,
&hellip;, k</em>에 해당하는 직교다차항(orthogonal polynomials)을 나타냅니다.
</p>
<p>이미 복잡한 내용이 되버리기는 했지만, 이것이 모형식과 모형행렬의 관계의 전부가 아닙니다. 우선, 요인은 포함하지만
절편(intercept)은 포함하지 않는 모형을 생각해 볼 수 있습니다. 이 경우 포함된 요인의 모든 수준(level)을 표현할 수
있도록  <em>k</em>개의 열로 코딩 되어야합니다. 두번째로 고려할 점은, <code>options</code>을 사용하여
대조(<code>contrasts</code>)를 사용하는 방식을 변경할 경우, 모형에서 요인을 표현하는 방법이 완전히 달라지게 된다는 점입니다
.R에서는 디폴트(default)로 아래와 같이 지정되어 있습니다.
</p>
<div class="example">
<pre class="example">options(contrasts = c(&quot;contr.treatment&quot;, &quot;contr.poly&quot;))
</pre></div>

<p>이 부분을 따로 언급하는 이유는, R과 S에서 비순서형 요인(unordered factor)에 대해 다른
디폴트(default) 코딩을 사용하고 있기 때문입니다; S의 경우는 <code>Helmert</code> 방식을 사용합니다.또 다른 경우는
비순서형 요소를 사용할 경우, R과 S의 기본동작이 서로 다르다는 것입니다.S의 경우는 <code>Helmert</code>라는
방식을 이용합니다.따라서, 만약 <small>S-PLUS</small>를 사용한 결과를 바탕으로 쓰여진 책이나 논문의 내용을 R로 분석한 결과물과 비교해
보고 싶다면, 다음과 같은 설정이 필요 합니다.
</p>
<div class="example">
<pre class="example">options(contrasts = c(&quot;contr.helmert&quot;, &quot;contr.poly&quot;))
</pre></div>

<p>R에서 디폴트(default)로 <code>treatment</code> 대조를 채택한 이유는, 이 방법을 처음 다루는 초보자들에게는
<code>treatment</code> 대조로 생성된 결과를 해석하는 것이 쉬울것이라 믿었기 때문입니다.
</p>
<p>이번에는 함수 <code>contrasts</code>과 <code>C</code>를 사용하여 각각의 항을 모형에 포함시키기 위한 대조(contrast)의
사용법(scheme)을 좀 더 자세히 다뤄보도록 하겠습니다. 
<a name="index-contrasts"></a>
<a name="index-C"></a>
</p>
<p>우리는 어떤 식으로 교차항(interaction terms)을 모형에 포함할지에 대해서도 아직 다루지 않았습니다.교차항은 교호작용을
구성하는 변수들의 해당 열을 서로 곱(product)하여 생성합니다.
</p>
<p>교차항을 다루기 위한 세부사항들은 너무 복잡하기 때문에, 여기서 다루지는 않겠습니다. 하지만, R에서 모형을 사용하는 방법은 보통의
통계 전문가라면 예측할만한 방식을 크게 벗어나지 않습니다. 하지만 몇몇 예외가 있을 수 있는데, 교호작용(interaction)은
포함하지만 이에 대응하는 주효과(main effects)는 포함하지 않는 모형을 사용하는 것이 하나의 예가 될 수 있을 것입니다. 이
경우 일반적으로 기대하는 것과는 많이 다른 결과가 얻어질 수 있는데, 이는 아마도 이 분야 전문가들이나 관심을 가질만한 주제일 것
입니다.
</p>

<hr>
<a name="Linear-models"></a>
<a name="Linear-models-1"></a>
<h3 class="section">11.2 Linear models</h3>
<a name="index-Linear-models"></a>

<p>일반(ordinary) 다중(multiple,여러 개 항을 포함하는)모형을 적합하는 가장 간단한 방법은 아래와 같이 함수
<code>lm()</code>를 이용하는 것입니다:
<a name="index-lm"></a>
</p>
<div class="example">
<pre class="example">&gt; <var>fitted.model</var> &lt;- lm(<var>formula</var>, data = <var>data.frame</var>)
</pre></div>

<p>다음의 예시를 살펴봅니다.
</p>
<div class="example">
<pre class="example">&gt; fm2 &lt;- lm(y ~ x1 + x2, data = production)
</pre></div>

<p>예를 들면, 아래의 코드는 종속변수 <em>y</em>를 설명변수 <em>x1</em>과 <em>x2</em>에 회귀시킨
다중회귀모형(multiple regression model)을 적합시킵니다.(따로 표시된 것은 아니지만, 상수항(intercept
term)이 항상 포함된다는 점을 잊지 마시기 바랍니다.) 
</p>
<p>위 식에 사용된 것 중 중요한 (하지만 이 함수의 실행을 위해서는 반드시 필요한 것은 아닌) 모수(parameter)로는
<code>data = production</code>가 있습니다. 이 모수는 선형모형을 적합시키게 될 데이터를 지정하는 것으로, 여기서 지정된
<em>데이터 프레임(data frame)</em> <code>production</code>는 반드시 모형에 포함될 모든 변수들을 포함하고 있어야
합니다. <em>이러한 데이터 프레임의 지정은 해당 데이터 프레임,이 예제에서는 <code>production</code>이, 검색
경로(search path)상에 연결되었건(attached) 그렇지 않든 상관없이 동일하게 이루어져야 합니다.</em>
</p>
<hr>
<a name="Generic-functions-for-extracting-model-information"></a>
<a name="Generic-functions-for-extracting-model-information-1"></a>
<h3 class="section">11.3 Generic functions for extracting model information</h3>

<p><code>lm()</code>을 사용하면 적합된 선형모형을 하나의 객체로 얻게됩니다; 이 객체는 클래스(class)가 <code>&quot;lm&quot;</code>인 여러
개의 결과물로 구성된 하나의 리스트 입니다. 이렇게 <code>lm()</code> 함수를 사용해 적합된 모형에 관련된 정보는
일반함수(generic functions)를 사용하여 생성된 결과물을 출력하거나, 일부 정보만을 따로 추출하거나, 또는 플롯을 그리는 등
다양하게 활용할 수 있습니다.이렇게 모형 정보를 다룰 수 있는 일반함수에는 다음과 같은 종류가 있습니다. 
</p>
<div class="example">
<pre class="example">add1    deviance   formula      predict  step
alias   drop1      kappa        print    summary
anova   effects    labels       proj     vcov
coef    family     plot         residuals
</pre></div>

<p>이 중에서 가장 빈번하게 사용되는 일반함수들에 대해서 아래와 같이 정리해 보았습니다.
</p>
<dl compact="compact">
<dd><a name="index-anova"></a>
</dd>
<dt><code>anova(<var>object_1</var>, <var>object_2</var>)</code></dt>
<dd><p>이 함수는 두개의 적합된 모형을 비교하는 것으로, 분산분석표를 제공 합니다. (여기서 사용된 두 개의 모형은 임의로 선택된다기 보다는
하나의 새 모형(outer model)과 이 모형의 일부를 포함하는 다른 모형(submodel)이어야 합니다.) 
</p>
<a name="index-coefficients"></a>
<a name="index-coef"></a>
</dd>
<dt><code>coef(<var>object</var>)</code></dt>
<dd><p>적합된 선형계수를 (행렬의 형태로) 추출해줍니다.여기에서 <code>coef()</code>는 <code>coefficients()</code>라는 원래
함수의 약어 표현입니다.
</p>
<p>Long form: <code>coefficients(<var>object</var>)</code>.
</p>
<a name="index-deviance"></a>
</dd>
<dt><code>deviance(<var>object</var>)</code></dt>
<dd><p>잔차(residual)를 제곱하여 이를 모두 더한 값을 출력하며, 경우에 따라서는 weighted 된 잔차를 사용할 수도 있습니다. 
</p>
<a name="index-formula"></a>
</dd>
<dt><code>formula(<var>object</var>)</code></dt>
<dd><p><var>object</var>를 적합하는데 사용한 모형식(model formula)을 보여줍니다.
</p>
<a name="index-plot"></a>
</dd>
<dt><code>plot(<var>object</var>)</code></dt>
<dd><p><var>object</var>의 잔차(residuals)와 적합된 값(fitted values)을 보여주는 4가지 플롯과 함께 몇가지
모형진단(diagnostics)통계량을 제공합니다.
</p>
<a name="index-predict"></a>
</dd>
<dt><code>predict(<var>object</var>, newdata=<var>data.frame</var>)</code></dt>
<dd><p>적합된 모형을 사용하여 예측값(predicted values)를 구해줍니다. 이때 예측에 사용될 데이터 프레임은 반드시 원래의 모형적합에
사용된 데이터와 같은 변수명을 가져야 합니다. 이 함수를 사용한 결과로 <var>data.frame</var>으로 입력된 변수값을 이용하여 계산된
예측값이 벡터 또는 행렬로 출력됩니다. 
</p>

<a name="index-print"></a>
</dd>
<dt><code>print(<var>object</var>)</code></dt>
<dd><p>객체를 간결한 형태로 출력합니다. 많은 경우, 별도의 입력 없이도 결과가 출력됩니다. 
</p>
<a name="index-residuals"></a>
<a name="index-resid"></a>
</dd>
<dt><code>residuals(<var>object</var>)</code></dt>
<dd><p>적합된 모형에 대한 잔차 또는  weighted 잔차를 (행렬의 형태로) 추출합니다. (원래의 <code>residuals()</code> 함수를
약어인 <code>resid(<var>object</var>)</code>로 사용하실 수도 있습니다.)
</p>
<p>Short form: <code>resid(<var>object</var>)</code>.
</p>
<a name="index-step"></a>
</dd>
<dt><code>step(<var>object</var>)</code></dt>
<dd><p>스텝와이즈 (stepwise) 검색으로 최적모형을 찾아줍니다. 변수의 중요도(hierarchies)에 따라 한번 하나씩 항을 추가하거나
제거함으로서 적당한 모형을 선택하는 방법입니다. 스텝와이즈 검색을 사용할 경우, 가장 작은 AIC(Akaike&rsquo;s Information
Criterion)값을 갖는 모형을 선택하게 됩니다.
</p>
<a name="index-summary-1"></a>
</dd>
<dt><code>summary(<var>object</var>)</code></dt>
<dd><p>회귀분석의 결과를 간결한 형태로 요약하여 보여줍니다.
</p>
<a name="index-vcov"></a>
</dd>
<dt><code>vcov(<var>object</var>)</code></dt>
<dd><p>적합된 회귀계수들에 대한 분산-공분산 (variance-covariance) 행렬을 출력합니다.
</p></dd>
</dl>

<hr>
<a name="Analysis-of-variance-and-model-comparison"></a>
<a name="Analysis-of-variance-and-model-comparison-1"></a>
<h3 class="section">11.4 Analysis of variance and model comparison</h3>
<a name="index-Analysis-of-variance"></a>

<p>The model fitting function <code>aov(<var>formula</var>, data=<var>data.frame</var>)</code>
<a name="index-aov"></a>
분산분석(analysis of variance)을 수행하기 위해 <code>aov(<code>formula</code>,
data=<var>data.frame</var>)</code> 함수를 사용할 수 있습니다. 이 함수는 <code>lm()</code> 함수와 대체로 비슷한 연산을
수행한다고 볼 수 있으며, 따라서 위의 <a href="#Generic-functions-for-extracting-model-information">Generic functions for extracting model information</a>편에서 열거한 일반함수(generic functions)들을 거의 그대로 사용할 수 있습니다. 
</p>
<p>하지만, <code>aov()</code>함수는 오차의 다중계층(multiple error strata)구조를 가정한 모형을 다룰 수 있어, 분할법
실험(split plot experiment)이나 블럭간(inter-block)정보를 사용한 균형 불완비블럭설계(balanced
incomplete block design)와 같은 모형을 분석하기 위해 사용할 수 있다는 큰 장점을 가지고 있습니다. 모형식은 다음과
같이 사용할 수 있습니다.
</p>
<div class="example">
<pre class="example"><var>response</var> ~ <var>mean.formula</var> + Error(<var>strata.formula</var>)
</pre></div>
<a name="index-Error"></a>

<p>위 식은 <var>strata.formula</var>에 정의된 대로 오차의 계층(error strata)구조를 가정한 다계층실험
(multi-stratum experiement)을 표현한 것입니다.가장 간단한 경우로, 요인의 수준(levels)간(between)
차이와 수준내(within) 차이만 고려하는 2계층-실험(two strata experiment)이 있고, 이 경우
<var>strata.formula</var>는 단순히 하나의 요인이 됩니다.
</p>
<p>구체적인 예를 들면, 모형을 구성하는 모든 변수와 요인을 사용하여 아래와 같은 모형식(model formula)을 작성할 수 있습니다: 
</p>
<div class="example">
<pre class="example">&gt; fm &lt;- aov(yield ~ v + n*p*k + Error(farms/blocks), data=farm.data)
</pre></div>

<p>이 식은 보통 <code>v + n*p*k</code>로 표현되는 평균 모형(mean model)으로 실험을 기술할 때 사용되며, 이 경우
&ldquo;between farms&rdquo;, &ldquo;within farms&rdquo;, 그리고 &ldquo;within blocks&rdquo;라는 세 개의 오차계층(error
strata)을 포함합니다.
</p>

<hr>
<a name="ANOVA-tables"></a>
<a name="ANOVA-tables-1"></a>
<h4 class="subsection">11.4.1 ANOVA tables</h4>

<p>분산분석(the analysis of variance,ANOVA)(또는 분산분석표)은 사실 여러 개의 모형을 적합한 결과를 나타내고
있다는 점을 이해할 필요가 있습니다. 보통 잔차합 (sums of squares,SS)은 주어진 시퀀스의 <em>해당 위치(that
place)</em>에 있는<em>해당 변수(that term)</em>를 모형에 하나씩 포함시킬때 마다 점점 감소합니다. 즉, 오직
직교실험(orthogonal experiment)의 경우에만 항을 추가해나가는 순서가 중요하지 않습니다. 
</p>
<p>다계층실험(multistratum experiments)의 경우, 우선 종속(response)변수를 오차계층(error strata)에
시퀀스 순서대로 정사영(project)시켜 나가면서, 각 정사영마다 평균모형( mean model)을 적합하는 과정을 통해 분산분석을
수행하게 됩니다. 여기에 대한 자세한 설명은 Chambers &amp; Hastie (1992)의 책을 참고하시길 바랍니다. 
</p>
<p>이렇게 디폴트(default) ANOVA 테이블로 각 모형을 따로 적합한 결과들을 비교하는 것 보다는 좀 더 쉽게, 두개 이상의 모형들을
한번에 비교하고 싶다면, <code>anova()</code> 함수를 사용하면 됩니다.
<a name="index-anova-1"></a>
</p>
<div class="example">
<pre class="example">&gt; anova(<var>fitted.model.1</var>, <var>fitted.model.2</var>, &hellip;)
</pre></div>

<p><code>anova()</code> 함수를 사용하면, 입력한 순서대로 적합된 모형 간의 차이를 보여주는 테이블을 생성합니다.이때, 비교하게 될
모형들은,물론 일종의 계층적 순서(hierarchical sequence)를 가져야만 합니다.<code>anova()</code> 함수를 사용하는
것이 디폴트(default) 함수를 사용했을 때와 다른 정보를 더 제공하는 것은 아니지만, 좀 더 이해하기 쉽고 손쉽게 모형을 비교하기
위해 사용한다고 보시면 됩니다.
</p>
<hr>
<a name="Updating-fitted-models"></a>
<a name="Updating-fitted-models-1"></a>
<h3 class="section">11.5 Updating fitted models</h3>
<a name="index-Updating-fitted-models"></a>

<p><code>update()</code> 함수는 이미 적합된 모형에 몇 개의 항만을 추가하거나 혹은 제거해서 새로운 모형으로서 적합시키고자 할 때
매우 유용하게 사용할 수 있으며, 다음과 같이 사용합니다.
<a name="index-update"></a>
</p>
<div class="example">
<pre class="example">&gt; <var>new.model</var> &lt;- update(<var>old.model</var>, <var>new.formula</var>)
</pre></div>

<p>위 식의 <var>new.formula</var> 부분에서 마침표(period) &lsquo;<samp><code>.</code></samp>&rsquo; 하나가 사용될 경우, 이것은 &quot;이전
모형으로부터 온 부분들&quot;이라는 의미로 사용된 것 입니다. 
<a name="index-_002e"></a>
좀 더 확실한 이해를 위해 아래의 예제를 살펴봅시다.
</p>
<div class="example">
<pre class="example">&gt; fm05 &lt;- lm(y ~ x1 + x2 + x3 + x4 + x5, data = production)
&gt; fm6  &lt;- update(fm05, . ~ . + x6)
&gt; smf6 &lt;- update(fm6, sqrt(.) ~ .)
</pre></div>

<p>제일 먼저 데이터 프레임 <code>production</code>으로부터 온 5개의 변수를 포함하는 중회귀(multiple regression)
모형(fm05)을 적합하고, 이를 바탕으로 6번째 변수를 추가하여 모형을 다시 적합한 후(fm6), 다시 이 모형에서 제곱근(square
root) 변환시킨 종속변수를 사용하여 모형을 적합한 것입니다 (smf6).
</p>
<p>특히, 제일 처음으로 사용한 모형 적합 함수에서 <code>data=</code> 인자(argument)가 지정된 경우에는, 이 정보가 모형 적합에
사용되는 과정을 통헤  <code>update()</code> 함수와 그 함수족(allies)을 사용할 경우 그대로 전달되어 사용된다는 점을
기억하시기 바랍니다. 
</p>
<p>또, &lsquo;<samp><code>.</code></samp>&rsquo;는 다른 상황(contexts)에서 사용될 때는 위에서 설명한 것과 약간 다른 의미로 사용된다는 점도
주의해야 합니다. 아래의 예에서는, 
</p>
<div class="example">
<pre class="example">&gt; fmfull &lt;- lm(y ~ . , data = production)
</pre></div>

<p>종속(response)변수 <code>y</code>와 함께 데이터 프레임 <code>production</code>에 포함된 <em>모든 변수들</em>을
회귀변수로 사용하는 모형을 적합하겠다는 의미입니다.
</p>
<p>순서대로 항을 늘려가며 모형을 비교하기 위해서는 <code>add1()</code>, <code>drop1()</code> 그리고 <code>step()</code>와
같은 함수들을 사용할 수 있습니다.
<a name="index-add1"></a>
<a name="index-drop1"></a>
<a name="index-step-1"></a>
이 함수들은 이름 그대로의 의미로 사용할 수 있으며,더 자세한 사항은 각 함수의 도움말을 살펴보시길 바랍니다.
</p>
<hr>
<a name="Generalized-linear-models"></a>
<a name="Generalized-linear-models-1"></a>
<h3 class="section">11.6 Generalized linear models</h3>
<a name="index-Generalized-linear-models"></a>

<p>일반화 선형 모델(generalized linear model)이란 정규분포가 아닌 분포를 갖는 종속변수(non-normal
response)와 변수변환(transformation)을 통한 선형성(linearity)의 만족이라는 두 과제를 깔끔하게 해결하기 위해
선형모형(linear model)을 좀 더 발전시킨 것이라고 생각하시면 됩니다.일반화 선형 모형은 다음과 같은
가정(assumptions)들을 사용하여 정의할 수도 있습니다:
</p>
<ul>
<li> 이 모형에는 하나의 종속(response)변수 <em>y</em>가 있고, 이 반응변수의 분포에 영향을 미치는 여러 개의
설명변수(stimulus variables) 
x_1, x_2, &hellip;,
가 포함되어 있습니다.

</li><li> 이 모형헤어 설명변수들이 <em>y</em>의 분포에 미치는 영향은 <em>오직 단순 선형 함수의 형태</em>로 나타낼 수 있어야 합니다. 이
선형 함수는 <em>linear predictor</em>라고 부를 수 있으며, 다음과 같이 사용될 수 있습니다. 
<div class="display">
<pre class="display">eta = beta_1 x_1 + beta_2 x_2 + &hellip; + beta_p x_p,
</pre></div>
<p>따라서, i번째 설명변수 x_i의 선형계수인 beta_i가 0 인 경우에는 이 변수가 <em>y</em>의 분포에 아무런 영향을 미치지
않습니다.
</p>
</li><li> <em>y</em>의 분포는 아래와 같은 형식으로 표현할 수 있습니다.
<div class="display">
<pre class="display">f_Y(y; mu, phi)
  = exp((A/phi) * (y lambda(mu) - gamma(lambda(mu))) + tau(y, phi))
</pre></div>
<p>위 예시에서 <code>phi</code>는 <em>스케일 모수(scale parameter)</em>로 (주로 주어지는 값이며), 모든 관측치에 대해
같은 상수값을 갖습니다. 또, <em>A</em>는 사전가중치(prior weight)를 의미하며, 이 역시 주어진 값이긴 하지만 관측치에
따라 다른 값을 가질 수도 있습니다. 마지막으로 $\mu$는 <em>y</em>의 평균을 의미합니다.
따라서, 이 식에서 <em>y</em>의 분포는 평균과 스케일 모수(parameter)에 의해 결정 됩니다.
</p>
</li><li> <em>y</em>의 평균 <code>mu</code>는 linear predictor의 스무드한 가역함수(smooth invertible
function)로 표현됩니다:
<div class="display">
<pre class="display">mu = m(eta),    eta = m^{-1}(mu) = ell(mu)
</pre></div>
<p>여기서 역함수인 ell()을 <em>링크함수(link function)</em>이라고 합니다.
</p>
</li></ul>

<p>위의 가정들은 통계실무에서 사용하는 꽤 광범위한 클래스의 모형들을 포함할 수 있는 최소한의 가정이지만, 추정(estimation)과
추론(inference)을 하기 위한 하나의 통일된 방법론(methodology)이나 그 비슷한 것을 개발할 수 있을 만큼 충분히
구체적이기도 합니다. 일반화 선형 모형의 최신 레퍼런스나 좀 더 자세한 정보에 관심이 있는 분들께는 McCullagh &amp; Nelder
(1989)와 Dobson (1990)을 찾아보실 것을 권하고 싶습니다.
</p>

<hr>
<a name="Families"></a>
<a name="Families-1"></a>
<h4 class="subsection">11.6.1 Families</h4>
<a name="index-Families"></a>

<p>R에서는 일반화 선형모형에서 종속변수의 분포가 <em>가우시안(gaussian = 정규분포)</em>, <em>이항
(binomial)</em>, <em>포아송 (poisson)</em>, <em>역가우시안 (inverse gaussian)</em>, 그리고
<em>감마 (gamma)</em>인 경우를 모두 다룰 수 있으며, 또 종속변수의 분포가 분포 함수에 의해 정확히 묘사될 수 없는 경우에
사용하는 <em>쿼시-라이클리후드 (quasi-likelihood)</em> 모형 역시 지원합니다.특히 쿼시-라이클리후드 모형의 경우,
<em>분산함수(variance function)</em>를 반드시 평균(mean)의 함수식 형태로 나타낼 수 있어야 하지만, 이 외의 다른
경우에는 종속변수의 분포가  분산함수(variance function)의 형태를 내포합니다.  
</p>
<p>종속변수의 각 분포들은 아래와 같이 다양한 연결함수(link functions)를 사용하여 이 분포의 평균과 linear
predictor를 연결합니다. 사용가능한  분포와 연결함수는 다음과 같습니다:
</p>
<blockquote>
<table>
<thead><tr><th width="25%">Family name</th><th width="55%">Link functions</th></tr></thead>
<tr><td width="25%"><code>binomial</code></td><td width="55%"><code>logit</code>, <code>probit</code>, <code>log</code>, <code>cloglog</code></td></tr>
<tr><td width="25%"><code>gaussian</code></td><td width="55%"><code>identity</code>, <code>log</code>, <code>inverse</code></td></tr>
<tr><td width="25%"><code>Gamma</code></td><td width="55%"><code>identity</code>, <code>inverse</code>, <code>log</code></td></tr>
<tr><td width="25%"><code>inverse.gaussian</code></td><td width="55%"><code>1/mu^2</code>, <code>identity</code>, <code>inverse</code>, <code>log</code></td></tr>
<tr><td width="25%"><code>poisson</code></td><td width="55%"><code>identity</code>, <code>log</code>, <code>sqrt</code></td></tr>
<tr><td width="25%"><code>quasi</code></td><td width="55%"><code>logit</code>, <code>probit</code>, <code>cloglog</code>,
<code>identity</code>, <code>inverse</code>, <code>log</code>, <code>1/mu^2</code>, <code>sqrt</code></td></tr>
</table>
</blockquote>

<p>종속변수의 분포와 연결함수, 그리고 모형을 실행하기 필요한 다른 모든 정보들의 조합을 일반화 선형모형에서의
<em>분포족(family)</em>이라고 합니다. 
</p>
<hr>
<a name="The-glm_0028_0029-function"></a>
<a name="The-glm_0028_0029-function-1"></a>
<h4 class="subsection">11.6.2 The <code>glm()</code> function</h4>
<a name="index-glm"></a>

<p>일반화 선형모형에서도 종속변수의 분포가 오직 단순 선형함수의 형태로만 설명변수들과 연관되기 때문에, 선형모형 적합에 사용된 방법이 일반화
모형의 선형 부분에도 그대로 적용될 수 있습니다. 다만, 분포족(family)을 지정해야한다는 차이가 있습니다.
</p>
<p>일반화 선형모형을 적합하는데 사용하는 R 함수는 <code>glm()</code>이며, 아래와 같이 사용합니다.
</p>
<div class="example">
<pre class="example">&gt; <var>fitted.model</var> &lt;- glm(<var>formula</var>, family=<var>family.generator</var>, data=<var>data.frame</var>)
</pre></div>

<p>(<code>lm()</code>함수와 비교했을 때) 유일하게 하나 첨가된 기능은 <var>함수족.생성자(family.generator)</var>이며,
어떤 함수족을 모형에 사용할 것인지를 지정해주는 도구 같은 것입니다. 이 함수는 해당 모형과 그 추정(estimation)을 정의하고
실행하기위해 필요한 함수들과 표현식들의 리스트를 생성해 줍니다. 언뜻 매우 복잡할 것처럼 보일 수도 있지만, 사실 사용하기 매우 간단한
함수 입니다.
</p>
<p><code>함수족 생성자(family generator)</code>에 사용될 수 있는 분포들의 표준 표기명은 <a href="#Families">Families</a> 섹션에
있는 표에서 &quot;함수족 이름 (Family Name)&quot; 부분에서 찾으실 수 있습니다. 또 연결함수를 따로 선택하고 싶은 경우,
모수(paramter)를 지정할 때 처럼, 분포족(family)이름 옆 괄호(parentheses) 안에 연결함수의 이름을 입력하시면
됩니다.  또 <code>쿼시(quasi)</code>족의 경우, 분산함수(variance function)를 이와 비슷한 방식으로 입력할 수
있습니다. 
</p>
<p>아래의 예들을 살펴보시면 사용법이 좀 더 분명하게 이해될 것입니다.
</p>
<a name="The-gaussian-family"></a>
<h4 class="subsubheading">The <code>gaussian</code> family</h4>

<p>아래와 같이 <code>glm()</code> 함수를 사용하면 <code>lm()</code>을 사용할 때와 같은 결과를 얻긴하지만 훨씬 비효율적입니다. 
</p>
<div class="example">
<pre class="example">&gt; fm &lt;- glm(y ~ x1 + x2, family = gaussian, data = sales)
</pre></div>

<p>achieves the same result as
</p>
<div class="example">
<pre class="example">&gt; fm &lt;- lm(y ~ x1+x2, data=sales)
</pre></div>

<p>가우시안족(gaussian family)은 연결함수의 선택이 그다지 필요하지 않기 때문에, 굳이 모수(parameter)를 지정할 필요가
없다는 점을 생각해보시기 바랍니다. 만약 가우시안족(gaussian family)에 표준이 아닌 (nonstandard) 연결함수를
사용하고 싶다면, 뒤에서 다루게 될, <code>쿼시족(quasi family)</code>을 사용하는 것이 보통입니다. 
</p>
<a name="The-binomial-family"></a>
<h4 class="subsubheading">The <code>binomial</code> family</h4>

<p>Silvey (1970)에서 사용된 간단한 예제를 살펴봅시다.
</p>
<p>에게해의 한 섬인 Kalythos에는 남성들이 선천성 안질환을 앓고 있는데, 이 안질환은 주로 나이가 들어감에 따라 더욱
진행됩니다. 아래의 데이터는 이 섬에 거주하는 다양한 연령대의 남성들의 실명여부를 검사한 결과를 기록한 것입니다:
</p>
<table>
<tr><td>Age:</td><td>20</td><td>35</td><td>45</td><td>55</td><td>70</td></tr>
<tr><td>No. tested:</td><td>50</td><td>50</td><td>50</td><td>50</td><td>50</td></tr>
<tr><td>No. blind:</td><td>&nbsp;6<!-- /@w --></td><td>17</td><td>26</td><td>37</td><td>44</td></tr>
</table>

<p>이 데이터에 로지스틱(logistic)과 프로빗(probit) 두가지 모형을 모두 적합시키고, 각 모형으로부터 남성거주자의 실명확률이
50%가 되는 나이인 LD50를 추정하고자 합니다.
</p>
<p>만약 <em>y</em>가 연령 <em>x</em> 때의 테스트에서 확인된 실명한 사람들의 수이고, <em>n</em>은 테스트를 받은 사람의
수라면, 두 모형은 아래와 같이 표현됩니다.
y ~ B(n, F(beta_0 + beta_1 x))
프로빗 모형의 경우,  F(z) = Phi(z) 표준 정규 분포(standard normal
distribution function)를, 로짓 모형의 경우, F(z) =
e^z/(1+e^z) 입니다.두 경우 모두 LD50는
LD50 = - beta_0/beta_1
으로 계산할 수 있으며, 이 값은 분포함수 <code>F(z)</code>의 값이 <em>0</em>일 때의 <code>z</code>에 해당합니다
</p>
<p>위 문제를 풀기위한 첫번째 단계로 우선 모형에서 다루게 될 데이터를 데이터 프레임의 형식으로 준비합니다.
</p>
<div class="example">
<pre class="example">&gt; kalythos &lt;- data.frame(x = c(20,35,45,55,70), n = rep(50,5),
                         y = c(6,17,26,37,44))
</pre></div>

<p><code>glm()</code> 함수를 이용하여 이항모형(binomial model)을 적합할 경우에는, 아래의 세가지 종속변수(response)
종류 중 한 가지를 선택하실 수 있습니다:
</p>
<ul>
<li> 종속변수가 <em>벡터(vector)</em>인 경우, <em>이진법(binary)</em> 데이터를 담고 있으므로, 반드시 <em>0</em>과
<em>1</em>로만 구성된 벡터여야 합니다. 

</li><li> 종속변수가 <em>2열의 행렬</em>이라면, 첫번째 열은 해당 시행(trial)에 대한 성공횟수 그리고 두번째 열은 실패횟수를 저장합니다.

</li><li> 만약 종속변수가 <em>요인(factor)</em>인 경우, 첫번째 수준을 실패(<em>0</em>)로, 그 외의 모든 다른 수준들은 성공
(<em>1</em>)이라고 간주합니다.
</li></ul>

<p>이 예제에서는 이 중 두번째 방법을 사용할 것입니다, 따라서 아래와 같이 행렬 하나를 준비된 데이터 프레임 안에 추가하겠습니다.
</p>
<div class="example">
<pre class="example">&gt; kalythos$Ymat &lt;- cbind(kalythos$y, kalythos$n - kalythos$y)
</pre></div>

<p>모형의 적합은 아래와 같습니다.
</p>
<div class="example">
<pre class="example">&gt; fmp &lt;- glm(Ymat ~ x, family = binomial(link=probit), data = kalythos)
&gt; fml &lt;- glm(Ymat ~ x, family = binomial, data = kalythos)
</pre></div>

<p><code>logit</code> 연결함수가 디폴트이므로, 두번째 식에서는 해당 모수(parameter)의 입력은 생략될 수 있습니다. 각 모형의
적합된 결과를 확인하기 위해,
</p>
<div class="example">
<pre class="example">&gt; summary(fmp)
&gt; summary(fml)
</pre></div>

<p>두 모형 모두 적합결과가 아주 좋습니다. LD50을 추정하기 위해, 다음과 같은 간단한 함수를 작성할 수 있습니다:
</p>
<div class="example">
<pre class="example">&gt; ld50 &lt;- function(b) -b[1]/b[2]
&gt; ldp &lt;- ld50(coef(fmp)); ldl &lt;- ld50(coef(fml)); c(ldp, ldl)
</pre></div>

<p>이 데이터로부터 얻어진 실제 추정치는 각각 43.663세 와 43.601세 입니다.
</p>
<a name="Poisson-models"></a>
<h4 class="subsubheading">Poisson models</h4>

<p>포아송족 (Poisson family)의 경우, 디폴트로 <code>log</code>가 연결함수로 지정되어 있으며, 보통 실무에서
포아송족(Poisson family)을 주로 사용하게 되는 경우는 빈도데이터(frequency data)를 대체형(surrogate)
(포아송) 로그선형모형(Poisson log-linear model)에 적합할 때 입니다. 로그선형모형을 대체형(surrogate)이라고
한 이유는, 빈도데이터의 경우, 실제 분포는 대체로 (포아송이 아니라) 다항분포(multinomial distribution)이기
때문입니다. 이 모형의 사용은 매우 중요하지만 너무 방대한 주제라 여기서는 다루지 않겠습니다. 사실 빈도데이터에 포아송 분포를 가정하는
모형은 비정규형(non-gaussian) 일반화 모형 전체에서 가장 대표적인 방법이라고 할 수 있겠습니다.  
</p>
<p>물론 때때로 데이터가 정말 포아송 분포에서 얻어지는 경우도 있겠지만, 이 경우 과거에는, (실무에서는 아직도) 데이터를 로그나 제곱근으로
변환하여 가우시안(gaussian) 데이터로 바꾼 다음 분석을 수행했습니다. 하지만 이제는 아래와 같이 포이송 일반화 선형모형을 적합하는
것이  가능합니다.
</p>
<div class="example">
<pre class="example">&gt; fmod &lt;- glm(y ~ A + B + x, family = poisson(link=sqrt),
              data = worm.counts)
</pre></div>

<a name="Quasi_002dlikelihood-models"></a>
<h4 class="subsubheading">Quasi-likelihood models</h4>

<p>일반화 선형모형의 모든 함수족(families)에서, 종속변수의 분산은 평균에 대한 함수이며, 스케일 모수(parameter)는
계수(multiplier)입니다. 분산이 평균과 어떤 식으로 연관되는지 나타내는 식은 종속변수분포의 중요한 특성이라 볼 수 있습니다;
예를 들면, 포아송 분포의 경우 Var(y) = mu.
</p>
<p>쿼시-라이클리후드(Quasi-likelihood)를 이용한 추정(estimation)과 추론(inference)을 위해, 정확한
종속변수의 분포를 지정할 필요는 없지만, 연결함수(link function)와 평균(mean)의 함수 형태로 분산함수(variance
function)는 지정되어야 합니다. 쿼시-라이클리후드(Quasi-likelihood)를 이용한 추정에는 가우시안 분포의 경우와 완전히
동일한 방법을 사용하므로, 표준혀이 아닌 (non-standard) 연결함수 또는 분산함수(variance funtion)를 가정하는
가우시안 모형을 적합하는 데도 사용할 수 있습니다.
</p>
<p>예를들어, 아래와 같이 비선형회귀모형을 적합할 경우
y = theta_1 z_1 / (z_2 - theta_2) + e
이 모형은 아래와 같은 방법으로 사용할 수도 있습니다.
y = 1 / (beta_1 x_1 + beta_2 x_2) + e
where
x_1 = z_2/z_1, x_2 = -1/z_1, beta_1 = 1/theta_1, and beta_2 =
theta_2/theta_1.
적당한 데이터 프레임이 존재한다고 가정하면, 위의 비선형회귀모형은 다음과 같이 적합할 수도 있습니다.
</p>
<div class="example">
<pre class="example">&gt; nlfit &lt;- glm(y ~ x1 + x2 - 1,
               family = quasi(link=inverse, variance=constant),
               data = biochem)
</pre></div>

<p>더 자세한 설명이 필요하면 해당 매뉴얼과 도움말을 이용하시길 바랍니다.
</p>
<hr>
<a name="Nonlinear-least-squares-and-maximum-likelihood-models"></a>
<a name="Nonlinear-least-squares-and-maximum-likelihood-models-1"></a>
<h3 class="section">11.7 Nonlinear least squares and maximum likelihood models</h3>
<a name="index-Nonlinear-least-squares"></a>

<p>특정한 형식을 갖춘 비선형모형은 일반화 선형모형(<code>glm()</code>)을 사용하여 적합할 수 있습니다. 하지만 대부분의 경우,
비선형모형은 비선형 최적화(nonlinear optimization) 방법 중 하나를 사용하여 비선형 곡선(curve)에 적합시키는
방식으로 풀어야만 합니다. R은 이런 비선형 최적화 문제를 풀어주는 <code>optim()</code>, <code>nlm()</code> 그리고
(R 2.2.0 부터는) <code>nlminb()</code> 함수를 제공합니다. 
<a name="index-nlm"></a>
<a name="index-optim"></a>
<a name="index-nlminb"></a>
특히, <code>nlminb()</code> 함수의 경우, <small>S-PLUS</small>에서 사용되는 <code>ms()</code>와 <code>nlminb()</code> 함수와
같은 (혹은 좀 더 다양한) 기능을 제공합니다. 이러한 함수를 사용할 경우, 주어진 적합결여지표(index of lack-of-fit)를
최소화시키는 모수의 값을 찾는것이 우리의 관심사이며,  위의 함수들은 모수에 여러 값을 반복적으로 대입하여 최적값을 찾습니다. 그러나,
이러한 프로시져를 사용할 경우, 선형회귀에서 모수를 추정할 때와는 달리, 만족스러울만한 추정치로 수렴하게 될거라는 보장은 없습니다. 모수
추정을 위해 초기값을 사용해야하는 모든 계산 방법에서는 이 초기값을 얼마나 잘 선택하는지에 따라 수렴결과가 크게 달라지기 때문입니다.
</p>

<hr>
<a name="Least-squares"></a>
<a name="Least-squares-1"></a>
<h4 class="subsection">11.7.1 Least squares</h4>

<p>비선형모형을 적합하는 한가지 방법은 오차 혹은 잔차들의 제곱합(the sum of the squared errors or
residuals)을 최소화시키는 것입니다. 이러한 최소제곱법은 관측된 오차들이 정규분포를 따른다고 보여질 경우에 권장됩니다.
</p>
<p>여기서 Bates &amp; Watts (1988), page 51에 수록된 예제를 하나 살펴보도록 하겠습니다. 주어진 데이터는 아래와
같습니다.
</p>
<div class="example">
<pre class="example">&gt; x &lt;- c(0.02, 0.02, 0.06, 0.06, 0.11, 0.11, 0.22, 0.22, 0.56, 0.56,
         1.10, 1.10)
&gt; y &lt;- c(76, 47, 97, 107, 123, 139, 159, 152, 191, 201, 207, 200)
</pre></div>

<p>최소화하기 위한 적합기준을 다음과 같습니다:
</p>
<div class="example">
<pre class="example">&gt; fn &lt;- function(p) sum((y - (p[1] * x)/(p[2] + x))^2)
</pre></div>

<p>모형적합을 위해 모수에 대한 초기값이 필요합니다. 그럴듯한 초기값을 찾는 방법 중 하나는 데이터를 플롯시킨 후, 모수값을 추측해서,
데이터 값과 유사한 패턴을 주는 모형의 곡선을 겹쳐 그려보는 것입니다.
</p>
<div class="example">
<pre class="example">&gt; plot(x, y)
&gt; xfit &lt;- seq(.02, 1.1, .05)
&gt; yfit &lt;- 200 * xfit/(0.1 + xfit)
&gt; lines(spline(xfit, yfit))
</pre></div>

<p>물론 더 나은 추측값이 있을 수 있지만, 200 과 0.1 을 초기값으로 하는 것에 무리는 없어 보입니다. 이제 모형을 적합시켜 보면:
</p>
<div class="example">
<pre class="example">&gt; out &lt;- nlm(fn, p = c(200, 0.1), hessian = TRUE)
</pre></div>
<a name="index-nlm-1"></a>

<p>모형을 적합시키고 나면, <code>out$minimum</code>는 SSE를, <code>out$estimate</code>는 최소제곱법을 이용한 모수
추정치(estimates)를 보여줍니다. 추정치의 표준오차(standard error, SE)의 근사치는 아래 식으로 구할 수 있습니다:
</p>
<div class="example">
<pre class="example">&gt; sqrt(diag(2*out$minimum/(length(y) - 2) * solve(out$hessian)))
</pre></div>

<p>위 식에서 숫자 2는 모형에 포함된 모수(parameter)의 개수를 의미합니다. 모수의 추정치에 대한 95% 신뢰구간은 추정치에
+/- 1.96*SE 하여 계산할 수 있습니다. 또 최소제곱법으로 구한 추정치의 핏(fit)을 데이터 플롯 위에
덧그릴수도 있습니다:
</p>
<div class="example">
<pre class="example">&gt; plot(x, y)
&gt; xfit &lt;- seq(.02, 1.1, .05)
&gt; yfit &lt;- 212.68384222 * xfit/(0.06412146 + xfit)
&gt; lines(spline(xfit, yfit))
</pre></div>

<p>표준 패키지인 <strong>stats</strong>에는 최소제곱법으로 비선형모형을 적합할 수 있는 많은 종류의 함수들이 포함되어 있습니다. 바로 위의
예제에서 우리는 Michaelis-Menten 모형을 적합했습니다. 이 분석은 다음과 같은 방법으로도 실행 가능합니다.
</p>
<div class="example">
<pre class="example">&gt; df &lt;- data.frame(x=x, y=y)
&gt; fit &lt;- nls(y ~ SSmicmen(x, Vm, K), df)
&gt; fit
Nonlinear regression model
  model:  y ~ SSmicmen(x, Vm, K)
   data:  df
          Vm            K
212.68370711   0.06412123
 residual sum-of-squares:  1195.449
&gt; summary(fit)

Formula: y ~ SSmicmen(x, Vm, K)

Parameters:
    Estimate Std. Error t value Pr(&gt;|t|)
Vm 2.127e+02  6.947e+00  30.615 3.24e-11
K  6.412e-02  8.281e-03   7.743 1.57e-05

Residual standard error: 10.93 on 10 degrees of freedom

Correlation of Parameter Estimates:
      Vm
K 0.7651
</pre></div>

<hr>
<a name="Maximum-likelihood"></a>
<a name="Maximum-likelihood-1"></a>
<h4 class="subsection">11.7.2 Maximum likelihood</h4>
<a name="index-Maximum-likelihood"></a>

<p>최우추정(Maximum likelihood)법 역시 비선형모형을 적합하는데 쓰일 수 있으며, 오차항이 정규분포를 따르지 않을 경우에도
사용할 수 있습니다. 이 방법은 로그-우도(log-likelihood) 함수를 최대화시켜주는 모수의 값을 추정치로 찾아주며, 이는 음의
로그-우도(negative log-likelihood)를 최소화시키는 모수의 값을 찾는것과 동일합니다. 이제 Dobson(1990),
pp.108–111 에 나오는 예제를 살펴보도록 하겠습니다. 이 예제는 dose-response 데이터에 로지스틱 모형을 적합하는 것이며
<code>glm()</code>함수를 사용할 수 있습니다. 우선 주어진 데이터는 아래와 같습니다:
</p>
<div class="example">
<pre class="example">&gt; x &lt;- c(1.6907, 1.7242, 1.7552, 1.7842, 1.8113,
         1.8369, 1.8610, 1.8839)
&gt; y &lt;- c( 6, 13, 18, 28, 52, 53, 61, 60)
&gt; n &lt;- c(59, 60, 62, 56, 63, 59, 62, 60)
</pre></div>

<p>다음과 같이 음의 로그-우도 함수를 최소화 합니다:
</p>
<div class="example">
<pre class="example">&gt; fn &lt;- function(p)
   sum( - (y*(p[1]+p[2]*x) - n*log(1+exp(p[1]+p[2]*x))
           + log(choose(n, y)) ))
</pre></div>

<p>이 작업을 수행하기위해 적당한 초기값(starting values)을 선택합니다:
</p>
<div class="example">
<pre class="example">&gt; out &lt;- nlm(fn, p = c(-50,20), hessian = TRUE)
</pre></div>
<a name="index-nlm-2"></a>

<p>모형을 적합시키고나면, <code>out$minimum</code>사용해서 음의 로그-우도(negative log-likelihood) 함수값을,
<code>out$estimate</code>를 사용해서 모수의 최대우도추정치(maximum likelihood estimates/MLE)를 확인할
수 있습니다.추정치의 표준오차(standard error, SE)의 근사치는 아래와 같이 구할 수 있습니다:
</p>
<div class="example">
<pre class="example">&gt; sqrt(diag(solve(out$hessian)))
</pre></div>

<p>마찬가지로, 95% 신뢰구간은 모수의 추정치에 +/-1.96*SE 하여 계산하면 됩니다.
</p>
<hr>
<a name="Some-non_002dstandard-models"></a>
<a name="Some-non_002dstandard-models-1"></a>
<h3 class="section">11.8 Some non-standard models</h3>

<p>이번 장은 특수한 회귀모형 및 데이터 분석방법을 다루기 위해  R에서 이용가능한 기능들에 간단히 소개하면서 마무리하도록 하겠습니다.
</p>
<ul>
<li> <a name="index-Mixed-models"></a>
<strong>혼합모형 (Mixed models)</strong>이란 선형 및 비선형 회귀모형의 회귀계수 중 일부가 랜덤효과(random
effect)인 모형을 의미하는 것으로, 
<a name="index-lme"></a>
<a name="index-nlme"></a>
이러한 혼합모형에 적합하기 위해서는 권장 패키지인 <a href="http://CRAN.R-project.org/package=nlme"><strong>nlme</strong></a>에서 제공하는 <code>lme()</code>와
<code>nlme()</code>를 사용할 수 있으며, 이런 함수들의 등장으로 혼합모형이  좀 더 많이 사용될 수 있게 되었습니다. 

</li><li> <a name="index-Local-approximating-regressions"></a>
<strong>로컬 근사 회귀(Local approximating regressions)</strong>
<a name="index-loess"></a>
<code>loess()</code> 함수는 로컬 가중치를 가정한 회귀(locally weighted regression)를 사용한 일종의
비모수회귀(nonparametric regression)모형을 적합합니다.이러한 회귀모형은 패턴이 깔끔하지 않은(messy) 데이터에서
추세를 찾아내거나, 데이터 크기 줄이기(data reduction)에 사용할 수도 있습니다. 

<p><code>loess()</code> 함수는 projection pursuit regression을 위한 함수인 <code>ppr()</code>과 함께
표준패키지인 <strong>stats</strong>에서 제공됩니다.
<a name="index-loess-1"></a>
</p>
</li><li> <a name="index-Robust-regression"></a>
<strong>로버스트 회귀(Robust regression)</strong>는 데이터에 포함된 이상치(extreme outliers)들의 영향력을
줄여 회귀모형을 적합하는 방법들 중 하나 입니다. 권장패키지인 <strong>MASS</strong>에 포함되어 있는 <code>lqs</code> 
<a name="index-lqs"></a>
함수의 경우, 상당히 안정적인 적합치(fits)를 얻을 수 있는 최신의(state-of-art) 알고리즘들을 사용합니다. 또 이상치의
영향력에 대해서는 다소 덜 안정적이라도, 통계적으로 좀 더 효율적인 방법들이 여러 패키지에서 제공되는데, <strong>MASS</strong> 패키지의
<code>rlm</code>와 같은 함수가 그 중 하나의 예입니다.
<a name="index-rlm"></a>
in package <a href="http://CRAN.R-project.org/package=MASS"><strong>MASS</strong></a>.

</li><li> <a name="index-Additive-models"></a>
<strong>가법 모형(Additive models)</strong>은 설명변수(determining variable)들에 대한 스무드한 가법(즉,
교호작용을 포함하지 않는) 함수(smooth additive functions)를 사용하여 회귀모형식을 세우는 것으로, 보통 하나의
설명변수에 대해 하나의 함수를 사용합니다. <a href="http://CRAN.R-project.org/package=acepack"><strong>acepack</strong></a>에서 제공하는 <code>avas</code> 함수
<a name="index-avas"></a>
<a name="index-ace"></a>
in package <a href="http://CRAN.R-project.org/package=acepack"><strong>acepack</strong></a> and functions <code>bruto</code> and <code>mars</code>
<a name="index-bruto"></a>
<a name="index-mars"></a>
함수 등은 R에서 사용자-기여 패키지(user-contributed packages)를 통해 이 모형을 적합할 수 있다는 것을
보여주는 몇 가지 예 입니다 .이 모형을 조금 더 확장한 것으로 <strong>일반화 가법 모형 (Generalized Additive
Models)</strong>이 있으며, 마찬가지로 사용자-기여 패키지인 <a href="http://CRAN.R-project.org/package=gam"><strong>gam</strong></a>과 <a href="http://CRAN.R-project.org/package=mgcv"><strong>mgcv</strong></a>를 통해 구현가능합니다.

</li><li> <a name="index-Tree_002dbased-models"></a>
<strong>트리 기반 모형 (Tree-based models)</strong>은 (모형을 통한) 예측이나 (모형에 대한) 해석을 위해 하나의 글로벌
선형 모형을 찾는다기 보다는, 데이터를 분할(partition) 합니다. 즉, 설명변수의 임계점 (critical points)에서
데이터를 두 그룹으로 나누는 과정을 반복해서, 궁극적으로는 데이터를 그룹 내(within)에서는 가능한 동질하고(homogeneous),
그룹 간(between)은 가능한 이질적인(heterogeneous) 그룹들로 나누게 됩니다.그런데, 이러한 데이터 분할의 결과로 종종
다른 데이터 분석법으로부터는 찾을 수 없었던 것들을 발견하게 되기도 합니다. 

<p>이 모형 역시 보통의 선형모형(ordinary linear model)의 형태로 표현할 수 있습니다. 모형을 적합을 위해 사용할 수 있는
함수로 <code>tree()</code>가 있습니다.
<a name="index-tree"></a>
또 결과물을 효과적인 시각화를 위해 <code>plot()</code>와 <code>text()</code>와 같은 일반함수(generic function)와
연동시켜 사용하는 것도 가능합니다.
</p>
<p>R에서는  사용자-기여 패키지(user contributed package)인 <a href="http://CRAN.R-project.org/package=rpart"><strong>rpart</strong></a>과
<a href="http://CRAN.R-project.org/package=tree"><strong>tree</strong></a> 등을 사용해서 이러한 트리 모형을 사용하는 것이 가능합니다.
</p>
</li></ul>

<hr>
<a name="Graphics-_0028_adf8_b798_d53d_c2a4_0029"></a>
<a name="Graphical-procedures"></a>
<h2 class="chapter">12 Graphical procedures</h2>

<p>R 환경(environment)에서 가장 중요고도 유용하게 활용되는 부분이 바로 그래픽 기능일 것입니다. R의 그래픽 기능을
사용해서, 다양한 통계 관련 그래프들을 생성할 수 있으며, 또 완전히 새로운 종류의 그래프를 만들어 내는 것도 가능합니다.
</p>
<p>그래픽 기능들은 대화형(interactive)이나 일괄식(batch)으로 사용하는 것 모두 가능하지만,대부분의 경우에는 대화형으로
작업하는 것이 좀 더 쉽고 효과적입니다. 대화형 사용이 좀 더 쉬운 이유는, R이 시작될 때 대화형 그래픽을 출력하는 특별한
<em>그래픽 윈도우(graphics window)</em>를 여는 <em>device driver</em>(장치 드라이버)가 자동으로
초기화되기 때문입니다.  물론 이러한 과정은 자동적으로 실행되지만, UNIX에서는 <code>X11()</code>, 윈도우즈에서는
<code>windows()</code>, 그리고 Mac OS X에서는 <code>quartz()</code> 함수를 사용해서 그래픽 장치(graphic
device)를 시작할 수 있다는 것을 알아두시면 유용할 것 입니다. 
</p>
<p>일단 장치 드라이버가 실행되면, R의 플롯팅(plotting) 명령어들은 다양한 종류의 그래픽 처리 및 새로운 종류의 그래픽 생성을
위해 사용할 수 있습니다.
</p>
<p>플롯팅 명령어들은 다음과 같이 크게 세 그룹으로 나눌 수 있습니다:
</p>
<ul>
<li> <strong>하이-레벨 (High-level)</strong> 플롯팅 함수들은 그래픽 디바이스 상에 축(axes), 레이블(labels),
제목(titles) 등으로 여러 요소로 구성된 새로운 플롯을 그려줍니다.
</li><li> 들을 추가하여 좀 더 많은 정보들을 표현할 수 있도록 하는데  사용 됩니다.
</li><li> <strong>대화형 (Interactive)</strong> 그래픽 함수들은 마우스와 같은 포인팅 장치(pointing device)를 이용하여 이미
생성된 플롯에 정보를 추가하거나 또는 지우는 작업을 지원합니다.
</li></ul>

<p>또한, R은 사용자가 원하는대로 플롯을 수정 및 변경하는 데 사용할 수 있도록 여러 종류의 <em>그래픽 파라미터
(graphical parameters)</em>들을 제공합니다.
</p>
<p>이 매뉴얼에서는 일단 &lsquo;기본(base)&rsquo; 그래픽이라고 알려진 것들에 대해서만 다루겠습니다.  이러한 기본 그래픽과는 별도로
<strong>grid</strong> 패키지를 통해 사용할 수 있는 별도의 그래픽 서브-시스템이 존재하는데, 좀 더 강력한 그래픽 기능들을 제공하지만,
사용하기가 쉽지는 않습니다. 또, <strong>grid</strong>를 기반해서 제작된 <a href="http://CRAN.R-project.org/package=lattice"><strong>lattice</strong></a>라는 권장패키지도 있는데, 이는
S에서 <em>Trellis</em>(트렐리스)라는 시스템이 제공하는 다중패널 플롯(multi-panel plots)과 거의 비슷한
기능들을 사용할 수 있도록 지원합니다.
</p>

<hr>
<a name="High_002dlevel-plotting-commands"></a>
<a name="High_002dlevel-plotting-commands-1"></a>
<h3 class="section">12.1 High-level plotting commands</h3>

<p>하이-레벨 플롯팅 함수들은 함수에 몇 개의 인자만 입력해도 하나의 완전한(complete) 플롯이 생성될 수 있도록 디자인
되었습니다. 따라서, 별도의 설정없이 자동적으로 적절한 위치에 축, 레이블, 그리고 제목들이 놓이게 되며 (물론 설정을 통해 바꾸는 것도
가능합니다). 하이레벨 플롯팅 명령어들은 언제나 새 플롯을 그리기 시작할 때, 필요하다면, 현재 출력 중인 플롯을 지워 버립니다.
</p>

<hr>
<a name="The-plot_0028_0029-function"></a>
<a name="The-plot_0028_0029-function-1"></a>
<h4 class="subsection">12.1.1 The <code>plot()</code> function</h4>
<a name="index-plot-1"></a>

<p>R에서 가장 빈번하게 사용되는 플롯팅 함수는 <code>plot()</code> 입니다. 이는 <em>일반함수(generic
function)</em> 중 하나 입니다: 생성되는 플롯의 종류는 (플롯의) 타입(type) 또는 함수의 첫번째 인자의
<em>클래스(class)</em>에 의해서 결정됩니다.
</p>
<dl compact="compact">
<dt><code>plot(<var>x</var>, <var>y</var>)</code></dt>
<dt><code>plot(<var>xy</var>)</code></dt>
<dd><p>만약, <var>x</var>와 <var>y</var> 두 개 모두 벡터이면, <code>plot(<var>x</var>, <var>y</var>)</code>은 <var>x</var>와
<var>y</var>의 관계를 살펴볼 수 있는 산점도(scatter plot)를 생성합니다. 하나의 인자만을 입력 받지만, 두 번째 표현 역시
같은 산점도를 출력합니다. 하지만 이 경우, 인자는 <var>x</var>와 <var>y</var> 두개의 컴포넌트로 구성된 리스트이거나, 또는 2 열의
행렬 형식이어야 합니다.
</p>
</dd>
<dt><code>plot(<var>x</var>)</code></dt>
<dd><p>만약 <var>x</var>가 시계열(time-series)이면, 이 함수는 시계열 플롯(time-series plot)을 생성합니다. 또, 만약
<var>x</var>가 수치형 벡터인 경우에는, <var>x</var>의 인덱스를 <code>x</code>로 <var>x</var>의 값을 <code>y</code>로 하는 플롯을
생성합니다. 마지막으로, <var>x</var>가 복소수(complex) 벡터이면, 이 함수는 실수부분을 <code>x</code>로 허수부분을
<code>y</code>로 하는 플롯을 생성합니다.
</p>
</dd>
<dt><code>plot(<var>f</var>)</code></dt>
<dt><code>plot(<var>f</var>, <var>y</var>)</code></dt>
<dd><p>여기서 <var>f</var>는 요인을, <var>y</var>는 수치형 벡터를 의미합니다. 첫번째 표현식은 벡터 <var>f</var>에 대한 막대 그래프
(bar plot)를 생성하고, 두번째 표현식은 <var>f</var>의 각 수준 별로 <var>y</var>의 박스플롯(boxplot)을 생성합니다.
</p>
</dd>
<dt><code>plot(<var>df</var>)</code></dt>
<dt><code>plot(~ <var>expr</var>)</code></dt>
<dt><code>plot(<var>y</var> ~ <var>expr</var>)</code></dt>
<dd><p>여기에서 <var>df</var>는 데이터 프레임, <var>y</var>는 임의의 객체, <var>expr</var>는, <code>a+b+c</code>와 같이,
<code>+</code>로 구분된 여러 개체 이름의 리스트를 의미합니다. 첫번째 표현식은 데이터 프레임에 포함된 모든 변수들을 대상으로 각 변수의
분포를 보여주고, 두번째 표현식은 <code>expr</code>내에 사용된 변수들만을 대상으로 분포를 보여줍니다. 마지막 세번째 표현식은
<var>expr</var>에 사용된 모든 변수 각각에 대한 <var>y</var>의 분포를 보여 줍니다.
</p></dd>
</dl>

<hr>
<a name="Displaying-multivariate-data"></a>
<a name="Displaying-multivariate-data-1"></a>
<h4 class="subsection">12.1.2 Displaying multivariate data</h4>

<p>R은 다변량 데이터를 시각화하기 위한 두 가지 매우 유용한 함수들을 제공합니다. 만약, <code>X</code>가 수치형 행렬 혹은 수치형
데이터 프레임이면, 아래의 명령문은 
</p>
<div class="example">
<pre class="example">&gt; pairs(X)
</pre></div>
<a name="index-pairs"></a>

<p><code>X</code>의 열들로 구성된 변수들로 그린 페어와이즈 산점도(pairwise scatterplot) 행렬을 그립니다.이것은
<code>X</code>의 각각의 열(<code>행</code>)이 다른 모든 열들(<code>열</code>)에 대하여 플롯되어,총 <em>n(n-1)</em>개의
플롯이 생성되고, 행과 열이 모두 같은 플롯 스케일(scales)을 갖는 하나의 행렬처럼 나열됩니다. 
</p>
<p>세 개 혹은 네 개의 변수만을 사용할 경우에는 <em>coplot</em>을 사용하는 것이 보다 효과적일 수 있습니다. <code>a</code>와
<code>b</code>는 수치형 벡터이고, <code>c</code>는 수치형 벡터 혹은 요인(factor)인 경우 (세 벡터는 모두 길이가 같아야
합니다.),다음의 명령문을 사용하면, 
</p>
<div class="example">
<pre class="example">&gt; coplot(a ~ b | c)
</pre></div>
<a name="index-coplot"></a>

<p><code>c</code>가 요인인 경우에는, 이 함수는 주어진 <code>c</code>의 각 수준에서 <code>a</code>(<code>y</code>)에 대한
<code>b</code>(<code>x</code>)의 산점도를 그립니다. 또, <code>c</code>가 수치형 벡터인 경우에는, <code>c</code>를 몇 개의
<em>조건부 구간 (conditioning intervals)</em>로 나누어 각 구간에서 그 구간에 해당하는 <code>c</code>값을 갖는
데이터를 대상으로, <code>a</code>(<code>y</code>)에 대한 <code>b</code>(<code>x</code>)의 산점도를 그립니다. 이 조건부 구간의
개수와 위치는 <code>coplot()</code> 함수의 <code>given.values=</code> 인자를 설정하여 조정할 수 있습니다. 함수
<code>co.intervals()</code>와 병행하여 사용하면 구간선택시 매우 유용합니다&mdash; 이 경우,
<code>co.intervals()</code> 함수는 구간을 선택하는데 도움을 줄 수 있습니다.   또한, <em>주어진</em> 두 개의 변수에
대해 이 플롯을 그리고 싶다면, 아래와 같이 명령문을 사용하시면 됩니다. 
</p>
<div class="example">
<pre class="example">&gt; coplot(a ~ b | c + d)
</pre></div>

<p>이 명령문은 <code>c</code>와 <code>d</code>의 결합 조건부 구간(joint conditioning interval)을 생성하여, 각
구간별로 <code>a</code>(<code>y</code>)에 대한 <code>b</code>(<code>x</code>)의 산점도를 그립니다.
</p>
<p><code>coplot()</code>과 <code>pairs()</code> 함수는 모두 <code>panel=</code>이라는 인자를 가지는데,이 인자를
설정함으로써 각각의 패널에 어떤 종류의 플롯을 그릴것인지 선택할 수 있습니다. 디폴트(default)로는 산점도를 생성하는데 사용되는
<code>points()</code>라는 설정되어 있지만, <code>x</code>와 <code>y</code> 두 벡터를 사용하는 다른 종류의 로우-레벨 그래픽
함수를 <code>panel=</code>에 입력하여 원하는 형태의 플롯으로 바꿀 수 있습니다.<code>coplot()</code>에 사용될 수 있는 유용한
패널함수 중 하나로 <code>panel.smooth()</code>가 있습니다.
</p>
<hr>
<a name="Display-graphics"></a>
<a name="Display-graphics-1"></a>
<h4 class="subsection">12.1.3 Display graphics</h4>

<p>다른 하이-레벨 그래픽 함수들은 다른 종류의 플롯을 생성하는 데 사용됩니다.사용가능한 함수 중 몇 가지는 다음과 같습니다.
</p>
<dl compact="compact">
<dt><code>qqnorm(x)</code></dt>
<dt><code>qqline(x)</code></dt>
<dt><code>qqplot(x, y)</code></dt>
<dd><a name="index-qqnorm-1"></a>
<a name="index-qqline-1"></a>
<a name="index-qqplot"></a>
<p>다음은 분포 비교(Distribution-comparison)를 위한 플롯을 생성하는 함수들에 대해 다루겠습니다.첫번째 표현식은 수치형
벡터 <code>x</code>(<code>y</code>)를 정규 순서통계량의 기대값(expected Normal order score(<code>x</code>)에
대해 플롯한 정규스코어플롯(Normal scores plot)을 생성합니다. (즉, 이 플롯의 <code>x</code> 값으로는 정규 분포를
따르는 순서통계량이 (플롯 생성시 Theoretical Quantiles로 레이블 됨), <code>y</code> 값으로는 실제 데이터의 분포를
따르는 순서통계량이 (플롯 생성시 Sample Quantiles로 레이블 됨)이 사용됩니다. 두번째 표현식은 첫번째 표현식을 통해 얻은
플롯에 데이터와 정규분포의 4분위수(quartiles)들를 지나는 직선을 더해줍니다. 세번째 표현식은 <code>x</code>의 분위수(퀀타일,
quantiles)에 대해 <code>y</code>의 분위수(quantiles)를 플롯하여, 두 분포를 비교할 수 있도록 합니다. 
</p>
</dd>
<dt><code>hist(x)</code></dt>
<dt><code>hist(x, nclass=<var>n</var>)</code></dt>
<dt><code>hist(x, breaks=<var>b</var>, &hellip;)</code></dt>
<dd><a name="index-hist-1"></a>
<p>수치형 벡터 <code>x</code>에 대한 히스토그램을 생성합니다. 플롯하기 위해 필요한 클래스의 개수는 알아서 적절하게 선택되지만, 구간의
개수를 지정하고 싶다면 <code>nclass=</code> 인자(argument)를 입력하시면 됩니다. 또한, 브레이크 포인트/각 클래스의
끝점(breakpoint)의 개수를 지정하고 싶으면 <code>breaks=</code> 인자(argument)를 정확히 원하는 값으로 지정하시면
됩니다.만약, <code>probability=TRUE</code> 인자가 입력되면, 히스토그램의 막대(bars)들은 전체 도수(counts)대신
막대의 넓이(bin width)로 나누어진 상대적 빈도(relative frequencies)가 됩니다.
</p>
</dd>
<dt><code>dotchart(x, &hellip;)</code></dt>
<dd><a name="index-dotchart"></a>
<p><code>x</code>에대한 점도표(다트 챠트, dotchart)를 그립니다. 점도표에서는 <em>y</em>-축은 데이터 <code>x</code>에
대응되는 데이터의 레이블이, <em>x</em>-축에는 데이터의 값이 표시됩니다.이 플롯으로 정해진 범위의 값을 갖는 데이터들을 선택적으로
보여주는 작업을 쉽게 할 수 있습니다 .
</p>
</dd>
<dt><code>image(x, y, z, &hellip;)</code></dt>
<dt><code>contour(x, y, z, &hellip;)</code></dt>
<dt><code>persp(x, y, z, &hellip;)</code></dt>
<dd><a name="index-image"></a>
<a name="index-contour"></a>
<a name="index-persp"></a>
<p>3개의 변수로 플롯을 그리는 방법들입니다. <code>image</code> 플롯은 서로 다른 <code>z</code> 값을 나타내기 위해 여러 색을
사용하며, 여러 개 직사각형들을 포함하는 하나의 그리드(grid)를 그립니다. 또한, <code>contour</code> 플롯은 <code>z</code>의
값을 표현하기 위해 여러 개의 등고선 (contour lines)을 사용하며, <code>persp</code> 플롯은 3차원 표면도(surface
plot)을 그립니다.
</p></dd>
</dl>

<hr>
<a name="Arguments-to-high_002dlevel-plotting-functions"></a>
<a name="Arguments-to-high_002dlevel-plotting-functions-1"></a>
<h4 class="subsection">12.1.4 Arguments to high-level plotting functions</h4>

<p>하이-레벨 그래픽 함수에 자주 사용되는 인자들에는 다음과 같은 것들이 있습니다.
</p>
<dl compact="compact">
<dt><code>add=TRUE</code></dt>
<dd><p>이 함수를 로우-레벨 그래픽 함수처럼 사용하여, 현재의 플롯 위에 새로운 플롯을 겹쳐 그리도록 합니다 (모든 함수에 적용 가능한  것은
아닙니다).
</p>
</dd>
<dt><code>axes=FALSE</code></dt>
<dd><p>축이 생성되지 않도록 해주는 인자로, 사용자가 직접 <code>axis()</code> 함수로 축을 지정할 때 유용하게 사용할 수 있습니다.디폴트는
<code>axes=TRUE</code>이며, 따라서 하이-레벨 플롯은 축을 포함합니다.
</p>
</dd>
<dt><code>log=&quot;x&quot;</code></dt>
<dt><code>log=&quot;y&quot;</code></dt>
<dt><code>log=&quot;xy&quot;</code></dt>
<dd><p><em>x</em>, <em>y</em> 또는 두 축 모두를 <em>log</em>(로그)변환(logarithmic) 합니다.인자는 많은 종류의
플롤세 사용할 수 있지만, 모든 함수에 전부 적용될 수 있는 것은 아닙니다.
</p>
</dd>
<dt><code>type=</code></dt>
<dd><p><code>type=</code> 인자는 생성될 플롯의 종류를 지정하는 것으로, 아래와 같이 사용할 수 있습니다:
</p>
<dl compact="compact">
<dt><code>type=&quot;p&quot;</code></dt>
<dd><p>(디폴트로 지정되어 있으며,) 개별 포인트(점)들로 플롯합니다.
</p></dd>
<dt><code>type=&quot;l&quot;</code></dt>
<dd><p>선으로 플롯합니다. 
</p></dd>
<dt><code>type=&quot;b&quot;</code></dt>
<dd><p>포인트와 이들을 연결한 선 <em>두가지 모두</em>를 플롯합니다.
</p></dd>
<dt><code>type=&quot;o&quot;</code></dt>
<dd><p>포인트들과 이들을 지나는 선을 플롯합니다.
</p></dd>
<dt><code>type=&quot;h&quot;</code></dt>
<dd><p><em>0</em>에서부터 시작해서 각 포인트의 높이까지 세로로 이어진 수직선들을
플롯합니다. (<em>하이-덴서티(high-density)</em>플롯이라고도 하며, 히스토그램&quot;처럼&quot; 생겼으나, 선으로 그려진
플롯입니다.) 
</p></dd>
<dt><code>type=&quot;s&quot;</code></dt>
<dt><code>type=&quot;S&quot;</code></dt>
<dd><p>스텝(계단)함수 (step-function)를 플롯합니다. 첫번째 표현식에서는 점핑포인트에서 수직선의 윗부분이, 두번째 표현식에서는
점핑포인트에서 수직선의 아랫부분이 해당 데이터 포이트의 값(<code>y</code>)에 대응됩니다.
</p></dd>
<dt><code>type=&quot;n&quot;</code></dt>
<dd><p>이 인자를 선택하면 화면에 아무것도 플롯되지 않습니다. 하지만, (디폴트에 의해) 축은 여전히 그려지고, 그에 따라 입력된 데이터에 대한
좌표시스템 역시 설정되어집니다. 이러한 기능은 로우-레벨 그래픽 함수를 이용하기 전 이를 적용할 틀을 만드는 데 사용하면 좋을 것입니다.
</p></dd>
</dl>

</dd>
<dt><code>xlab=<var>string</var></code></dt>
<dt><code>ylab=<var>string</var></code></dt>
<dd><p><em>x</em>축과 <em>y</em>축에 대한 레이블을 표기합니다.이 인자들을 입력하면, 하이-레벨 플롯팅 함수에 입력했던 객체들의 이름이
축 이름으로 레이블되는 디폴트 설정을 바꿀 수 있습니다. 
</p>
</dd>
<dt><code>main=<var>string</var></code></dt>
<dd><p>플롯의 윗 부분에 (플롯에 사용된 것 보다) 큰 폰트로 주제목(title)을 표시합니다.
</p>
</dd>
<dt><code>sub=<var>string</var></code></dt>
<dd><p><em>x</em>-축 바로 밑에, 주제목보다는 약간 작은 폰트로 부제목을 표시합니다.
</p></dd>
</dl>

<hr>
<a name="Low_002dlevel-plotting-commands"></a>
<a name="Low_002dlevel-plotting-commands-1"></a>
<h3 class="section">12.2 Low-level plotting commands</h3>

<p>하이레벨(high-level)플롯팅 함수를 사용하면, 때때로 내가 원하는 것을 정확히 반영한 플롯을 그릴 수 없는 경우가 생깁니다.이럴
때, 로우-레벨(low-level) 플롯팅 함수들을 이용하면 현재 플롯에 포인트, 선 또는 텍스트 같은 부가적인 정보를 더할 수
있습니다.
</p>
<p>유용하게 사용할 수 있는 로우-레벨 플롯팅 함수들에는 다음과 같은 것들 같습니다. 
</p>
<dl compact="compact">
<dt><code>points(x, y)</code></dt>
<dt><code>lines(x, y)</code></dt>
<dd><a name="index-points"></a>
<a name="index-lines"></a>
<p>현재의 플롯에 포인트나 선을 추가합니다. 위 함수들은 <code>plot()</code>함수에서 <code>type=</code> 인자를 지정하는 것과 같은
작업을 수행합니다. (이 인자의 디폴트값인 <code>&quot;p&quot;</code>는 <code>points()</code>함수와, 이 인자의 <code>&quot;l&quot;</code> 값은
<code>lines()</code>와 동일합니다.)
</p>
</dd>
<dt><code>text(x, y, labels, &hellip;)</code></dt>
<dd><a name="index-text"></a>
<p><code>x,y</code>에 해당하는 점의 위치에 텍스트를 추가합니다. 보통 <code>레이블(labels)</code>은 하나의 정수나 문자형 벡터이며,
<code>i 번째 데이터의 레이블/labels[i]</code>은 <code>(x[i], y[i])</code>의 위치에 표시됩니다. (별도의 레이블이
지정되지 않더라도) 디폴트로 <code>1:length(x)</code> 겂이 사용됩니다.
</p>
<p><strong>주의</strong>: 이 함수는 다음과 같은 순서로 사용되어야 합니다.
</p>
<div class="example">
<pre class="example">&gt; plot(x, y, type=&quot;n&quot;); text(x, y, names)
</pre></div>

<p>그래픽 파라미터(parameter)인 <code>type=&quot;n&quot;</code>은 포인트를 보이지 않게 하지만 좌표축(axes)은 이미 설정되어
있으며, <code>text()</code>함수는 <code>names</code>에 문자형 벡터를 입력된 경우, 원래 포인트의 위치에 (입력된 벡터에
저장되어 있는) 문자값을 출력합니다. 
</p>
</dd>
<dt><code>abline(a, b)</code></dt>
<dt><code>abline(h=<var>y</var>)</code></dt>
<dt><code>abline(v=<var>x</var>)</code></dt>
<dt><code>abline(<var>lm.obj</var>)</code></dt>
<dd><a name="index-abline"></a>
<p>기울기  <code>b</code>이고 절편이 <code>a</code>인 직선을 현재의 플롯에 첨가합니다. <code>h=<var>y</var></code>는 높이가
<em>y</em>인 플롯 전체를 가로지르는 수평선(horizontal line)을 그리기 위해, 마찬가지로 <code>v=<var>x</var></code>은
(x축에서) <em>x</em> 좌표값을 갖는 수직선(vertical line)을 그립니다. 또, <var>lm.obj</var> 는 (모형적함으로
얻어진) 길이 2인 <code>회귀계수(coefficients)</code>들을 성분으로 갖는 리스트이며, 이 경우에는 이 두 숫자는 순서대로
(플롯에 첨가될 선의) 절편과 기울기로 사용될 것입니다.
</p>
</dd>
<dt><code>polygon(x, y, &hellip;)</code></dt>
<dd><a name="index-polygon"></a>
<p>(<code>x</code>, <code>y</code>)의 형태로 입력된 꼭짓점(vertices)들을 순서대로 연결해서 다각형(polygon)을
그립니다. (옵션으로) 그려진 다각형의 내부에 해치 라인(hatch line)을 사용해서 음영을 주거나,사용중인 그래픽 장치가 지원가능할
경우, 색으로 내부를 채우는 것도 가능합니다. 
</p>
</dd>
<dt><code>legend(x, y, legend, &hellip;)</code></dt>
<dd><a name="index-legend"></a>
<p>지정된 위치에 현재 플롯의 범례(legend)를 첨가합니다. <code>범례(legend)</code>에는 문자형 벡터로된 (해당 플롯의) 레이블과
함께 플롯에 사용됐던 문자, 선의 종류, 색 등을 함께 사용하는 것이 가능합니다. 이렇게 레이블 이외의 다른 요소들을 사용하기 위해서는,
<var>v</var> 이외의 최소한 한개 이상의 인자가 입력되어야 하며, (이 인자는 <var>v</var>와 같은 길이를 가진) 이미 플롯에 사용된
것과 같은 값들을 가지고 있어야 합니다. 다음과 같이 말이지요:
</p>
<dl compact="compact">
<dt><code>legend( , fill=<var>v</var>)</code></dt>
<dd><p>(다각형의) 영역을 채울게 될 색상들
</p></dd>
<dt><code>legend( , col=<var>v</var>)</code></dt>
<dd><p>포인트나 선에 사용될 색상들
</p></dd>
<dt><code>legend( , lty=<var>v</var>)</code></dt>
<dd><p>선의 종류
</p></dd>
<dt><code>legend( , lwd=<var>v</var>)</code></dt>
<dd><p>선의 굵기
</p></dd>
<dt><code>legend( , pch=<var>v</var>)</code></dt>
<dd><p>(문자형 벡터로) 입력된 문자들을 출력
</p></dd>
</dl>

</dd>
<dt><code>title(main, sub)</code></dt>
<dd><a name="index-title"></a>
<p>현재 플롯의 윗부분에 큰 글시로 주요(main) 제목을 첨가하고 (선택에 의해) 좀 더 작은 크기의 클씨로 부(sub)제목을 아랫 부분에
표시합니다.
</p>
</dd>
<dt><code>axis(side, &hellip;)</code></dt>
<dd><a name="index-axis"></a>
<p>현재 플롯에 첫번째 인수에 (<code>side</code>) 지정된 방향에 축(axis)을 첨가합니다. (이 <code>side</code>는
<em>1</em>부터 <em>4</em>까지의 숫자로 나타나며, 바닥(bottom)에서 시작해 반시계 방향으로 해당 사면을 의미합니다.) 이
함수에 다른 인수들을 지정하여 축의 위치를 플롯의 내부나 옆으로 바꾸거나, 틱마크와 레이블의 위치를 조정할 수도 있습니다. 또 사용자
정의대로 축을 생성하기위해, <code>plot()</code> 함수에서 <code>axes=FALSE</code>로 입력하고 이 함수로 새축을 생성할 수도
있을 것입니다.
</p></dd>
</dl>

<p>로우-레벨(Low-level) 플롯팅 함수들은 대체로 새로운 플롯의 구성요소를 어디에 배치할지 위치를 (<em>x</em>와 <em>y</em>
좌표로) 지정해주어야 합니다. 이러한 위치는 이미 사용된 하이-레벨 그래픽 명령어에의해 생성된 <em>사용자 좌표 (user
coordinates)</em>에 의해 표현되어야하며, 이러한 좌표 시스템은 주어진 데이터에 의해 결정되는 것입니다.
</p>
<p><code>x</code>와 <code>y</code> 인자가 필요한 경우, <code>x</code>와 <code>y</code>라는 이름을 가진 두 요소를 묶은 하나의 리스트를
하나의 인자로 입력하는 것 역시 가능합니다. 마찬가지로 2열의 행렬을 사용하는는 것도 가능합니다. 이렇게 입력할 위치를 지정하기 위해서,
<code>locator()</code>(아래 참조) 등의 함수를 사용하여 대화형으로(interactively) 찾은 플롯 내의 위치정보를
사용할수도 있을 것입니다.
</p>

<hr>
<a name="Mathematical-annotation"></a>
<a name="Mathematical-annotation-1"></a>
<h4 class="subsection">12.2.1 Mathematical annotation</h4>

<p>경우에 따라, 수학적 기호(symbols)나 공식(formulae)을 플롯에 첨가하는 것이 필요할 것입니다. R에서는 이러한 표현을
위해, 개별 문자열에 <code>text</code>, <code>mtext</code>, <code>axis</code>, 또는 <code>title</code> 등의 개별
함수를 사용하기 보다는 하나의 <em>expression</em>을 사용합니다. 예를 들면, 다음의 코드는 이항분포함수(binomial
probability function)의 공식을 표현한 것입니다:
</p>
<div class="example">
<pre class="example">&gt; text(x, y, expression(paste(bgroup(&quot;(&quot;, atop(n, x), &quot;)&quot;), p^x, q^{n-x})))
</pre></div>

<p>사용가능한 모든 기능에 대한 전체 리스트를 포함해, 더 많은 정보는 다음과 같은 R 명령문을 통해 확인할 수 있습니다:
</p>
<div class="example">
<pre class="example">&gt; help(plotmath)
&gt; example(plotmath)
&gt; demo(plotmath)
</pre></div>

<hr>
<a name="Hershey-vector-fonts"></a>
<a name="Hershey-vector-fonts-1"></a>
<h4 class="subsection">12.2.2 Hershey vector fonts</h4>

<p><code>text</code>와 <code>contour</code> 함수를 사용할 때, 텍스트를 편집하기위해 허쉬벡터폰트(Hershey vector
fonts)를 사용할 수 있습니다. 허쉬폰트를 사용하는 데는 다음과 같은 세가지 정도의 이유가 있습니다:
</p><ul>
<li> 허쉬폰트는, 특히 컴퓨터 스크린 상에서, 텍스트를 회전시키거나 작은 텍스트를 사용할 때 더 나은 결과물을 보여줍니다.
</li><li> 또한 허쉬폰트는 기본폰트에서 제공하지 않는 특수한 몇몇 기호들(symbols)을 제공합니다. 조디악 기호(zodiac sign),
지도용(cartographic)심볼, 그리고 천문학용(astronomical)심볼 등이 그러한 예 입니다.
</li><li> 허쉬폰트는 키릴(Cyrillic)과 일본어(가나(Kana)와 간지(Kanji)문자 포함) 문자들을 제공합니다.
</li></ul>

<p>허쉬문자표들의 리스트를 포함한, 좀 더 많은 정보는 R에서 다음과 같은 명령문을 사용해서 확인할 수 있습니다:
</p>
<div class="example">
<pre class="example">&gt; help(Hershey)
&gt; demo(Hershey)
&gt; help(Japanese)
&gt; demo(Japanese)
</pre></div>

<hr>
<a name="Interacting-with-graphics"></a>
<a name="Interacting-with-graphics-1"></a>
<h3 class="section">12.3 Interacting with graphics</h3>

<p>R에서는 마우스를 사용하여 플롯에 새로운 정보를 추가하거나 제거하는 작업을 할 수 있습니다. 이런 함수들 중 가장 간단한 것으로
<code>locator()</code> 함수가 있습니다:
</p>
<dl compact="compact">
<dt><code>locator(n, type)</code></dt>
<dd><a name="index-locator"></a>
<p>현재 플롯에서 사용자가 마우스 왼쪽 버튼을 사용하여 위치를 선택할 때까지 기다립니다. 이러한 대기 상태는, 함수는 입력된
<code>n</code>개(디폴트는 512)개의 점들을 모두 선택하고, 다음 번 마우스 버튼을 누를 때까지 계속 됩니다. <code>type</code>
인자는 선택된 포인들을 현재 플롯상에 어떻게 나타날지 결정해주는 것으로, 하이-레벨 (high-level)그래픽 함수처럼 사용됩니다;
디폴트로는 아무것도 표시되지 않도록 지정되어 있습니다. <code>locator()</code>는 선택된 포인트들의 위치는 <code>x</code>와
<code>y</code> 두 개의 요소로 구성된 하나의 리스트로 출력합니다.
</p></dd>
</dl>

<p>하지만 <code>locator()</code> 함수는 인수의 입력없이 사용되는 경우가 더 많습니다. 이 함수는 범례(legends)나
레이블(labels) 같은 그래픽 요소들을 배치할 때, 이러한 요소들이 해당 그래픽 내에서 정확하게 어디에 위치하는 것이 좋을지 결정하기
어려운 경우, 대화형(interactively)으로 위치를 찾을 수 있도록 해주므로 매우 유용합니다. 예를 들면,
이상점(outlier)과 같이 특별한 데이터 포인트에 대한 정보를 표기하기위해 다음과 같은 명령문을 사용할 수 있습니다:
</p>
<div class="example">
<pre class="example">&gt; text(locator(1), &quot;Outlier&quot;, adj=0)
</pre></div>

<p>(<code>locator()</code> 함수는 현재 디바이스가 postscript와 같이 대화형 선택(interactive pointing)
기능을 제공하지 않는 경우에는 실행되지 않습니다.)
</p>
<dl compact="compact">
<dt><code>identify(x, y, labels)</code></dt>
<dd><a name="index-identify"></a>
<p><code>x</code>와 <code>y</code> 정보가 입력된 포인트들을 대상으로, 이 중 특정 포인트들 (마우스의 왼쪽 버튼 클릭으로 선택) 근처에
해당 포인트에 대응하는 <code>레이블(labels)</code> 값을 표기하여 선택된 포인트들을 구분합니다.(<code>labels</code>인자가 따로
입력되지 않은 경우는, 해당 포인트의 인덱스를 출력합니다). (포인트의 선택 후) 버튼을 한 번 더 누르면 선택된 포인트들의 인덱스가
출력됩니다.
</p></dd>
</dl>

<p>때때로 우리는 포인트 위치를 미리 지정하는 대신, 해당 플롯 상에서 포인트를 직접 선택하고 싶은 경우가 있습니다. 예를 들면, 그래픽
디스플레이 상에서 관심있는 몇 개의 관측치만 선택해서, 선택된 관측치들만 따로 처리하고 싶은 경우가 있습니다. 이 경우, 두 개의 숫치형
벡터인 <code>x</code>와 <code>y</code>로 표현된 <em>(x, y)</em> 좌표쌍이 입력된 상태에서, identify() 함수는 다음과
같이 사용할 수 있습니다:
</p>
<div class="example">
<pre class="example">&gt; plot(x, y)
&gt; identify(x, y)
</pre></div>

<p><code>identify()</code> 함수는 그 자체로 플롯을 그리지는 않지만, 사용자들이 마우스 포인터로 자유롭게 움직이다 왼쪽 버튼
클릭으로 원하는 포인트(또는 그 포인트의 근처)를 선택할 수 있도록 해줍니다. 마우스 포인터 근처에 데이터 포인터가 위치한 경우, 해당
포인트의 근처에 인덱스가 표시될 것 입니다. (이 인덱스는, 해당 포인트의 <code>x</code> 또는 <code>y</code> 벡터에서의 위치를
의미합니다). 선택된 포인트를 표기하는 또 다른 방법으로는, <code>identify()</code> 함수에 <code>labels</code> 인자를
사용해서, (해당 케이스의 이름과 같은) 좀 더 유용한(informative) 표현을 사용할 수 있도록하거나,  <code>plot =
FALSE</code> 인자를 사용하면 아무것도 표기하지않도록 지정할 수도 있습니다. (포인트를 선택하는) 프로세스가 끝나고 나면(위 참조),
<code>identify()</code>는 선택된 포인트들의 인덱스를 출력합니다; 이 선택된 포인트들의 인덱스를 사용하면, 원래의 <code>x</code>
와 <code>y</code> 벡터 형태로 위치를 확인하는 것도 가능합니다.
</p>
<hr>
<a name="Using-graphics-parameters"></a>
<a name="Using-graphics-parameters-1"></a>
<h3 class="section">12.4 Using graphics parameters</h3>

<p>그래픽을 생성할 때, 특히 프리젠테이션이나 출판을 위한 목적이라면, R 제공하는 디폴트만으로는 항상 원하는 형태의 플롯을 얻을 수
없을지도 모릅니다. 하지만, 그래픽 파라미터(graphics parameters)를 이용하면 거의 모든 그래프의 구성요소를 사용자가
원하는대로 바꿀 수 있습니다. R은 선의 형태, 색, 그림의 배치, 그리고 텍스트 정의 등에 이르기까지 굉장히 다양한 작업을 수행할
수 있는 그래픽 파라미터들을 제공합니다. 또 , 모든 그래픽 파라미터는 이름(e.g. &lsquo;<code>col</code>&rsquo;의 경우, 사용할 색을
결정하는 파라미터입니다)과 값(value, &lsquo;<code>col</code>&rsquo;의 경우, 숫자로 사용할 색을 지정합니다)의 두가지 요소로 구성됩니다.
</p>
<p>현재 사용중인(active) 디바이스마다 사용할 그래픽 파라미터(parameters)의 리스트를 따로 정의하는 것이 가능하며, 각 디바스
별로 서로 다른 디폴트 파라미터들이 초기화됩니다. 그래픽 파라미터를 사용하는 방법은 크게 두 가지로 나눌 수 있습니다: 하나는, 보다
&quot;영구적(permanently)&quot;인 방법으로 현재 디바이스에서 사용할게 될 모든 그래픽 함수들에 영향을 미치게 되며, 좀 더
&quot;일시적(temporarily)&quot;인 방법은 사용하게 될 오직 하나의 그래픽 함수에만 영향을 줍니다.
</p>

<hr>
<a name="The-par_0028_0029-function"></a>
<a name="yeonggujeog_0028permanent_0029-byeonhwaneul-weonhal-ddae_003a-par_0028_0029-hamsu"></a>
<h4 class="subsection">12.4.1 영구적(permanent) 변환을 원할 때: <code>par()</code> 함수</h4>
<a name="index-par"></a>
<a name="index-Graphics-parameters"></a>

<p>par()함수는 현재의 그래픽 디바이스에서 사용할 그래픽 파라미터들을 지정하고 그 값을 바꾸는데 사용합니다.
</p>
<dl compact="compact">
<dt><code>par()</code></dt>
<dd><p>아무런 인수를 입력하지 않고 사용하면, 현재 디바이스에서 사용되고 있는 모든 그래픽 파라미터의 이름과 해당 파라미터들이 가진
값(values)들이 출력됩니다.
</p></dd>
<dt><code>par(c(&quot;col&quot;, &quot;lty&quot;))</code></dt>
<dd><p>(인수의 이름들을 포함한) 문자 벡터가 인수로 사용되면, 오직 지정된 그래픽 파라미터들에 대해서만 사용 중인 값(values)이
(리스트의 형태로) 출력됩니다.
</p></dd>
<dt><code>par(col=4, lty=2)</code></dt>
<dd><p>그래픽 파라미터와 해당 파라미터의 값들을 따로 인수(하나의 인수도 가능)로 지정하면, 지정된 값이 리스트로 출력됩니다.
</p></dd>
</dl>

<p>par()함수를 사용해서 그래픽 파라미터를 지정하면 해당 파라미터와 그 값은 “영구적”으로 바뀝니다. 즉 미래에 해당 그래픽 함수를
(현재 디바이스에서) 사용하면 새로 지정된 값이 반영되어 출력되는 것 입니다. 따라서 이 방법을 사용해서 그래픽 파라미터를 지정하는 것은
일종의 “디폴트” 값을 지정하는 것과 같다고 생각할 수 있을 겁니다. 즉, 다른 값이 다시 지정되지 않는 한, 모든 그래픽 함수가 이
지정값에 영향을 받게 되는 것입니다.
</p>
<p>par()를 사용하면, <em>언제나</em>, 심지어 <code>par()</code>가 다른 함수 안에서 사용된 경우라도, (현재 디바이스 내)
모든 그래픽 파라미터들의 값이 (the global values of graphics parameters) 영향을 받게 된다는 점을
주의하시기 바랍니다. 이러한 결과는, 대부분의 경우 그다지 바람직하고 할 수 없을 겁니다 - 보통 우리가 바라는 것은 몇 개의 그래픽
파라미터만을 따로 지정하고, 이 상태에서 몇 개의 플롯을 작업한 후, 다시 처음의 설정으로 돌아갈 수 있도록 현재의 R 세션
전체에는 영향을 주지 않는 것입니다. 따라서, 몇 개의 그래픽 파라미터를 바꿔서 작업하고 싶은 경우, 초기값들을 <code>par()</code>의
결과로 저장해두면, 변경된 파라미터로 플롯 작업을 끝낸 다음에, 이 저장된 값을 실행하면 다시 초기값으로 복원됩니다.
</p>
<div class="example">
<pre class="example">&gt; oldpar &lt;- par(col=4, lty=2)
  <span class="roman">&hellip; plotting commands &hellip;</span>
&gt; par(oldpar)
</pre></div>

<p>설정가능한 <em>모든</em> 그래픽 파라미터의 값을 저장했다 다시 사용하기 위해서는,  <a name="DOCF24" href="#FOOT24"><sup>24</sup></a>그래픽 파라미터를 다음과 같이 지정하면
됩니다.
</p>
<div class="example">
<pre class="example">&gt; oldpar &lt;- par(no.readonly=TRUE)
  <span class="roman">&hellip; plotting commands &hellip;</span>
&gt; par(oldpar)
</pre></div>


<hr>
<a name="Arguments-to-graphics-functions"></a>
<a name="injareul-sayonghan-ilsijeog-byeonhwan_0028Temporary-changes_003a-Arguments-to-graphics-functions_0029"></a>
<h4 class="subsection">12.4.2 인자를 사용한 일시적 변환(Temporary changes: Arguments to graphics functions)</h4>

<p>그래픽 파라미터들은 (거의 모든) 그래픽 함수에서 적당한 인수로 사용될 수 있습니다. 인수로 사용했을 때는 오직 해당 함수가 사용되는
동안만 새로 지정한 값이 적용된다는 점을 제외하고는, par()함수 내에서 사용했을 때와 거의 같은 효과를 갖습니다. 예를 들면:
</p>
<div class="example">
<pre class="example">&gt; plot(x, y, pch=&quot;+&quot;)
</pre></div>

<p>위 명령문의 결과로 더하기 기호(<code>+</code>)를 플롯 문자(plotting character)로 사용한 산점도를 그리게 되는데, 이
경우 앞으로 그리게 될 플롯의 디폴트 플롯문자를 바꾸지는 않습니다.
</p>
<p>안타깝게도, 항상 이런 방식이 항상 일관성있게 적용되는 것은 아니므로, 경우에 따라서는 <code>par()</code>를 사용해서 그래픽
파라미터들을 원하는대로 지정하고 다시 되돌리는 작업을 해야할 수도 있습니다.
</p>

<hr>
<a name="Graphics-parameters"></a>
<a name="geuraepig-paramiteo-mogrog"></a>
<h3 class="section">12.5 그래픽 파라미터 목록</h3>

<p>앞으로 몇 개의 섹션에서는 일반적으로 많이 사용되는 그래픽 파라미터들에 대해 자세히 설명하겠습니다. <code>par()</code> 함수의
R 도움말 문서에 간단히 요약되어있지만, 이 문서에서는 좀 더 자세히 설명하겠습니다.
</p>
<p>그래픽 파라미터들은 다음의 형식으로 사용됩니다:
</p>
<dl compact="compact">
<dt><code><var>name</var>=<var>value</var></code></dt>
<dd><p>파라미터의 효과에 대한 설명. <var>name</var>은 파라미터의 이름(the name of the parameter), 즉
<code>par()</code> 또는 그래픽 함수에서 사용할 인수의 이름을 의미합니다. <var>value</var>는 파라미터를 원하는대로
지정하기위해(setting) 사용하는 일반적인 값(values) 중 하나를 의미합니다.
</p></dd>
</dl>

<p>단, <code>축(axes)</code>은 <strong>그래픽 파라미터가 아니라</strong>, <code>plot</code> 함수에만 적용가능한 몇 안되는 인자들
중의 하나라는 점을 기억하시기 바랍니다: 여기에 대해서는 <code>xaxt</code>와 <code>yaxt</code>를 참고하시기 바랍니다.
</p>

<hr>
<a name="g_t_adf8_b798_d53d-_c694_c18c_b4e4_c758-_d65c_c6a9_0028Graphical-elements_0029"></a>
<a name="geuraepig-yosodeulyi-hwalyong_0028Graphical-elements_0029"></a>
<h4 class="subsection">12.5.1 그래픽 요소들의 활용(Graphical elements)</h4>

<p>R의 플롯은 점, 선, 텍스트 그리고 (영역이 채워진) 다각형이라는 구성 요소들로 이루어져 있습니다. 이러한 <em>그래픽
요소(graphical elements)</em>들이 그려지는 방식을 제어하는 그래픽 파라미터에는 다음과 같은 것들이 있습니다:
</p>
<dl compact="compact">
<dt><code>pch=&quot;+&quot;</code></dt>
<dd><p>점을 플롯팅에 사용할 문자(character)를 지정합니다. 디폴트는 그래픽 드라이버(driver)의 종류에 따라 차이가 있긴하지만,
일반적으로는 (속이 빈) 
원의 형태입니다. 
선택한 포인팅 문자의 종류에 따라 자동적으로 점의 위아래의 위치가 적절하게 조정되며, 예를 들면, <code>&quot;.&quot;</code>의 경우 점이
가운데로 정렬됩니다.
</p>
</dd>
<dt><code>pch=4</code></dt>
<dd><p><code>pch</code>에 0에서 25사이의 정수가 입력될 경우, 각 번호에 해당하는 기호(symbol)를 사용한 플롯을 그립니다.  각
번호에 해당하는 기호(symbol)가 무엇인지 확인하려면, 다음과 같은 명령어를 사용할 수 있습니다.
</p>
<div class="example">
<pre class="example">&gt; legend(locator(1), as.character(0:25), pch = 0:25)
</pre></div>

<p>또, 21에서 25사이의 숫자가 선택될 경우, 0에서 20 사이에 이미 사용되었던 기호(symbol)가 다른 방식으로 색이
칠해져(coloured/속이 빈 원의 경우, 까만 원으로 그려질 수 있습니다) 그려질 수 있습니다: <code>points</code> 에 관한
도움말과 예제를 참조하시기 바랍니다.
</p>
<p>또한, <code>pch</code>는 <code>32:255</code>의 범위에 해당하는 숫자로, 현재 폰트에서 문자(character)로 사용되는,
문자나 숫자로 점을 플롯할 수 있습니다.
</p>
</dd>
<dt><code>lty=2</code></dt>
<dd><p>선의 종류(types)를 지정하는 옵션. 이 옵션으로 지정한 선의 종류를 모든 그래픽 디바이스가 항상 출력가능한 것은 아니며, 또
디바이스의 종류에 따라 선을 출력하는 방식이 다를 수도 있습니다. 그러나 <code>lty=1</code>은 항상 실선(solid line)을,
<code>lty=0</code>은 항상 선을 보이지 않게, <code>lty=2</code>와 그 이상의 번호는 점선(dotted)이나 파선(dashed),
혹은 이 둘을 다양하게 조합한 선으로 출력합니다. 
</p>
</dd>
<dt><code>lwd=2</code></dt>
<dd><p>선의 굵기(width)를 지정하는 옵션. “표준(standard)” 두께의 몇 배인지를 숫자로 지정하여, 원하는대로 선의 두께를
지정합니다. <code>lines()</code>함수로 그린 선은 물론이고, 플롯의 축(axis)선 및 다른 선들의 굵기를 조정하는 것도
가능합니다. 모든  디바이스가 이 파라미터를 지원하는 것은 아니며, 디바이스의 종류에 따라 사용가능한 선의 굵기에 제약이 있을 수
있습니다.
</p>
</dd>
<dt><code>col=2</code></dt>
<dd><p>점, 선, 덱스트, 그리고 색으로 채워진 영역과 이미지 모두에 색을 지정하기 위해 사용 가능합니다. 현재 사용 중인 파레트
(palette, 자세한 사용은 <code>?palette</code> 부분 참조)로부터 번호를 선택하거나, 또는 색 이름을 직접 입력해서 선택하는
것도 가능 합니다. 
</p>
</dd>
<dt><code>col.axis</code></dt>
<dt><code>col.lab</code></dt>
<dt><code>col.main</code></dt>
<dt><code>col.sub</code></dt>
<dd><p>비슷한 색(color)지정 파라미터들로 위와 같은 것들이 있으며, 위에서부터 순서대로 축의 주석(axis annotation),
<em>x</em>와 <em>y</em>의 레이블(label), 주(main)타이틀과 서브(sub)-타이틀에 각각 사용 가능합니다.
</p>
</dd>
<dt><code>font=2</code></dt>
<dd><p>정수 값을 사용하여 텍스트(text)를 출력에 사용할 폰트(font)의 종류를 지정합니다. 장치 드라이버가 지원가능한 경우,
<code>1</code>은 기본형 텍스트(plain text), <code>2</code>는 볼드체(굸은 글씨, bold face), 3은
이탤릭체(italic), <code>3</code>는 볼드 이탤릭, 그리고 <code>5</code>는 (그리스 문자 등을 포함하는) 기호(symbol)
폰트로 출력합니다. 
</p>
</dd>
<dt><code>font.axis</code></dt>
<dt><code>font.lab</code></dt>
<dt><code>font.main</code></dt>
<dt><code>font.sub</code></dt>
<dd><p>폰트 역시 적용하게 될 대상에 따라, 위에서부터 순서대로 축의 주석 (axis annotation), <em>x</em>와 <em>y</em>의
레이블(label), 주(main)타이틀과 서브(sub)-타이틀에 각각 사용 가능합니다.
</p>
</dd>
<dt><code>adj=-0.1</code></dt>
<dd><p>플롯의 위치를 기준으로 텍스트를 상대적으로 정렬(justification)합니다. <code>0</code>은 좌측정렬(left justify),
<code>1</code>은 우측정렬(right justify), 그리고 <code>0.5</code>는 플롯의 위치를 기준으로 가운데에 수평으로(center
horizontally)로 정렬하는 것을 의미합니다. 즉, 지정된 숫자는 텍스트의 비율을 의미하는 것으로, 플롯의 위치에서 왼쪽을
기준으로 얼마만큼 간격을 두는지 결정합니다. 따라서, <code>-0.1</code>를 지정할 경우, 플롯의 위치와 텍스트 사이에 텍스트
너비(width)의 10% 만큼의 간격을 두게 됩니다. 
</p>
</dd>
<dt><code>cex=1.5</code></dt>
<dd><p>문자 (character)의 확대 비율을 지정합니다. 이 옵션의 값은 텍스트 문자(플로팅 문자(plotting characters)
포함)의 크기를 텍스트의 디폴트(default) 크기를 기준으로 했을 때의 상대적 크기로 출력합니다. 
</p>
</dd>
<dt><code>cex.axis</code></dt>
<dt><code>cex.lab</code></dt>
<dt><code>cex.main</code></dt>
<dt><code>cex.sub</code></dt>
<dd><p>역시 대상에 따라, 위에서부터 순서대로 축의 주석 (axis annotation), <em>x</em>와 <em>y</em>의
레이블(label), 주(main)타이틀과 서브(sub)-타이틀에 각각 적용됩니다.
</p></dd>
</dl>

<hr>
<a name="g_t_cd95_acfc-_d2f1-_b9c8_d06c-_0028tick-marks_0029"></a>
<a name="cuggwa-tig-makeu-_0028tick-marks_0029"></a>
<h4 class="subsection">12.5.2 축과 틱 마크 (tick marks)</h4>

<p>R의 하이-레벨에 플롯(high-level plots)에서는 많은 경우 축이 자동 포함되지만, 로-레벨(low-level) 그래픽
함수인 <code>axis()</code> 등을 사용하여 원하는 대로 축을 지정하는 것 역시 가능합니다. 축은 세 가지 요소에 의해 결정 됩니다:
<em>축선 (axis line)</em> (선의 종류는 <code>lty</code> 그래픽 파라미터에 의해 지정됨), <em>틱 마크(tick
marks)</em> (축선을 따라서 단위별로 분할하는 선을 표기),그리고 <em>틱의 레이블 (tick labels)</em>(틱 마크의 단위
표기)가 그 세 가지 입니다. 이러한 요소들은 다음과 같은 그래픽 파라미터들을 사용하여 조정할 수 있습니다. 
</p>
<dl compact="compact">
<dt><code>lab=c(5, 7, 12)</code></dt>
<dd><p>처음의 두 숫자는 각각 <em>x</em>와 <em>y</em>축에의  틱의 간격을 지정합니다. 세번째 숫자는 축 레이블(axis
labels)이 출력될 길이(소수점 아래 길이 포함)를 (사용 가능한) 문자길이로 지정합니다. 이 파라미터가 너무 작은 값으로 선택될
경우, 모든 틱 레이블들이 반올림되어져 같은 숫자가 되어버리는 문제가 발생할 수 있습니다.
</p>
</dd>
<dt><code>las=1</code></dt>
<dd><p>축 레이블의 정렬될 방향(orientation)을 지정합니다. <code>0</code>은 축에 평행하게(parallel to axis),
<code>1</code>은 수평으로(horizontal), 그리고 <code>0</code>는 축에 수직으로(perpendicular to the axis)
레이블을 출력합니다.
</p>
</dd>
<dt><code>mgp=c(3, 1, 0)</code></dt>
<dd><p>축 요소들에 대해 위치를 지정합니다. 첫번째 숫자는 축 레이블(axis label)에서 축의 위치까지의 거리를, 텍스트의 줄 간격으로
표시합니다. 두번째 요소는 틱 레이블까지의 거리를, 마지막 값은 축의 위치에서부터 축선까지의 거리(보통은 0)를 지정합니다. 양수 값을
지정할 경우 플롯의 영역의 바깥쪽에 해당 요소들이 나타나며, 음수값의 경우는 안쪽에 나타납니다.
</p>
</dd>
<dt><code>tck=0.01</code></dt>
<dd><p>틱마크(tick marks)의 길이를 플롯된 영역의 크기에 대한 비율(fraction)로 지정합니다. <code>tck</code>이 작게
(0.5보다 작을 경우) 지정된 경우, <em>x</em>와 <em>y</em> 축에 표시된 틱마크들은 모두 같은 크기로 나타나게 됩니다. 1로
지정할 경우, 그리드 선(grid lines)으로 나타내며, 음수값은 플롯 영역의 바깥에 틱마크를 표시합니다.안쪽에 틱마크를 표시하고
싶다면, <code>tck=0.01</code>와 <code>mgp=c(1,-1.5,0)</code>를 같이 사용하세요.
</p>
</dd>
<dt><code>xaxs=&quot;r&quot;</code></dt>
<dt><code>yaxs=&quot;i&quot;</code></dt>
<dd><p>각각 <em>x</em>와 <em>y</em> 축의 스타일을 지정합니다.  스타일이 &quot;i&quot; (internal)와 &quot;r&quot; (디폴트
(default))인 경우, 틱마크가 항상 데이타 범위 내에서만 나타나지만, <code>&quot;r&quot;</code> 의 경우 모서리에서 약간의 공백을 남기고
출력합니다. (S의 경우, R에는 적용되지 않는 다른 스타일을 사용합니다.) 
</p>
</dd>
</dl>

<hr>
<a name="g_t_adf8_b9bc-_0028figure_0029_c758-_c5ec_bc31"></a>
<a name="geurim-_0028figure_0029yi-yeobaeg"></a>
<h4 class="subsection">12.5.3 그림 (figure)의 여백</h4>


<p>R에서는 하나의 플롯이 하나의 <code>그림(figure)</code>으로 나타나며, 이 그림은 여백(margins)으로 둘러싸인
<em>플롯 영역(plot region)</em> (축, 레이틀, 제목 등을 포함하는)과 (많은 경우) 축에 의해 둘러싸여 있습니다. 
</p>
<p>아래는 전형적인 예입니다.
</p>
<img src="images/fig11.png" alt="images/fig11">

<p>이러한 그림의 레이아웃 (구성 요소의 배열)은 다음과 같은 그래픽 파라미터들에의해 결정됩니다:
</p>
<dl compact="compact">
<dt><code>mai=c(1, 0.5, 0.5, 0)</code></dt>
<dd><p>순서대로 아래, 왼쪽, 위 그리고 오른쪽 여백(margin)의 너비를 조정합니다. 단위는 인치 입니다.
</p>
</dd>
<dt><code>mar=c(4, 2, 2, 1)</code></dt>
<dd><p>위의 mai 와 같은 기능을 하지만, 유일한 차이는 텍스트의 줄 간격을 단위로 한다는 점입니다.  
</p></dd>
</dl>

<p><code>mar</code>와 <code>mai</code>는, 두 가지 중 하나만 사용하더라도 다른 한쪽이 영향을 받는다는 점에서, 두 함수는 동등하다고
할 수 있겠습니다. 이 파라미터는 디폴트(default)로 지정된 값이 좀 큰 편이라 조정이 필요할 것입니다; 오른쪽 여백
(margin)을 조정할 일은 거의 없다고 할 수 있으며, 윗 여백 역시 거의 사용할 일이 없을 것입니다. 하지만, 아래와 왼쪽여백의
경우, 축이나 틱레이블을 출력할 수 있을 만큼의 여백이 필요합니다. 무엇보다, 디폴트 값은 디바이스가 어느 정도의 크기로 출력할지 전혀
고려하지 않은 채 설정되어져 있습니다: 예를 들면, <code>postscript()</code> 드라이버를 사용할 경우, 따로
<code>mar</code>나 <code>mai</code>를 지정하지 않고, <code>height=4</code> 만 사용할 경우, 플롯 크기의 반 크기에 해당하는
여백을 포함하게 됩니다.  또 여러 그래프를 중첩해서 사용할 경우 (아래 multiple figure environment 참조)
자동적으로 여백은 줄어들지만, 이렇게 줄어든 여백으로도 여러 개의 그래프를 한 페이지에 모두 출력하기에는 충분하지 않을 수 있습니다.
</p>
<hr>
<a name="g_t_c911_cca9_b41c-_adf8_b9bc-_0028figure_0029-_d658_acbd"></a>
<a name="jungceobdoen-geurim-_0028figure_0029-hwangyeong"></a>
<h4 class="subsection">12.5.4 중첩된 그림 (figure) 환경</h4>

<p>R에서는 한 페이지에 출력 가능하도록, <em>n</em> 행 <em>m</em> 열로된 그림의 배열(array)을 생성할 수
있습니다. 각각의 그림(figure)은 각자의 여백을 포함하며, 그림의 배열(array)은 외부여백 (outer margin)을 포함하는
것이 가능합니다.
</p>
<img src="images/fig12.png" alt="images/fig12">

<p>그래프의 중첩과 관련된 그래픽 파라미터에는 다음과 같은 것들이 있습니다:
</p>
<dl compact="compact">
<dt><code>mfcol=c(3, 2)</code></dt>
<dt><code>mfrow=c(2, 4)</code></dt>
<dd><p>여러 그림을 배열할 크기를 지정합니다. 각 파라미터의 첫번째 값은 행의 수를, 두번째 값은 열의 수를 지정합니다. 이 두 파라미터의
유일한 차이점은 지정된 틀에 그래프를 채워나가는 순서인데, <code>mfcol</code>의 경우 플롯을 (그리는) 순서대로 열 별로(by
column) 그래프를 채워나가고 <code>mfrow</code>의 경우, 행별로(by rows) 그래프를 채워나갑니다.  
</p>
<p>즉, 그림의 레이아웃(layout)은 <code>mfrow=c(3,2)</code>과 같은 지정에 의해 생성된 것입니다; 이 그림의 경우 6개의
플롯이 모두 그려진 다음 해당 페이지를 출력하게 됩니다.
</p>
<p>두 파라미터 중 하나가 사용될 경우, (<code>par(&quot;cex&quot;)</code>와 현재 디바이스에서의 폰트 크기에 영향을 받는)
기호(symbols)와 텍스트의 기본 크기(base size)가 줄어들 수 있습니다. 2행과 2열의 레이아웃의 경우, 여기에 포함된
텍스트는 기본 크기가 처음 크기의 0.83 배가 되며, 만약 세 개나 그 이상의 행이나 열이 한 레이아웃에 포함될 경우, 텍스트는 처음
크기의 0.66배가 됩니다.
</p>
</dd>
<dt><code>mfg=c(2, 2, 3, 2)</code></dt>
<dd><p>중첩 (그림) 환경( multiple figure environment)에서 현재 그림의 위치를 지정합니다. 처음 두 개의 숫자는 현재
그림의 행과 열의 위치를 표시하며, 나중의 두 숫자는 여러 그림이 배열되었을 때의 위치를 행과 열로 표시합니다. 이미 배열이 된 그림들
사이에 간격을 주기 위해서도 이 문장을 사용할 수 있습니다. 또한 한 페이지 상의 크기가 다른 두 그림을 조정하기 위해, 이 그래픽
파라미터의 마지막 두 숫자를 <em>실제</em>값과 다른 값으로 지정하는 것도 가능합니다.
</p>
</dd>
<dt><code>fig=c(4, 9, 1, 4)/10</code></dt>
<dd><p>해당 페이지에서 현재 그림의 위치를 조정합니다. 각각의 숫자들은 그림의 왼쪽, 오른쪽, 아래 그리고 위 모서리의 위치를 나타내는 것으로,
왼쪽 아래 모서리에서부터 재었을 때의 해당 페이지의 비율을 나타냅니다. 이 모수를 지정하면 한 페이지 안의 어떤 위치에라도
그림(figures)을 출력하는 것이 가능해집니다. 만약 현재 페이지에 그림을 하나 더 추가하고 싶다면, <code>new=TRUE</code>
라는 옵션을 함께 사용해야 합니다. (이 점은 S와 다릅니다.)
</p>
</dd>
<dt><code>oma=c(2, 0, 3, 0)</code></dt>
<dt><code>omi=c(0, 0, 0.8, 0)</code></dt>
<dd><p>외부여백(outer margins)의 크기를 조정합니다.  <code>mar</code>와 <code>mai</code>에서와 마찬가지로,
<code>oma</code>는 텍스트 줄 간격으로, <code>omi</code>는 인치 단위로 여백의 크기를 지정하며, 입력된 네 숫자는 아래여백부터
시작해서 시계 방향으로 표기한 것 입니다.
</p>
</dd>
</dl>

<p>외부여백(outer margins)은 페이지 별로 표기되는(page-wise) 타이틀 등을 제대로 출력하기 위해 지정되어야 합니다. 외부
여백에 텍스트를 출력하고 싶다면, <code>mtext()</code> 함수와 <code>outer=TRUE</code> 인자를 사용하면 됩니다. 외부 여백은
디폴트로 지정되지 않았으므로, 반드시 <code>oma</code>나 <code>omi</code>를 사용해서 따로 지정해야마 합니다.
</p>
<p>좀 더 복잡하게 배열된 그래픽 중첩을 사용하고 싶다면, <code>split.screen()</code>과 <code>layout()</code> 같은
함수들을 사용할 수 있으며, <strong>grid</strong>나 <a href="http://CRAN.R-project.org/package=lattice"><strong>lattice</strong></a> 등의 패키지를 사용하는 것도 가능합니다.
</p>
<hr>
<a name="Device-drivers"></a>
<a name="Device-drivers-1"></a>
<h3 class="section">12.6 Device drivers</h3>
<a name="index-geuraepig-dibaiseu-deuraibeo-_0028graphic-device-driver_0029"></a>

<p>R은 거의 모든 종류의 디스플레이나 프린팅 디바이스에서 (다양한 수준의) 그래픽을 생성합니다. 하지만, 이러한 작업을 시작하기전,
반드시 R에 어떤 종류의 디바이스를 사용할 것인지를 지정해야 합니다. 이러한 디바이스 지정은 하나의 <em>장치 드라이버
(device driver)</em>를 작동시키는 것입니다. 이렇게 장치 드라이버를 작동시켜야하는 이유는 R에서 사용된 그래픽 명령문(예를
들어, “선을 그어라” 같은)을 사용하고자 하는 디바이스가 이해할 수 있는 형태로 전환하기 위해서입니다.   
</p>
<p>장치 드라이버는 장치 드라이버 함수를 사용해서(calling) 작동시킵니다. (R에서 사용 가능한) 모든 종류의 장치 드라이버에는
이러한 기능을 가진 함수가 하나씩 있습니다:  <code>help(Devices)</code>라고 입력하시면 사용가능한 모든 디바이스와 해당
디바이스를 작동시키는 함수의 리스트를 확인할 수 있습니다. 예를 들면, 다음과 같은 명령문을 입력하면
</p>
<div class="example">
<pre class="example">&gt; postscript()
</pre></div>

<p>앞으로 생성하게 될 모든 그래픽 결과물들이 PostScript 포맷으로 프린터로 보내지게 됩니다. 자주 자용되는 장치 드라이버에는 다음과
같은 것들이 있습니다:
</p>
<dl compact="compact">
<dt><code>X11()</code></dt>
<dd><a name="index-X11"></a>
<p>Unix와 같은 X11 윈도우 시스템을 사용하기 위한 함수
</p></dd>
<dt><code>windows()</code></dt>
<dd><a name="index-windows"></a>
<p>윈도우를 사용하기 위한 함수
</p></dd>
<dt><code>quartz()</code></dt>
<dd><a name="index-quartz"></a>
<p>Mac OS X 를 사용하기 위한 함수
</p></dd>
<dt><code>postscript()</code></dt>
<dd><a name="index-postscript"></a>
<p>PostScript로 프린터를 사용하거나, 또는 PostScript 포맷으로 된 그래픽 파일을 생성하기 위한 함수
</p></dd>
<dt><code>pdf()</code></dt>
<dd><a name="index-pdf"></a>
<p>PDF 파일을 생성하며, 이 파일을 다른 PDF 파일에 포함시키는 것도 가능
</p></dd>
<dt><code>png()</code></dt>
<dd><a name="index-png"></a>
<p>비트맵 PNG 파일을 생성하는 함수 (언제나 실행 가능한 것은 아닙니다: help 참조)
</p></dd>
<dt><code>jpeg()</code></dt>
<dd><a name="index-jpeg"></a>
<p>비트맵 JPEG 파일을 생성하는 함수로 <code>image</code> 플롯을 저장하기에 최적화된 방법 (언제나 실행 가능한 것은 아닙니다:
help 참조)
</p></dd>
</dl>

<p>하나의 디바이스의 사용이 끝나면, 다음과 같은 명령어를 사용해서 해당 디바이스를 종료시키는 것을 잊지 마십시기 바랍니다.
</p>
<div class="example">
<pre class="example">&gt; dev.off()
</pre></div>

<p>이 문장을 사용하면 현재 사용 중인 디바이스를 좀 더 확실하게 종료시킬 수 있습니다; 예를 들면, 하드카피로 출력하는 디바이스를 사용
중인 경우, 이 명령문을 사용하면 각 페이지가 종료된 다음 프린터로 보내집니다. (원래 페이지의 종료는 R에서 하나의 세션이 종료될 때
자동적으로 이루어지게 됩니다.)
</p>

<hr>
<a name="g_t_c870_d310-_bb38_c11c_b97c-_c704_d55c-_d3ec_c2a4_d2b8_c2a4_d06c_b9bd_d2b8-_b2e4_c774_c5b4_adf8_b7a8-_c0dd_c131_d558_ae30_0028PostScript-diagrams-for-typeset-documents_0029"></a>
<a name="jopan-munseoreul-wihan-poseuteuseukeuribteu-daieogeuraem-saengseonghagi_0028PostScript-diagrams-for-typeset-documents_0029"></a>
<h4 class="subsection">12.6.1 조판 문서를 위한 포스트스크립트 다이어그램 생성하기(PostScript diagrams for typeset documents)</h4>

<p><code>postscript()</code> 장치 드라이버에 <code>file</code>을 인수로 지정하면, 작업힌 그래픽을 PostScript 포맷으로
지정한 파일 안에 저장할 수 있습니다. 플롯은 별도로 <code>horizontal=FALSE</code> 지정을 하지 않는다면,
가로정렬(landscape orientation) 되며, <code>width</code>와 <code>height</code> 인수를 사용하면 그래픽의
크기를 조정할 수 있습니다 (플롯은 지정된 페이지 크기에 맞춰 자동적으로 크기가 조절됩니다).예를 들면, 다음과 같은 명령문을 사용할
경우
</p>
<div class="example">
<pre class="example">&gt; postscript(&quot;file.ps&quot;, horizontal=FALSE, height=5, pointsize=10)
</pre></div>

<p>PostScript 코드로 된 높이가 5인치인 그림 파일 하나가 생성되며, 이 파일은 아마도 다른 문서에 포함될 수도 있을
것입니다. 만약 명령문에 사용된 파일의 이름이 이미 존재하는 파일의 이름과 같다면, 이 문장으로 실행으로
덮어쓰기(overwritten)가 되어버립니다. 이러한 덮어쓰기는 설사 해당 파일이 현재 R 세션에서 방금 전에 생성된 것이라고
하더라도 발생하게 됩니다.
</p>
<p>PostScript 포맷을 사용하는 가장 많이 사용되는 곳은 생성된 그림(figure)을 다른 문서에 포함시키는 작업을 할 때
입니다. 이러한 작업은 파일을 PostScript 포맷으로 <em>고정시키면(encapsulated)</em> 훨씬 쉬워집니다: R은
별도로 <code>onefile=FALSE</code> 인자가 지정되지 않으면, 계속 같은 파일로(conformant) 결과를 출력합니다. 이러한
특이한 출력방식은 S 과의 호환성(compatibility)에서 기인합니다: 다시 말해, 모든 결과물이 (EPSF 기준을 따르기
때문에) 한 페이지에 출력된다는 의미입니다. 따라서, 다른 문서에 포함될 수 있는(for inclusion use) 플롯을 그리기
위해서는 다음과 같은 문장을 사용해야 합니다.
</p>
<div class="example">
<pre class="example">&gt; postscript(&quot;plot1.eps&quot;, horizontal=FALSE, onefile=FALSE,
             height=8, width=6, pointsize=10)
</pre></div>


<hr>
<a name="g_t_b2e4_c218_c758-_adf8_b798_d53d-_b514_bc14_c774_c2a4-_0028graphic-devices_0029"></a>
<a name="dasuyi-geuraepig-dibaiseu-_0028graphic-devices_0029"></a>
<h4 class="subsection">12.6.2 다수의 그래픽 디바이스 (graphic devices)</h4>

<p>R의 중상급 이상의 사용자라면 종종 여러 개의 그래픽 디바이스에서 동시에 작업해야할 필요를 느낄 수도 있습니다. 물론, 실제로는 한
번에 하나의 명령문이 오직 하나의 그래픽 디바이스에서만 실행되며, 이때 사용 중인 디바이스를 <em>현재 디바이스(current
device)</em>라고 부릅니다. 여러 개의 디바이스가 사용중인 경우(open), 디바이스들은 열린 순서대로 리스트 상 하나의 위치에
할당되며, 해당 디바이스의 종류가 이름처럼 표기됩니다. 
</p>
<p>여러 디바이스들을 동시에 열어 작동시키기위해 사용할 수 있는 주요 명령문과 그 의미는 아래와 같습니다:
</p>
<dl compact="compact">
<dt><code>X11()</code></dt>
<dd><p>[UNIX]
</p></dd>
<dt><code>windows()</code></dt>
<dt><code>win.printer()</code></dt>
<dt><code>win.metafile()</code></dt>
<dd><p>[Windows]
</p></dd>
<dt><code>quartz()</code></dt>
<dd><p>[OS X]
</p></dd>
<dt><code>postscript()</code></dt>
<dt><code>pdf()</code></dt>
<dt><code>png()</code></dt>
<dt><code>jpeg()</code></dt>
<dt><code>tiff()</code></dt>
<dt><code>bitmap()</code></dt>
<dt><code>&hellip;</code></dt>
<dd><p>새로운 장치 드라이버 함수를 입력할 때마다 새 그래픽 디바이스가 작동되며, 따라서 디바이스 리스트도 사용된 함수의 숫자 만큼 하나씩
길어지게 됩니다. 이렇게 작동된 디바이스는 현재 디바이스가 되며, 앞으로 생성될 그래픽 결과물은 이 현재 디바이스가 출력합니다.
</p>
</dd>
<dt><code>dev.list()</code></dt>
<dd><a name="index-dev_002elist"></a>
<p>현재 사용중인 모든 디바이스들의 개수와 이름을 보여주는 명령문. 이 리스트 상의 첫번째 위치(position 1)에는 항상 <em>널
디바이스 (null device)</em>가 위치하지만, 사실 이 디바이스는 그랙픽 명령문을 전혀 실행하지 않습니다.
</p>
</dd>
<dt><code>dev.next()</code></dt>
<dt><code>dev.prev()</code></dt>
<dd><a name="index-dev_002enext"></a>
<a name="index-dev_002eprev"></a>
<p>리스트 상에서 현재 디바이스 보다 각각 (순서상) 앞이나 뒤에 위치한 그래픽 디바이스들의 개수와 이름을 보여주는 명령문.
</p>
</dd>
<dt><code>dev.set(which=<var>k</var>)</code></dt>
<dd><a name="index-dev_002eset"></a>
<p>디바이스 리스트 상 <var>k</var> 번째에 위치한 그래픽 디바이스를 현재 디바이스로 지정하기위해 사용하는 명령문. 새로 지정된 디바이스의
숫자와 이름을 출력합니다.
</p>
</dd>
<dt><code>dev.off(<var>k</var>)</code></dt>
<dd><a name="index-dev_002eoff"></a>
<p>디바이스 리스트 상 <var>k</var> 번째 그래픽 디바이스를 종료시킵니다. <code>postscript</code> 와 같은 몇몇 디바이스의 경우,
디바이스의 종류에 따라 이 명령문은 해당 파일을 즉시 출력하거나 또는 나중에 출력하기 위해 해당 파일을 제대로 종료하는 것으로
실행됩니다.
</p>
</dd>
<dt><code>dev.copy(device, &hellip;, which=<var>k</var>)</code></dt>
<dt><code>dev.print(device, &hellip;, which=<var>k</var>)</code></dt>
<dd><p><var>k</var> 번째 디바이스를 복사(copy)하는 명령문. 여기서 <code>디바이스 (device)</code>는 <code>포스트
스크립트(postscript)</code> 같은 하나의 디바이스 함수를 의미하며, 필요할 경우 &lsquo;<samp>&hellip;</samp>&rsquo; 부분에 인수를 입력하여
사용할 수도 있습니다. <code>dev.print</code>도 비슷하게 사용되지만, 이 함수는 디바이스를 복사(copy)한 후 바로
종료시키므로, 하드 카피로 출력과 같은 명령을 즉시 실행하게 됩니다.
</p>
</dd>
<dt><code>graphics.off()</code></dt>
<dd><p>널 디바이스(null device)를 제외한 리스트 상의 모든 그래픽 디바이스들을 종료합니다.
</p></dd>
</dl>

<hr>
<a name="Dynamic-graphics"></a>
<a name="Dynamic-graphics-1"></a>
<h3 class="section">12.7 Dynamic graphics</h3>
<a name="index-Dynamic-graphics"></a>

<p>R은 다이나믹(dynamic) 또는 대화형(interactive) 그래픽을 위한 빌트인(built-in) 기능을 제공하지
않습니다. (e.g. 포인트 덩어리(point clouds)를 회전시킨다거나, 포인트들을 “색칠하는 (brushing)” (대화형으로
포인트들을 하일라이팅하는,interactively highlighting points) 것 등등). 하지만, Swayne, Cook과
Buja가 개발한 GGobi 시스템에서는 이런 기능을 사용할 수 있습니다.
</p>
<blockquote>
<p><a href="http://www.ggobi.org/">http://www.ggobi.org/</a>
</p></blockquote>

<p>또 R에서는, 아래의 <a href="http://CRAN.R-project.org/package=rggobi"><strong>rggobi</strong></a> 패키지를 설치하여 이러한 그래픽 기능들을 사용할 수 있습니다. 
</p>
<p>또한, <a href="http://CRAN.R-project.org/package=rgl"><strong>rgl</strong></a> 패키지는 3D plots에서, 좀 더 구체적으로 plot 의 표면(surfaces)에서,
대화형(interactive) 작업을 지원합니다.
</p>
<hr>
<a name="Packages-_0028_d328_d0a4_c9c0_0029"></a>
<a name="Packages-_0028paekiji_0029"></a>
<h2 class="chapter">13 Packages (패키지)</h2>
<a name="index-Packages-_0028paekiji_0029-1"></a>

<p>R의 모든 함수들과 데이터셋들은 <em>패키지 (packages)</em>안에 저장되어 있습니다. 따라서, 어떤 패키지가
로드(loaded)되었을 때만 패키지 안의 내용물들을 사용할 수 있습니다.이러한 패키지 시스템은 효율성(efficiency)과 개발자의
편의 (to aid package developers)라는 장점을 가집니다: 전체 리스트를 사용할 때 보다 메모리의 사용량이 적고,
필요한 내요을 검색하는 데도 훨씬 적은 시간이 걸린다는 점에서 효율적이며, 다른 코드와 같은 이름을 사용하게 되는 것(name
clashes with other code)을 자연스럽게 방지하는 역할도 있으므로 패키지 개발자의 편의를 고려했다고 볼 수
있습니다. 패키지를 개발하는 과정에 대해서는 <a href="http://cran.r-project.org/doc/manuals/R-exts.html#Creating-R-packages">Creating R packages</a> in <cite>Writing R Extensions</cite>를 살펴보시길 바랍니다.여기에서 우리는 사용자 측면에 대해서만 이야기할 것입니다.
</p>
<p>어떤 패키지들이 여러분이 사용중인 R 프로그램(사이트, site)에 설치되어 있는지 알고싶다면, 인자의 입력 없이 다음의 함수를
사용하시면 됩니다.
</p>
<div class="example">
<pre class="example">&gt; library()
</pre></div>

<p>특정한 하나의 패키지를 로드(load)하기 위해서는(예를 들면, Davison &amp; Hinkley (1997)에 사용된 함수들이 포함되어
있는 <a href="http://CRAN.R-project.org/package=boot"><strong>boot</strong></a>를 사용하고 싶다고 가정합시다), 아래와 같은 명령어를 입력하면 됩니다. 
</p>
<div class="example">
<pre class="example">&gt; library(boot)
</pre></div>

<p>인터넷을 사용할 수 있다면, <code>install.packages()</code>와 <code>update.packages()</code> 함수들을
이용하여 패키지를 설치하거나 업데이트 할 수 있습니다. (윈도우즈와 RAqua GUI에서는 <code>Packages</code> 메뉴를 통해
이러한 작업을 실행할 수도 있습니다. see <a href="http://cran.r-project.org/doc/manuals/R-admin.html#Installing-packages">Installing packages</a> in <cite>R Installation
and Administration</cite>)를 참고하시길 바랍니다.)
</p>
<p>현재 로드되어 있는 패키지들을 확인하고 싶다면 아래의 함수를 입력하여
</p>
<div class="example">
<pre class="example">&gt; search()
</pre></div>

<p>검색 리스트(search list)를 확인할 수 있습니다.일부 패키지들은 로드되어있다고 하더라도 검색 리스트에서 보이지 않을 수도
있습니다.(여기에 대해서는 see &lsquo;Namespaces&rsquo;를 찾아보시길 바랍니다): 이러한 패키지들은 다음의 명령어를 사용하면 확인이
가능합니다.
</p>
<div class="example">
<pre class="example">&gt; loadedNamespaces()
</pre></div>


<p>설치된 패키지에서 사용가능한 모든 도움말(help) 주제의 목록을 확인해보고 싶다면 아래의 명령어를 사용하시기 바랍니다.
</p>
<div class="example">
<pre class="example">&gt; help.start()
</pre></div>

<p>이 명령어로 <acronym>HTML</acronym> 도움말 시스템(help system)이 시작되며, <code>Reference</code> 섹션에서 패키지 목록을
찾으시면 됩니다.
</p>

<hr>
<a name="g_t_d45c_c900-_d328_d0a4_c9c0_b4e4-_0028Standard-packages_0029"></a>
<a name="pyojun-paekijideul-_0028Standard-packages_0029"></a>
<h3 class="section">13.1 표준 패키지들 (Standard packages)</h3>

<p>표준(또는 <em>기본 (base)</em>) 패키지들은 R 소스코드(source code)에서 매우 중요한 부분을 차지합니다.이 표준
패키지들은 R이 작동할 수 있도록하는 기본 함수들(basic functions)은 물론이고, 데이터셋, 표준 통계분석 및
(앞부분에서 설명된) 그래픽 함수들로 구성되어 있습니다. 이러한 표준 패키지들은 R 설치시에 자동으로 따라 옵니다. 모든 표준패키지
목록을 보고싶으시면 다음을 참조하세요. See <a href="R-FAQ.html#Which-add_002don-packages-exist-for-R_003f">R packages</a> in <cite>R FAQ</cite>.
</p>
<hr>
<a name="g_t_c0ac_c6a9_c790_002d_ae30_c5ec-_d328_d0a4_c9c0_0028Contributed-packages_0029_c640-CRAN"></a>
<a name="sayongja_002dgiyeo-paekiji_0028Contributed-packages_0029wa-CRAN"></a>
<h3 class="section">13.2 사용자-기여 패키지(Contributed packages)와 <acronym>CRAN</acronym></h3>
<a name="index-CRAN"></a>

<p>R에는 수없이 많은 개발자들에 의해 작성된, 매우 방대한 양의 기여된 패키지(contributed packages)들이
있습니다. 이 중 일부는 특수한 통계방법들을 구현하였고, 또다른 것들은 데이터 또는 하드웨어에 대한 접근을 다루고있으며, 그 외에도
교과서의 부록으로(to complement textbooks) 제작된 것들도 있습니다. 일부 <em>권장 (recommended)</em>
패키지들은 R의 바이너리 배포 때 함께 배포됩니다. 하지만 대부분의 패키지는
<acronym>CRAN</acronym>(<a href="http://CRAN.R-project.org/">http://CRAN.R-project.org/</a>과 이 사이트의 미러 사이트들) 그리고
Bioconductor (<a href="http://www.bioconductor.org/">http://www.bioconductor.org/</a>)나 Omegahat
(<a href="http://www.omegahat.org/">http://www.omegahat.org/</a>)과 같은 저장소들(repositories)을 통해서 다운로드 할 수
있습니다. <em>R FAQ</em>에는 이 문서의 출시(release)를 기준으로 최근의 CRAN 패키지들의 목록을 포함하고는 있지만,
이용가능한 패키지들의 목록은 매우 자주 변경됩니다.
</p>
<hr>
<a name="g_t_b124_c784_c2a4_d398_c774_c2a4-_0028Namespaces_0029"></a>
<a name="neimseupeiseu-_0028Namespaces_0029"></a>
<h3 class="section">13.3 네임스페이스 (Namespaces)</h3>
<a name="index-neimseupeiseu-_0028Namespaces_0029"></a>
<a name="index-_003a_003a"></a>
<a name="index-_003a_003a_003a"></a>

<p>패키지들은 <em>네임스페이스(namespaces)</em>라는 것을 가질 수 있으며, 현재 <code>datasets</code> 패키지를 제외한
모든 기본 (base)과 권장(recommended ) 패키지들은 이 네임스페이스를 가지고 있습니다. 네임스페이스는 크게 다음의 세가지
역할을 수행합니다:첫째, 패키지 작성자가 내부적 사용만을 목적으로 개발한 함수들과 데이터들을 숨길 수 있도록 합니다. 둘째, 사용자나
(혹은 다른 패키지 작성자)가 해당 패키지에서 사용중인 함수명과 같은 이름의 함수를 사용하고자 할때, 같은 이름의 두 함수가 충돌하여
작동이 중단(breaking)되는 것을 방지합니다.마지막으로 특정 패키지 내의 하나의 객체(object)를 지칭하는 또다른 방법을
제시합니다.
</p>
<p>예를 들면, <code>t()</code>는 R에서 행렬을 전치(transpose)하는 함수 입니다.  그러나, 사용자들 중에는
<code>t</code>라는 같은 이름을 갖는 자신만의 고유한 함수를 정의하고 싶은 사람도 있을 것입니다.이때 네임스페이스(namespaces)는
사용자 정의 함수가 우선권을 갖게 되어 행렬을 전치하기 위해 <code>t()</code>함수를 사용할 수 없게 되는  일이 없도록 방지합니다.
</p>
<p>네임스페이스와 함께 사용되는 두개의 연산자들(operators)이 있습니다. 하나는 더블콜론(double-colon) 연산자
<code>::</code>로, 특정 네임스페이스에 정의된 함수(definitions)들을 선택합니다.위의 예제를 다시 이용하면, 전치함수는
<code>base</code> 패키지 안에 정의되어 있기 때문에, 언제라도 <code>base::t</code>로  불러내는 것이 가능합니다.용할 수
있습니다. 하지만, 오직 패키지에서 내보내진(exported) 함수들만이 이런 식으로 사용될 수 있습니다.
</p>
<p>트리플-콜론(triple-colon) 연산자 <code>:::</code>가 R 코드 내에서 사용되는 경우가 있습니다: 이 연산자는 더블-콜론
연산자와 비슷한 기능을 수행하지만, 숨겨진 객체(hidden objects)에 대해서도 접근할 수 있다는 점에서 차이가 있습니다.그러나,
여러개의 패키지들을 대상으로 검색할 수 있는, <code>getAnywhere()</code> 함수가 더 선호되는 경향이 있습니다.
</p>
<p>패키지들은 서로 상호의존적(inter-dependent)이라, 하나를 로딩할 때 자동으로 다른 패키지들을 함께 로딩할 수
있습니다. 위에서 설명한 콜론 연산자들은 사용할 때도 관련있는 패키지들이 자동 로딩 됩니다.네임스페이스를 가진 패키지들이 자동 로드로
실행되면, 이들은 검색목록(search list)에 추가되지는 않습니다.
</p>
<hr>
<a name="g_t_c6b4_c601_ccb4_c81c_c758-_ae30_b2a5_b4e4_c5d0-_b300_d55c-_c811_adfc"></a>
<a name="unyeongcejeyi-gineungdeule-daehan-jeobgeun"></a>
<h2 class="chapter">14 운영체제의 기능들에 대한 접근</h2>

<p>R은 실행 중인 운영 체제를 이용할수있는 꽤 광범위 한 시설을가지고 있습니다: 이것은 R이 스크립트 언어로 사용될수 있고,
R 자체가 그 능력을 십분 활용하고 있습니다. 예: 패키지 설치.
</p>
<p>R 자체의 스크립트가 모든 플랫폼에서 작동 할수있어야 하기 때문에, 스크립팅 시설들이 플랫폼에 제한되지않게 가능한한 독자적으로
만들기위하여 상당한 노력이 들어갔습니다.
</p>

<hr>
<a name="g_t_d30c_c77c-_bc0f-_b514_b809_d130_b9ac"></a>
<a name="pail-mic-diregteori"></a>
<h3 class="section">14.1 파일 및 디렉터리</h3>

<p>파일및 디렉터리를 조작할수있는 함수는 많이있습니다. 좀 더 보편적으로 쓰이는 함수들 몇가지를 여기에서 설명하겠습니다.
</p>
<p>비어있는 파일이나 디렉터리를 만들고 싶은 경우 <code>file.create</code> 이나 <code>dir.create</code> 를
사용합니다. (이 함수들은 POSIX utilities 의 <code>touch</code> 및<code>mkdir</code> 과 유사합니다.)
R 세션 디렉터리에서 임시적으로 만든 파일이나 디렉터리일 경우 <code>tempfile</code> 을 참조 하십시요.
</p>
<p>파일을 삭제할 때 <code>file.remove</code> 이나 <code>unlink</code> 를 사용할수 있습니다: 디렉터리 트리도 같이 삭제
시키고 싶은 경우 <code>unlink</code> 를 사용 하면 됩니다.
</p>
<p>디렉터리 리스트 출력을 원할경우 <code>list.files</code> (<code>dir</code> 로도 사용가능) 이나 <code>list.dirs</code>
를 사용합니다. 이 함수들은 정규 표현식 (regular expression) 을 사용해 파일들을 찾을 수 있습니다: 와일드 카드를
사용할경우 <code>Sys.glob</code> 를 사용합니다.
</p>
<p><code>file.info</code>를 사용하여 filepath (예로 파일이나 디렉터리를 포함함) 에 있는 많은 양식의 정보들을 찾을수
있습니다.
</p>
<p>파일이 &rsquo;존재&rsquo;하는지  (파일이 파일 시스템에 존재하지만 현재 사용자에게 보이지 않는 경우도 있습니다) 확인하는 몇 가지 방법이
있습니다. 다양한 버전의 <code>file.exists</code>, <code>file.access</code> 그리고 <code>file_test</code>
함수들이 있습니다: 셸 스크립팅에 익숙한 분들을 위한 예로 <code>file_test</code> 는 POSIX <code>test</code>
명령어의 한 버전 입니다.
</p>
<p>R 의 <code>file.copy</code> 라는 함수는 POSIX 명령어인 <code>cp</code> 의 유사체 입니다.
</p>
<p><code>file.choose</code> 를 사용하여 파일을 선택하는 작업을  대화 형으로 수행 할 수 있습니다: 윈도우즈 포트는 더 다양한
기능을 갖은 <code>choose.files</code> 와 <code>choose.dir</code> 함수들을 가지고 있으며, <strong>tcltk</strong>
패키지에 유사한 함수들이 있습니다 : <code>tk_choose.files</code> 와 <code>tk_choose.dir</code>.
</p>
<p><code>file.show</code> 와 <code>file.edit</code> 과 같은 함수들은, 만약 콘솔 (예로 윈도우즈에서 RGui나 OS X에서
R.app)을 사용중일 경우, 콘솔의 기능을 사용하여 R 포트에 적절한 방법으로 하나 이상의 파일을 표시및 편집합니다.
</p>
<p>파일 시스템에 있는 <em>links</em> 를 일부 지원 하고 있습니다: <code>file.link</code> 와
<code>Sys.readlink</code>를 참조하십시오.
</p>

<hr>
<a name="Filepaths"></a>
<a name="Filepaths-1"></a>
<h3 class="section">14.2 Filepaths</h3>

<p>몇 가지 예외를 제외하고, R 은 filepaths를 조작할때 기본 운영체제의 기능에 의존합니다. 어떤 면에서는 운영체제에 의존하게
허락되있고. 이것은 운영체제의 버전까지도 포함됩니다. 운영체제가 filepaths를 해석하는 방법에 대한 POSIX 표준이있습니다,
그리고 많은 R 사용자들이 POSIX 표준에 대한 준수를 가정하지만, 윈도우즈는 준수함을 제기하지 않고있으며, 다른 운영체제들도
완전히 준수하지는 않을 수 있습니다.
</p>
<p>다음은 filepaths 에 관해서 발생 된 몇 가지 문제들 입니다.
</p>
<ul>
<li> POSIX 파일 시스템은 대소 문자를 구분합니다, 그래서 <samp>foo.png</samp> 와 <samp>Foo.PNG</samp> 는 다른 파일이
됩니다. 그러나, 윈도우즈와 OS X에서 기본값은 대소 문자를 구별하지 않게 되있습니다, 그리고 FAT 파일 시스템은 (일반적으로 이동식
저장 장치에 사용됨) 보통 대소 문자를 구분하지 않습니다 (그리고 모든 filepaths가 소문자로 매핑이 되 있습니다).

</li><li> 거의 모든 윈도우즈 기본 운영체제 서비스는 filepath 구분 기호(separator)로 슬래시 또는 백 슬래시의 사용을 지원하고,
R 은 윈도우에서 요구하는 양식으로 알려진 예외를 변환합니다.

</li><li> filepaths 끝에 추가되는 슬래시가 작용하는 효과는 기본 운영체제에 따라 다릅니다. 윈도우즈에서 이런 paths는 유효하지 않으며
작동하지도 않을것 입니다. POSIX-2008에서 이런 paths는 디렉터리일때만 유효하지만, 예전 버전에서는 파일일 경우에도
유효했습니다. 그러므로 이런 형식의 filepaths는 사용하지 않는게 최선일 것입니다. 

</li><li> <samp>/abc//def</samp> 처럼 중복된 슬래시가 있는 filepaths는 POSIX 파일 시스템에서 유효합니다, 그리고 이런 경우
중복되 있더라도 하나의 슬래시로 취급됩니다. 윈도우즈 기본 운영체제 기능은 <em>일반적으로</em> 이런 filepaths를 수용하고
있습니다. 하지만 앞에 추가되는 이중 슬래시는 다른 의미를 갖고있습니다.

</li><li> 윈도우즈에서 사용하는 UNC filepaths (<samp>\\server\dir1\dir2\file</samp> 와
<samp>\\?\UNC\server\dir1\dir2\file</samp> 같은 path) 는 지원되지 않습니다, 그러나 일부 R 함수에서는
사용될수도 있습니다. POXIS 파일 시스템들은 앞에 추가되는 이중 슬래시를 특별히 취급하도록 되있습니다.  

</li><li> 윈도우즈에서는 filepaths에 드라이브가 추가되있어도 유효하고, 드라이브 없이 현제 디렉토리에 비례되어도 유효합니다. 예:
<samp>d:foo/bar</samp> 는 <samp>d:/a/b/c/foo/bar</samp> 를 가리킵니다, 만약 <em><samp>d:</samp> 드라이브에
있는</em> 현제 디렉터리가 <samp>/a/b/c</samp> 일 경우.  이런식으로 작동을 하게 의도되 있지만, 안전하게 작업을 하려면 완전한
paths 를 사용하십시요.
</li></ul>

<p><code>basename</code> 과 <code>dirname</code> 함수들을 사용하여 file path의 부분을 선택할수 있습니다: 구성 요소들을
이용하여 file path를 만들때 권장되는 방법은 <code>file.path</code>입니다. <code>pathexpand</code> 함수는 (현재
사용자의, 그리고 아마도 다른 사용자들의) 홈 디렉토리에 대한 값을 대체하여 &rsquo;틸드 확장&rsquo;을 할수있게 합니다.
</p>
<p>링크가 들어있는 파일 시스템일 경우, 하나의 파일이 많은 filepaths로 불려질수 있습니다.  <code>normalizePath</code>
함수로 정식 filepath를 찾을 수 있습니다.
</p>
<p>윈도우즈는 긴 파일 이름 및 짧은 (&rsquo;8.3&rsquo;) 파일 이름의 컨셉트를 갖고 있습니다: <code>normalizePath</code> 는 긴 파일
이름을 사용 하여  path의 절대 값을 출력하고 <code>shortPathName</code>은  짧은 이름을 사용는 버전을 출력 합니다.
후자는 공백을 포함 하지 않고 구분 기호로 백슬래시를 사용 합니다. 그래서, 때로는 R에서 이름을 export 하는 데 유용합니다.
</p>
<p>파일 <em>사용 권한</em>에 관련된 주제입니다.  R는 owner/group/all 에 대 하여 read/write/execute
권한의 POSIX 컨셉트를 지원하지만 파일 시스템은 부분적으로만 지원됩니다 (그래서 윈도우즈에만 관련된 예로 (R 세션을 실행 하는
계정에서) read-only 파일이 인식이 됩니다).  액세스 제어 목록 (Access Control Lists - ACLs)이 여러
파일 시스템에 사용 되고 있지만 합의된 표준이 없고 R역시 그 목록들을 제어할 수 있는 시설이 없습니다.  사용 권한을 변경 하려면
<code>Sys.chmod</code>를 사용하면 됩니다.
</p>
<hr>
<a name="g_t_c2dc_c2a4_d15c-_ba85_b839_c5b4"></a>
<a name="siseutem-myeongryeongeo"></a>
<h3 class="section">14.3 시스템 명령어</h3>

<p><code>system</code> 과 <code>system2</code> 함수들은 시스템 명령을 호출하고 선택적으로 출력을 수집하는데
사용됩니다. <code>system2</code>는 좀 더 일반적이지만, 그것의 주요 장점은 그것을 사용하는 크로스 플랫폼 코드를 작성하기가 더
쉽다는 것입니다.
</p>
<p><code>system</code> 은 윈도우즈에서 다른 운영체제들과  다르게 작용합니다  (이것과 같은 이름의 API C 명령이 이작업을 하기
때문입니다) . 다른 곳에서 이 함수는 명령을 실행하는 쉘을 호출합니다: R 의 윈도우즈 포트에서 쉘을 호줄 하려면
<code>shell</code> 함수를 사용합니다.
</p>
<p>운영 체제가 명령을 포함하고 있는지 확인하려면, 크로스 플랫폼 방식으로이 작업을 수행하려고하는 <code>Sys.which</code> 를
사용합니다 (불행하게도 이것은 운영체제의 표준 서비스가 아닙니다).
</p>
<p><code>shQuote</code> 함수는 사용하고있는 운영체제 내에서의 명령을 위하여 필요에 따라 filepaths를 인용합니다.
</p>
<hr>
<a name="g_t_c555_cd95_acfc-_c544_ce74_c774_be0c-_0028archive_0029"></a>
<a name="abcuggwa-akaibeu-_0028archive_0029"></a>
<h3 class="section">14.4 압축과 아카이브 (archive)</h3>

<p>R 의 최신 버전은 종종 투명하게, 압축 파일을 읽고 쓸 수있는 광범위한 시설들이 있습니다.  R 에서 파일을 읽는 작업은
<em>연결 (connections)</em> 과  <code>file</code> 함수에 의해 대부분 수행 됩니다. <code>file</code> 함수는 파일
(또는 URL)의 연결을 열어줄때 사용하고, 파일의 &rsquo;magic&rsquo; 헤더로 부터 사용된 압축방식을 식별할수도 있습니다. 
</p>
<p>압축방식 중 지원된지 가장 오래된 방식은 <code>gzip</code> 압축이고 이것은 적합하고 일반적인 절충안으로 남아있습니다. 예전
리눅스의 <code>compress</code> 유틸리티로 압축된 파일들 또한 읽어질수 있지만 이런 경우는 드물어 지고 있습니다. 두 가지
다른 압축 방식으로 <code>bzip2</code> 와 <code>xz</code> 유틸리티들이 이용될수 있습니다. 이 방식들은 보통 더 높은
압축률을 이루지만 (파일에 따라서 훨씬 더 높을 수도 있음) 느린 감압시간과 훨씬 더 느린 압축시간을 감수해야 합니다. 
</p>
<p><code>xz</code> 와 <code>lzma</code> 압축 사이에 일부 혼란이 있습니다
(<a href="http://en.wikipedia.org/wiki/Xz">http://en.wikipedia.org/wiki/Xz</a>
와<a href="http://en.wikipedia.org/wiki/LZMA">http://en.wikipedia.org/wiki/LZMA</a> 참조): R 은 두 가지방법의 다양한 버전으로 압축된
파일들을 읽을 수 있습니다.
</p>
<p>파일 아카이브란 파일들을 수집한 단일의 파일로, R 패키지들을 배포할때 사용되듯이, &rsquo;tarballs&rsquo; 과 zip 파일들이 가장
일반적으로 사용됩니다. R 은 이 두 가지 파일형태를 등재할수도 풀수도 있습니다 (<code>untar</code> 와 <code>unzip</code>
함수 참조), 그리고 두 가지 형태를 모두 생산할수도 있습니다 (<code>zip</code> 같은 경우 외부 프로그램의 도움이 있어야
합니다). 
</p>
<hr>
<a name="A-sample-session"></a>
<a name="A-sample-session-1"></a>
<h2 class="appendix">Appendix A A sample session</h2>

<p>다음 세션(session)은 R 환경(environment)의 일부 기능을 처음 접하는 사용자에게 소개할 목적으로
준비되었습니다. 처음에는 시스템의 많은 기능들이 익숙하지 않고 혼란스러울 수 있으나, 이러한 불편함을 곧 사라지게 될 것입니다.
</p>
<dl compact="compact">
<dt><code>사용자의 플랫폼에 맞추어 R을 올바르게 실행하도록 합니다 (see <a href="#Invoking-R-_0028R_c744-_c2e4_d589_d558_ae30_0029">Invoking R (R을 실행하기)</a>)</code></dt>
<dd>
<p>R 프로그램이 배너와 함께 시작됩니다.
</p>
<p>(혼돈을 피하기 위해서 R 코드를 표시할 때 왼쪽에 있는 프롬프트는 표시하지 않습니다.)
</p>
</dd>
<dt><code>help.start()</code></dt>
<dd><p>사용자의 기계에서 이용이 가능한 인터넷 브라우저를 이용하여 <acronym>HTML</acronym> 인터페이스를 가진 온라인 도움말을 시작합니다. 마우스를 이용하여
어떻게 이용하는 것인지 간단히 살펴보시길 바랍니다.
</p>
<p>다음의 내용들을 실습하기 위하여 도움말 창을 작게 만들어 놓습니다.
</p>
</dd>
<dt><code>x &lt;- rnorm(50)</code></dt>
<dt><code>y &lt;- rnorm(x)</code></dt>
<dd><p>이것은 정규분포로부터 발생시킨 50개의 난수를 벡터 <em>x</em>와 <em>y</em>에 저장한 것입니다.
</p>
</dd>
<dt><code>plot(x, y)</code></dt>
<dd><p>평면공간에 <em>x</em>와 <em>y</em>의 좌표로 이루어진 점들을 플랏해봅니다. 그패픽 창이 자동으로 나타나는 것을 볼 수 있습니다.
</p>
</dd>
<dt><code>ls()</code></dt>
<dd><p>R 작업공간(workspace)에 어떤 R 객체들이 있는지 확인해봅니다.
</p>
</dd>
<dt><code>rm(x, y)</code></dt>
<dd><p>더 이상 사용하지 않는 객체들을 작업공간으로부터 제거합니다.
</p>
</dd>
<dt><code>x &lt;- 1:20</code></dt>
<dd><p><em>x = (1, 2, &hellip;, 20)</em>를 생성합니다
</p>
</dd>
<dt><code>w &lt;- 1 + sqrt(x)/2</code></dt>
<dd><p>표준편차(standard deviation)의 가중치(weight)를 생성합니다.
</p>
</dd>
<dt><code>dummy &lt;- data.frame(x=x, y= x + rnorm(x)*w)</code></dt>
<dt><code>dummy</code></dt>
<dd><p><em>x</em>와 <em>y</em>의 두 개의 열을 가지는 데이터프레임(<em>data frame</em>)을 생성하고, 이를 살펴봅니다.
</p>
</dd>
<dt><code>fm &lt;- lm(y ~ x, data=dummy)</code></dt>
<dt><code>summary(fm)</code></dt>
<dd><p>단순 선형회귀(simple linear regression)을 적합합니다. 틸다표시 좌측에 있는 <code>y</code>에 관하여, 우리는
<em>y</em>가 <em>x</em>에 의존한다는 것을 모델한 것입니다.
</p>
</dd>
<dt><code>fm1 &lt;- lm(y ~ x, data=dummy, weight=1/w^2)</code></dt>
<dt><code>summary(fm1)</code></dt>
<dd><p>우리는 표준편차를 알고 있기 때문에, 가중회귀(weighted regression)분석을 수행합니다.
</p>
</dd>
<dt><code>attach(dummy)</code></dt>
<dd><p>데이터프레임 내에 있는 열들을 일반적인 변수와 같이 접근할 수 있도록 해주는 것입니다.
</p>
</dd>
<dt><code>lrf &lt;- lowess(x, y)</code></dt>
<dd><p>비모수 국지회귀함수(nonparametric local regression)를 수행합니다.
</p>
</dd>
<dt><code>plot(x, y)</code></dt>
<dd><p>일반적인 방법으로 <em>x</em>와 <em>y</em>를 플랏해 봅니다.
</p>
</dd>
<dt><code>lines(x, lrf$y)</code></dt>
<dd><p>그래프에 회귀분석으로부터 나온 결과를 이용하여 회귀선을 추가합니다.
</p>
</dd>
<dt><code>abline(0, 1, lty=3)</code></dt>
<dd><p>그래픽에 기울기가 1이고 절편이 0인 회귀선을 표시합니다.
</p>
</dd>
<dt><code>abline(coef(fm))</code></dt>
<dd><p>가중치없이 수행한 회귀모형(unweighted regression)으로부터 얻은 회귀계수들을 이용하여 회귀선을 표시합니다.
</p>
</dd>
<dt><code>abline(coef(fm1), col = &quot;red&quot;)</code></dt>
<dd><p>Weighted regression line.
</p>
</dd>
<dt><code>detach()</code></dt>
<dd><p>탐색경로(search path)로부터 데이터프레임을 제거합니다.
</p>
</dd>
<dt><code>plot(fitted(fm), resid(fm),</code></dt>
<dt><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xlab=&quot;Fitted&nbsp;values&quot;<!-- /@w -->,</code></dt>
<dt><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ylab=&quot;Residuals&quot;<!-- /@w -->,</code></dt>
<dt><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;main=&quot;Residuals&nbsp;vs&nbsp;Fitted&quot;)<!-- /@w --></code></dt>
<dd><p>이분산성(heteroscedasticity)을 확인하기 위해서 표준회귀 진단플랏(standard regression diagnostic
plot)을 그립니다. 이를 볼 수 있나요?
</p>
</dd>
<dt><code>qqnorm(resid(fm), main=&quot;Residuals Rankit Plot&quot;)</code></dt>
<dd><p>비대칭도(skewness), 첨도(kurtosis), 그리고 이상치(outliers)를 찾기 위해서 정규스코어플랏(normal score
plot)을 이용해 봅니다. (실제로는 이 문제에 대해서 별로 유용하지 않습니다).
</p>
</dd>
<dt><code>rm(fm, fm1, lrf, x, dummy)</code></dt>
<dd><p>Clean up again.
</p></dd>
</dl>

<p>다음 섹션에서는 Michelson이 빛의 속도를 측정하기 위해서 사용했던 실험으로부터 모은 데이터를 이용해 보도록 하겠습니다. 이
데이터셋은 <code>morley</code>라고 객체명을 입력하면 이용이 가능하지만, 여기에서는 <code>read.table</code> 함수의 사용법을
알아보기 위해서 직접 데이터를 불러보도록 하겠습니다.
</p>
<dl compact="compact">
<dt><code>filepath &lt;- system.file(&quot;data&quot;, &quot;morley.tab&quot; , package=&quot;datasets&quot;)</code></dt>
<dt><code>filepath</code></dt>
<dd><p>시스템내에 데이터 파일이 존재하는 위치에 대한 파일경로를 얻습니다.
</p>
</dd>
<dt><code>file.show(filepath)</code></dt>
<dd><p>꼭 해보지 않아도 되지만, 파일의 내용을 살펴봅니다.
</p>
</dd>
<dt><code>mm &lt;- read.table(filepath)</code></dt>
<dt><code>mm</code></dt>
<dd><p>Michelson 데이터를 데이터프레임의 형식으로 읽어들인 뒤, 이를 확인해 보도록 합니다. 이 데이터셋은 <code>Expt</code> 변수에
5가지 종류의 실험정보를 저장했고, <code>Run</code> 변수에 종류별로 각각 20번씩 실험되었다는 정보를 가지고 있음을
보여줍니다. 그리고 <code>sl</code> 변수에 각 조건별 빛의 속도가 입력되어 있음을 알 수 있습니다.
</p>
</dd>
<dt><code>mm$Expt &lt;- factor(mm$Expt)</code></dt>
<dt><code>mm$Run &lt;- factor(mm$Run)</code></dt>
<dd><p><code>Expt</code>와 <code>Run</code> 변수들에 대한 데이터형을 요인(factor)로 변경합니다.
</p>
</dd>
<dt><code>attach(mm)</code></dt>
<dd><p>데이터프레임을 포지션 3 (기본값)에서 볼 수 있도록 합니다. 
</p>
</dd>
<dt><code>plot(Expt, Speed, main=&quot;Speed of Light Data&quot;, xlab=&quot;Experiment No.&quot;)</code></dt>
<dd><p>박스플랏(boxplot)을 이용하여 5가지 종류의 실험들을 서로 비교해보도록 합니다.
</p>
</dd>
<dt><code>fm &lt;- aov(Speed ~ Run + Expt, data=mm)</code></dt>
<dt><code>summary(fm)</code></dt>
<dd><p>&lsquo;runs&rsquo;와 &lsquo;experiments&rsquo;를 요인으로 놓은 상태에서 랜덤마이즈된 블락(randomized block) 분석을 합니다.
</p>
</dd>
<dt><code>fm0 &lt;- update(fm, . ~ . - Run)</code></dt>
<dt><code>anova(fm0, fm)</code></dt>
<dd><p>&lsquo;runs&rsquo;를 제외한 모델 (sub-model)을 이용하여 적합한뒤, 일반적인 분산분석(analysis of variance)와 비교를
해봅니다.
</p>
</dd>
<dt><code>detach()</code></dt>
<dt><code>rm(fm, fm0)</code></dt>
<dd><p>다음 분석으로 넘어가기 전에 불필요한 객체들을 삭제합니다.
</p>
</dd>
</dl>

<p>이제 컨투어(contour)와 이미지(image) 플랏이라는 그래픽 기능에 대해서 알아보도록 합니다.
</p>
<dl compact="compact">
<dt><code>x &lt;- seq(-pi, pi, len=50)</code></dt>
<dt><code>y &lt;- x</code></dt>
<dd><p><em>x</em>는  구간 [-pi\, pi]을 50등분한 값들을 가진 벡터입니다.
the interval [-pi\, pi].
벡터 <em>y</em>는 벡터 <em>x</em>와 동일합니다.
</p>
</dd>
<dt><code>f &lt;- outer(x, y, function(x, y) cos(y)/(1 + x^2))</code></dt>
<dd><p><em>f</em>는 <em>x</em>가 행이고, <em>y</em>가 열인 정방행렬입니다.  이 행렬의 구성요소는 <em>x</em>의 구성요소와
<em>y</em>의 구성요소를 하나의 짝을 이루도록 하여 함수 cos(y)/(1 + x^2)를
적용하여 얻은 값으로 얻어지게 됩니다.
</p>
</dd>
<dt><code>oldpar &lt;- par(no.readonly = TRUE)</code></dt>
<dt><code>par(pty=&quot;s&quot;)</code></dt>
<dd><p>현재 저장되어 있는 플랏팅 모수 (parameters)들을 보관한 뒤, 플랏팅 영역 (plotting region)을
&ldquo;square&rdquo;로 설정합니다.
</p>
</dd>
<dt><code>contour(x, y, f)</code></dt>
<dt><code>contour(x, y, f, nlevels=15, add=TRUE)</code></dt>
<dd><p><em>f</em>의 컨투어 맵(contour map)을 생성하고, 15개의 컨투어 레벨(등고선)을 보여지도록 합니다.
</p>
</dd>
<dt><code>fa &lt;- (f-t(f))/2</code></dt>
<dd><p><code>fa</code>는 <em>f</em>의 &ldquo;asymmetric part&rdquo;(비대칭 부분)입니다 (여기에서 <code>t()</code>는 행렬의
전치를 의미합니다).
</p>
</dd>
<dt><code>contour(x, y, fa, nlevels=15)</code></dt>
<dd><p>컨투어 플랏을 생성합니다.
</p>
</dd>
<dt><code>par(oldpar)</code></dt>
<dd><p>이전에 보관한 그래픽 파라미터들을 원래대로 복구시킵니다.
</p>
</dd>
<dt><code>image(x, y, f)</code></dt>
<dt><code>image(x, y, fa)</code></dt>
<dd><p>이미지 플랏을 생성합니다.
</p>
</dd>
<dt><code>objects(); rm(x, y, f, fa)</code></dt>
<dd><p>어떤 객체들이 워크스페이스에 있는지 확인한 뒤, 다음 분석을 수행하기 전에 불필요한 객체들을 제거합니다.
</p></dd>
</dl>

<p>R에서는 복소수 연산(complex arithmetic) 또한 가능합니다.
</p>
<dl compact="compact">
<dt><code>th &lt;- seq(-pi, pi, len=100)</code></dt>
<dt><code>z &lt;- exp(1i*th)</code></dt>
<dd><p><code>1i</code>는 복소수(complex number) <em>i</em>를 나타냅니다.
</p>
</dd>
<dt><code>par(pty=&quot;s&quot;)</code></dt>
<dt><code>plot(z, type=&quot;l&quot;)</code></dt>
<dd><p>허수(imaginary part)와 실수(real part)부분을 플랏합니다. 반드시 원의 모양이어야 합니다.
</p>
</dd>
<dt><code>w &lt;- rnorm(100) + rnorm(100)*1i</code></dt>
<dd><p>반지름이 1인 단위 원(unit circle) 안 쪽 부분으로부터 우리는 샘플링을 한다고 가정합니다. 한 가지 방법은 표준정규분포가
실수와 허수부분에 적용된 복소수를 취하는 것입니다.
</p>
</dd>
<dt><code>w &lt;- ifelse(Mod(w) &gt; 1, 1/w, w)</code></dt>
<dd><p>단위 원 밖에 놓여 있는 값들은 역수를 취하도록 합니다.
</p>
</dd>
<dt><code>plot(w, xlim=c(-1,1), ylim=c(-1,1), pch=&quot;+&quot;,xlab=&quot;x&quot;, ylab=&quot;y&quot;)</code></dt>
<dt><code>lines(z)</code></dt>
<dd><p>단위 원(unit circle)내에 모든 점들이 있음을 알 수 있지만, 이들이 균일하게 분포(uniform distribution)된
것이 아님을 알 수 있습니다. 
</p>
</dd>
<dt><code>w &lt;- sqrt(runif(100))*exp(2*pi*runif(100)*1i)</code></dt>
<dt><code>plot(w, xlim=c(-1,1), ylim=c(-1,1), pch=&quot;+&quot;, xlab=&quot;x&quot;, ylab=&quot;y&quot;)</code></dt>
<dt><code>lines(z)</code></dt>
<dd><p>두 번째 방법으로는 균일분포(uniform distribution)를 이용하는 것입니다. 이것은 디스크에 점들이 균등하게 퍼져있는 것처럼
보여야 합니다.
</p>
</dd>
<dt><code>rm(th, w, z)</code></dt>
<dd><p>Clean up again.
</p>
</dd>
<dt><code>q()</code></dt>
<dd><p>R 프로그램을 종료합니다. 이때,  R 작업공간(workspace)를 저장하고 싶은지에 대해서 물어보게 될
것입니다. 기초사용법에 대한 설명을 목적으로 한 세션이므로 꼭 저장하고 싶지는 않을 것입니다.
</p></dd>
</dl>

<hr>
<a name="Invoking-R-_0028R_c744-_c2e4_d589_d558_ae30_0029"></a>
<a name="Invoking-R-_0028Reul-silhaenghagi_0029"></a>
<h2 class="appendix">Appendix B Invoking R (R을 실행하기)</h2>

<p>Windows 또는 Mac OS X에서 R을 이용하는 사용자들은 특정 운영체제에 관한 설명이 되어 있는 섹션을 먼저 읽어보시길
바랍니다.  그러나, 명령어를 이용한 사용 또한 지원되고 있습니다. 
</p>

<hr>
<a name="Invoking-R-from-the-command-line"></a>
<a name="Invoking-R-from-the-command-line-1"></a>
<h3 class="appendixsec">B.1 Invoking R from the command line</h3>

<p>UNIX 또는 Windows 환경에서 명령어를 이용하여 작업을 할때, 명령어 &lsquo;<samp>R</samp>&rsquo;은 아래와 같은 형식으로 R 프로그램을
실행하는데 사용될 수 있습니다.
</p>
<div class="display">
<pre class="display"><code>R</code> [<var>options</var>] [<code>&lt;</code><var>infile</var>] [<code>&gt;</code><var>outfile</var>],
</pre></div>

<p>또한, <code>R CMD</code>라는 인터페이스를 통하여 다양한 R 도구들 (즉, R의 문서형식으로 되어 있는 파일들을
프로세싱하거나 애드온 패키지들을 조작하는데 사용하기 위한 것들)을 직접 호출하지 않고도 사용할 수 있습니다.
</p>
<p>Windows 커맨드 라인에서는 <code>R</code>보다는 <code>Rterm.exe</code>를 이용하는 것을 선호합니다.
</p>
<p>환경 변수(environment variable) <code>TMPDIR</code>이 지정되지 않았거나, 임시 파일과 디렉토리 생성을 하는데
이용되는 공간을 올바르게 지정했는가에 대해서 확인하는 것이 필요합니다.
</p>
<p>대부분의 옵션들은 R 세션의 시작과 끝에서 어떤 것들을 해야하는가를 조절하게 됩니다. 스타트업 메카니즘 (startup
mechanism)은 다음과 같습니다 (더 많은 정보를 &lsquo;<samp>Startup</samp>&rsquo;이라는 주제와 관련한 온라인 도움말에서 찾아볼 수
있으며, 일부 Windows와 관련된 내용들은 아래의 섹션에서 찾아볼 수 있습니다).
</p>
<ul>
<li> <samp>--no-environ</samp>이라는 옵션이 주어지지 않는다면, R은 환경변수들을 설정하기 위한 작업을 진행하기 위해서
사용자와 사이트 파일들(user and site files)을 찾습니다.  사이트 파일의 이름은 환경변수 <code>R_ENVIRON</code>에
의해 지정됩니다. 만약, 이것이 설정되어 있지 않다면, <samp><var>R_HOME</var>/etc/Renviron.site</samp>이 이용됩니다
(만약 존재할 경우에 한합니다).사용자 파일은 <code>R_ENVIRON_USER</code>라는 환경변수가 설정되어 있다면 이 파일에 의해서
지정됩니다. 그렇지 않다면 현재 또는 사용자의 홈디렉토리내에 있는 <samp>.Renviron</samp>이라는 파일을 찾습니다.  이러한 파일들은
&lsquo;<samp><var>name</var>=<var>value</var></samp>&rsquo;이라는 형식을 가진 라인들을 포함해야 합니다. (구체적인 이해를 위해서
<code>help(&quot;Startup&quot;)</code>을 살펴보시길 바랍니다) 설정하고 싶은 변수들은 아마도 기본 페이퍼의 크기를 정하는
<code>R_PAPERSIZE</code>, 기본 프린터 명령을 정해주는 <code>R_PRINTCMD</code>, 그리고 애드온 패키지들을 찾는데 사용된
R 라이브러리 트리(library tree)들의 목록을 지정하는 <code>R_LIBS</code>가 있습니다. 

</li><li> 명령어 옵션 <samp>--no-site-file</samp>이 주어지지 않았다면, R은 사이트-와이드 스타트업 프로파일(site-wide
startup profile)을 찾습니다. 이 파일의 이름은 <code>R_PROFILE</code> 환경 변수의 값으로부터 얻을 수 있습니다. 만약
이 변수가 지정되지 않았다면 기본적으로 <samp><var>R_HOME</var>/etc/Rprofile.site</samp>이 이용됩니다 (만약
존재한다면).

</li><li> 만약 <samp>--no-init-file</samp>이 주어지지 않았다면 R은 사용자 프로파일(user profile)을 탐색 후 이를
읽어들이게 됩니다. 이 파일의 이름은 환경변수 <code>R_PROFILE_USER</code>로 부터 얻을 수 있습니다. 이것이 설정되지 않았다면,
현재 디렉토리에 있거나 사용자의 홈 디렉토리에 있는 <samp>.Rprofile</samp> 파일을 찾을 것입니다. 

</li><li> 또한, (<samp>--no-restore</samp> 또는 <samp>--no-restore-data</samp> 옵션이 지정되지 않았다면) 현재의
디렉토리에 <samp>.RData</samp> 파일로부터 저장된 작업공간을 불러올 수 있습니다. 

</li><li> 마지막으로 <code>.First()</code> 함수가 존재한다면, 이것은 실행될 것입니다. (R 세션의 끝부분에서 실행된
<code>.Last()</code>함수와 같이) 이 함수는 적절한 스타트업 프로파일들 내에 정의될 수 있습니다.  또는 <samp>.RData</samp>에
위치할 수도 있습니다. 
</li></ul>

<p>추가적으로 R 처리과정에 이용되는 메모리를 조절하는 옵션들이 있습니다. (더 많은 정보를 원하신다면 &lsquo;<samp>Memory</samp>&rsquo;와
관련된 온라인 도움말을 살펴보시길 바랍니다). R에 의하여 사용되는 메모리를 크기를 조절하고자 하지 않는다면 사용자는 이들을
사용해야 할 필요는 없습니다. 
</p>
<p>R은 다음과 같은 명령어 옵션들을 제공합니다.
</p>
<dl compact="compact">
<dt><samp>--help</samp></dt>
<dt><samp>-h</samp></dt>
<dd><p>표준 출력(standard output)으로 짧은 도움말 메시지를 보여주고 종료합니다. 
</p>
</dd>
<dt><samp>--version</samp></dt>
<dd><p>표준 출력(standard output)으로 버전정보를 표시해주고 종료합니다.
</p>
</dd>
<dt><samp>--encoding=<var>enc</var></samp></dt>
<dd><p><code>stdin</code> 또는 콘솔로부터의 입력에 사용될 인코딩(encoding)을 지정합니다. 이것은 <code>iconv</code>에서 사용될
수 있는 알려진 인코딩이어야 합니다. 도움말 페이지를 참고하시길 바랍니다. (<code>--encoding <var>enc</var></code>) 또한
사용될 수 있습니다. 
</p>
</dd>
<dt><samp>RHOME</samp></dt>
<dd><p>표준출력에 R &ldquo;home directory&rdquo; (홈디렉토리)의 경로를 보여주고 종료합니다.  사용자가 직접 작성하는 쉘
스크립트(shell script)와 도움말 페이지(man page)를 제외하고 실행이 가능한 파일들, 패키지 등 모두가 R이
설치되어 집니다. 
</p>
</dd>
<dt><samp>--save</samp></dt>
<dt><samp>--no-save</samp></dt>
<dd><p>R세션을 종료할때 데이터 셋들을 저장할 것인지에 대한 여부를 조절합니다. 
</p>
</dd>
<dt><samp>--no-environ</samp></dt>
<dd><p>환경변수를 설정하기 위한 어떠한 유저파일(user file)을 읽어들이지 않습니다.
</p>
</dd>
<dt><samp>--no-site-file</samp></dt>
<dd><p>스타트업(startup)에서 사이트-와이드 프로파일 (site-wide profile)을 읽어들이지 않습니다.
</p>
</dd>
<dt><samp>--no-init-file</samp></dt>
<dd><p>스타트업(startup)에서 사용자의 프로파일을 읽어들이지 않습니다. 
</p>
</dd>
<dt><samp>--restore</samp></dt>
<dt><samp>--no-restore</samp></dt>
<dt><samp>--no-restore-data</samp></dt>
<dd><p>스타트업(startup)할때 R이 시작된 디렉토리내에서 <samp>.RData</samp>의 형식으로 저장되어진 이미지들 복구할 것인지를
조절합니다. 기본값은 복구하는 것입니다. (<samp>--no-restore</samp>는 좀 더 세부적인
<samp>--no-restore-*</samp>과 같은 옵션들 모두를 의미합니다)
</p>
</dd>
<dt><samp>--no-restore-history</samp></dt>
<dd><p>R이 시작된 디렉토리내에 일반적으로 <samp>.Rhistory</samp>로 되어 있는 작업기록파일 (history file)을 스타트업
(startup)할때 복구할 것인지를 조절합니다. 이 파일은 환경변수 <code>R_HISTFILE</code>에 의해서 지정될 수도
있습니다. 기본값은 복구하는 것입니다. 
</p>
</dd>
<dt><samp>--no-Rconsole</samp></dt>
<dd><p>(Windows에만 적용되는 옵션입니다). 이는 스타트업시에 <samp>Rconsole</samp> 파일을 로딩하지 못하게 합니다.
</p>
</dd>
<dt><samp>--vanilla</samp></dt>
<dd><p><samp>--no-save</samp>, <samp>--no-environ</samp>, <samp>--no-site-file</samp>,
<samp>--no-init-file</samp>, <samp>--no-restore</samp>를 모두 한데 묶은 것입니다. Windows상에서는 이
옵션은 또한 <samp>--no-Rconsole</samp>을 포함합니다.
</p>
</dd>
<dt><samp>-f <var>file</var></samp></dt>
<dt><samp>--file=<var>file</var></samp></dt>
<dd><p>(<code>Rgui.exe</code>에 적용되지 않습니다). <var>file</var>로부터 입력을 가져옵니다: &lsquo;<samp>-</samp>&rsquo;은
<code>stdin</code>을 의미합니다. <samp>--save</samp>가 지정되지 않았다면 <samp>--no-save</samp>를 의미하게
됩니다. Unix와 같은 환경에서는 쉡 메타문자(shell metacharacters)는 <var>file</var>내에서 사용을 피해야
합니다. (그러나, R 2.14.0 부터 공백(spaces)들이 허용됩니다).
</p>
</dd>
<dt><samp>-e <var>expression</var></samp></dt>
<dd><p>(<code>Rgui.exe</code>에서는 사용할 수 없습니다). <var>expression</var>을 한줄의 입력라인 (input
line)으로 이용하세요.하나 또는 그 이상의 <samp>-e</samp> 옵션들이 사용될 수 있으나, <samp>-f</samp> 또는
<samp>--file</samp>과는 함께 사용할 수 없습니다. <samp>--save</samp>가 지정되어 있지 않다면
<samp>--no-svae</samp>을 의미하게 됩니다. (이러한 방식으로 expression 부분에 들어갈 수 있는 최대 길이는
10,000 바이트 입니다. 공백 또는 쉘 메타문자들을 포함하는 expressions들은 따옴표를 사용해야 할 필요가 있습니다)
</p>
</dd>
<dt><samp>--no-readline</samp></dt>
<dd><p>(UNIX에서만 사용됩니다) <strong>readline</strong>을 통해서 명령어줄(command-line)을 편집하는 것을 끕니다. 이것은
<acronym>ESS</acronym>(&ldquo;Emacs Speaks Statistics&rdquo;) 패키지를 이용하여 Emacs상에서 R을 실행할 때
유용합니다. 더 많은 정보를 원하시면 See <a href="#The-command_002dline-editor-_0028_ba85_b839_c5b4_b77c_c778-_d3b8_c9d1_ae30_0029">The command-line editor (명령어라인 편집기)</a>를 살펴보시길
바랍니다. 명령어라인 편집은 기본적으로 대화식으로 사용합니다. (<samp>--interactive</samp>를 살펴보세요). 이 옵션은 또한
틸데확장(tilde-expansion)에 영향을 미칩니다. 이것에 대해서는 <code>path.expand</code>에 대한 도움말을 살펴보시길
바랍니다.
</p>
</dd>
<dt><samp>--min-vsize=<var>N</var></samp></dt>
<dt><samp>--min-nsize=<var>N</var></samp></dt>
<dd><p>고급사용자들에게만 권장됩니다. 바이트단위의 벡터 힙(vector heap)과 <em>cons cells</em> (numbers)에 대한
가비지 컬렉션 (garbage collection)에 대한 초기 트리거 크기 (initial trigger sizes)를
설정합니다. 접미사 &lsquo;<samp>M</samp>&rsquo;은 메가바이트 (megabytes)또는 수백만개의 셀 (millions of cells)을
지정합니다.기본값은 6Mb 와 350k 입니다. 
</p>
</dd>
<dt><samp>--max-ppsize=<var>N</var></samp></dt>
<dd><p><var>N</var>위치만큼 해당하는 포인터 프로텍션 스택(pointer protection stack)의 최대 크기를 지정합니다. 기본값은
10000이지만, 대규모의 복잡한 연산을 위하여 증가될 수 있습니다. 현재의 최대값은 100000입니다.
</p>
</dd>
<dt><samp>--max-mem-size=<var>N</var></samp></dt>
<dd><p>(Windows에만 해당합니다) R객체들과 작업영역을 위해 사용되는 메모리의 양의 한계를 지정합니다. 기본적으로 이는 R
32-비트를 기준으로 물리적인 RAM의 크기보다 작은 1.5Gb<a name="DOCF25" href="#FOOT25"><sup>25</sup></a>로 지정되어
있습니다.  이는 반드시 32Mb와 Windows의 해당버전에서 허용하는 최고치 사이어야 합니다. 
</p>
</dd>
<dt><samp>--quiet</samp></dt>
<dt><samp>--silent</samp></dt>
<dt><samp>-q</samp></dt>
<dd><p>실행 초기에 보여지는 카피라이트(copyright)와 환영 메시지를 보여주지 않습니다.
</p>
</dd>
<dt><samp>--slave</samp></dt>
<dd><p>R를 가능한 조용히 실행합니다. 이 옵션은 R을 이용하여 연산을 수행하는 프로그램을 지원하기 위한 목적으로
존재합니다. <samp>--quiet</samp>와 <samp>--no-save</samp>를 의미합니다.
</p>
</dd>
<dt><samp>--interactive</samp></dt>
<dd><p>(UNIX에서만 사용가능합니다) 입력의 방향이 설정되어 있을지라도 R이 대화식으로 사용되도록 하게 합니다. (기본적으로
<samp>stdin</samp>이 터미널(terminal) 또는 <code>pty</code>에 연결되어 있을 때 R은 대화식으로 실행되도록 되어
있습니다). 만약 <samp>--interactive</samp>이 주어져 있을지라도, <samp>-e</samp>, <samp>-f</samp>, 또는
<samp>--file</samp>은 비대화식 모드로 사용하게 됩니다.
</p>
<p>Note that this does not turn on command-line editing.
</p>
</dd>
<dt><samp>--ess</samp></dt>
<dd><p>(Windows만 가능합니다) 명령어를 이용한 에디터 사용없이 대화식으로 사용할 수 있는 기능을 포함하여 <acronym>ESS</acronym> 내에서
<code>R-inferior-mode</code>에 의해서 사용할 수 있도록 <code>Rterm</code>을 지정합니다. 
</p>
</dd>
<dt><samp>--verbose</samp></dt>
<dd><p>진행과정에 대한 정보를 출력하고, 특히 R의 옵션 <code>verbose</code>를 <code>TRUE</code>로 지정합니다. R 코드는
이 옵션을 이용하여 진단 메시지 (diagnostic message)의 출력을 조정하게 됩니다. 
</p>
</dd>
<dt><samp>--debugger=<var>name</var></samp></dt>
<dt><samp>-d <var>name</var></samp></dt>
<dd><p>(UNIX에서만 이용이 가능합니다). <var>name</var>이라는 이름의 디버거(debugger)를 통해 R을
실행합니다. <code>valgrind</code>와 최신버전의 <code>gdb</code>를 제외한 대부분의 디버거들에서, 추가적인 명령어 라인
옵션 (command line options)들이 무시되는 대신에 R이 실행될 때 디버거 내에서 실행이 가능합니다. 
</p>
</dd>
<dt><samp>--gui=<var>type</var></samp></dt>
<dt><samp>-g <var>type</var></samp></dt>
<dd><p>(UNIX에서만 이용가능합니다) 그래픽 사용자 환경으로서 <var>type</var>을 이용합니다 (이것은 대화식 기능의 그래픽 또한
포함합니다). 현재 <var>type</var>에서 사용가능한 값들은 기본적으로 &lsquo;<samp>X11</samp>&rsquo;이며, &lsquo;<samp>Tcl/Tk</samp>&rsquo;가 지원된다는
가정하에 &lsquo;<samp>Tk</samp>&rsquo;입니다. (back-compatibility를 위해서 &lsquo;<samp>x11</samp>&rsquo;과 &lsquo;<samp>tk</samp>&rsquo;도 사용될 수
있습니다).
</p>
</dd>
<dt><samp>--arch=<var>name</var></samp></dt>
<dd><p>(UNIX only) Run the specified sub-architecture.
</p>
</dd>
<dt><samp>--args</samp></dt>
<dd><p>이 플래그(flag)는 커맨드라인의 남은 부분을 건너뛰도록 유도하는 것을 제외하면 다른 기능은 없습니다.
<code>commandArgs(TRUE)</code>와 함께 값을 검색 또는 다시 불러오는데 유용합니다. 
</p></dd>
</dl>

<p>&lsquo;<samp>&lt;</samp>&rsquo;와 &lsquo;<samp>&gt;</samp>&rsquo;를 이용하여 일반적인 방법으로 입력과 출력의 방향을 조절할 수 있으나, 라인의 길인에 대한 4095
바이트의 제한은 여전히 적용되게 됩니다.  경고와 에러메시들이 에러 채널인 <code>stderr</code>로 보내어지게 됩니다. 
</p>
<p>명령어 <code>R CMD</code>는 R과 함께 사용될 수 있는 유용한 도구들을 실행시키도록 해줍니다. 그러나 이것은 직접적으로
실행시키기 보다는 다음과 같은 일반적인 형식을 가집니다. 
</p>
<div class="example">
<pre class="example">R CMD <var>command</var> <var>args</var>
</pre></div>

<p>여기에서 <var>command</var>는 도구의 이름이고 <var>args</var>는 그 도구에 넘겨지게 될 입력인자들을 의미합니다.
</p>
<p>현재, 다음과 같은 도구들을 사용할 수 있습니다. 
</p>
<dl compact="compact">
<dt><code>BATCH</code></dt>
<dd><p>R을 배치모드(batch mode)에서 실행시킵니다. <code>R --restore --save</code>와 추가적인 옵션들을 이용할
수 있습니다. (<code>?BATCH</code>를 참조하기 바랍니다).
</p></dd>
<dt><code>COMPILE</code></dt>
<dd><p>(UNIX에서만 사용할 수 있습니다) R과 함께 사용할 수 있는 C, C++, Fortran &hellip; 파일들을 컴파일합니다. 
</p></dd>
<dt><code>SHLIB</code></dt>
<dd><p>다이나믹 로딩을 위하여 공유된 라이브러리 (shared library)를 빌드(build)합니다.
</p></dd>
<dt><code>INSTALL</code></dt>
<dd><p>애드온(add-on) 패키지들을 설치합니다.
</p></dd>
<dt><code>REMOVE</code></dt>
<dd><p>애드온(add-on) 패키지들을 제거합니다.
</p></dd>
<dt><code>build</code></dt>
<dd><p>애드온(add-on) 패키지들을 빌드(build)합니다.
</p></dd>
<dt><code>check</code></dt>
<dd><p>애드온(add-on) 패키지들을 체크(check)합니다.
</p></dd>
<dt><code>LINK</code></dt>
<dd><p>(UNIX에서만 사용가능합니다) 실행가능한 프로그램을 생성하기 위하여 전처리 (front-end)입니다. 
</p></dd>
<dt><code>Rprof</code></dt>
<dd><p>Post-process R profiling files.
</p></dd>
<dt><code>Rdconv</code></dt>
<dt><code>Rd2txt</code></dt>
<dd><p>Rd 포맷을 <acronym>HTML</acronym>, LaTex, 일반 텍스트, 그리고 예제들을 추출하는 등 다양한 포맷으로
전환합니다. <code>Rd2txt</code>는 <code>Rd2conv -t txt</code>의 약식 표기입니다.
</p></dd>
<dt><code>Rd2pdf</code></dt>
<dd><p>Rd 포맷을 PDF로 전환합니다.
</p></dd>
<dt><code>Stangle</code></dt>
<dd><p>Sweave 문서로부터 S/R 코드를 추출합니다.
</p></dd>
<dt><code>Sweave</code></dt>
<dd><p>Sweave 문서를 프로세스 합니다.
</p></dd>
<dt><code>Rdiff</code></dt>
<dd><p>Diff R output ignoring headers etc
</p></dd>
<dt><code>config</code></dt>
<dd><p>환경설정에 대한 정보 (configuration information)을 가져옵니다.
</p></dd>
<dt><code>javareconf</code></dt>
<dd><p>(UNIX에서만 사용가능합니다) Java 설정 변수들을 업데이트 합니다.
</p></dd>
<dt><code>rtags</code></dt>
<dd><p>(UNIX에서만 사용가능합니다) C, R, 그리고 Rd 파일들로부터 이맥스 (Emacs)스타일의 태그 파일들을 생성합니다.
</p></dd>
<dt><code>open</code></dt>
<dd><p>(Windows에서만 사용가능합니다)  Windows의 파일연결(file association)을 이용하여 파일을 엽니다.
</p></dd>
<dt><code>texify</code></dt>
<dd><p>(Windows에서만 사용가능합니다)  R 스타일 파일을 사용하는 (La)TeX 파일들을 프로세싱합니다.
</p></dd>
</dl>

<p>Use
</p>
<div class="example">
<pre class="example">R CMD <var>command</var> --help
</pre></div>

<p><code>R CMD</code>를 통하여 사용이 가능한 도구들의 각각에 대한 사용방법을 알고 싶을 때는 다음과 같이 입력하세요. 
</p>
<p>추가적으로 도구들에 의해 실행되는 어떠한 R 프로세스들에 영향을 미칠 수 있는 <samp>--arch=</samp>,
<samp>--no-environ</samp>, <samp>--no-init-file</samp>, <samp>--no-site-file</samp> 그리고
<samp>--vanilla</samp> 옵션들을 <code>R</code>과 <code>CMD</code> 사이에 사용<a name="DOCF26" href="#FOOT26"><sup>26</sup></a>할 수 있습니다. (여기에서 <samp>--vanilla</samp>는 <samp>--no-environ
--no-site-file --no-init-file</samp>과 동일합니다.)그러나, <code>R CMD</code> 이 자체로는 어떠한 R
스타드업 파일들을 사용하지 않는다는 것을 알고 계셔야 합니다 (특히, 사용자 또는 사이트 <samp>Renviron</samp> 파일 모두 이용하지
않습니다). 그리고, <code>BATCH</code>를 제외한 이러한 도구들에 의해서 실행되는 R 프로세스들의 모두는
<samp>--no-restore</samp>를 사용합니다. 대부분은 <samp>--vanilla</samp>를 사용하고 R 스타트업 파일들을
작동시키지 않습니다. 현재 예외라고 할 수 있는 것들은 <code>INSTALL</code>, <code>REMOVE</code>,
<code>Sweave</code> 그리고 (<samp>--no-site-file --no-init-file</samp>을 이용하고 있는)
<code>SHLIB</code> 입니다. 절대경로 (absolute filepath)에 의해서 주어진 또는 해당경로상에 있는 어떠한 다른
실행가능한 <code><var>cmd</var></code>을 사용하기 위해서는 아래와 같이 사용합니다. 
</p>
<div class="example">
<pre class="example">R CMD <var>cmd</var> <var>args</var>
</pre></div>

<p>이렇게 하는 것은 R 또는 <code>ldd</code> 또는  <code>pdflatex</code>와 같은 어떤 특정한 명령어가
수행되어져야 하는 환경을 동일하게 해주는데 유용합니다. Windows 상에서 <var>cmd</var>는 실행이 가능할 수도 있고 배치파일
(batch file)일수도 있으며, 만약 <code>.sh</code> 또는 <code>.pl</code>과 같은 확장자를 가진다면 적합한
인터프리터(interpreter)가 이들을 실행시키기 위해서 호출되어집니다.
</p>

<hr>
<a name="Invoking-R-under-Windows"></a>
<a name="Invoking-R-under-Windows-1"></a>
<h3 class="appendixsec">B.2 Invoking R under Windows</h3>

<p>Windows에서 R을 실행하는 방법은 두 가지가 있습니다. <code>cmd.exe</code> 또는 이보다 좀 더 많은 기능들을 가지고
있는 쉘과 같은 터미널을 보여주는 윈도우 내에서는 이전 섹션에서 설명한 방법들이 사용될 수 있는데, 이는 <code>R.exe</code> 또는
<code>Rterm.exe</code>를 실행하는 것입니다. 대화식으로 사용하기 위해서는 콘솔기반의 그래픽 사용자 환경인
<code>Rgui.exe</code>가 있습니다. 
</p>
<p>Windows 상에서 스타트업 방식은 UNIX와 유사하지만, &rsquo;home directory&rsquo; (홈디렉토리)에 대한 참조는
Windows상에서 항상 정의되는 것이 아니기 때문에 좀 더 명확히 정해줘야 합니다.환경변수(environment variable)
<code>R_USER</code>을 정의하는 것은 홈디렉토리를 지정하는 것입니다.또한, 환경변수 <code>HOME</code>을 정의하는 것 역시 홈디렉토리를
정하는 것입니다.사용자가 조절할 수 있는 이 두 변수들이 설정되면, R은 홈디렉토리를 지정하는 시스템을 찾으려고 합니다. 제일먼저,
Windows 개인 디렉토리 (일반적으로 Windows XP의 경우에는 <code>C:\Documents and
Settings\username\My Documents</code>를 의미합니다)를 지정합니다.실패시에는 환경변수 <code>HOMEDRIVE</code>와
<code>HOMEPATH</code>가 지정하는 홈디렉토리를 사용하게 됩니다. 이 모든 과정이 실패할 경우에 홈디렉토리는 스타팅 디렉토리로 정해지게
됩니다. 
</p>
<p>환경변수 <code>TMPDIR</code>, <code>TMP</code> 혹은 <code>TEMP</code>가 결정되지 않거나, 이 둘 중 하나가 일시적인 파일 혹은
디렉토리 생성을 위한 유효한 공간을 지정하게 끔 설정해야 합니다.
</p>
<p>환경변수들은 명령어 라인에서 &lsquo;<samp><var>name</var>=<var>value</var></samp>&rsquo;와 같은 형식으로 제공됩니다.
</p>
<p>만약 어떠한 경우에라도 <samp>.RData</samp>로 끝나는 인자가 있다면, 이것은 불러오게 될 작업공간에 대한 경로로서
인식되어집니다.이것은 <samp>--restore</samp>를 의미하는 것이고, 주어진 이름을 가진 파일의 상위디렉토리에 대한 작업 디렉토리를
지정하는 것이기 때문입니다.(이러한 메카니즘은 드래그-앤-드랍(drag-and-drop)과 <code>RGui.exe</code>와 사용되는
파일연결(file association)을 위해 사용됩니다.  그러나, 또한 <code>Rterm.exe</code>를 위해 사용되기도
합니다. 만약 주어진 이름을 가진 파일이 존재하지 않는다면 이것은 작업디렉토리를 부모디렉토리가 있을경우에 지정하게 됩니다).
</p>
<p><code>RGui.exe</code>를 작동시킬때 다음과 같은 추가적인 명령어 옵션들이 이용가능합니다. 
</p>
<dl compact="compact">
<dt><samp>--mdi</samp></dt>
<dt><samp>--sdi</samp></dt>
<dt><samp>--no-mdi</samp></dt>
<dd><p><code>Rgui</code>가 하나의 주 윈도우 상에 여러 개의 작은 윈도우 창을 이용하는 MDI 프로그램 혹은 콘솔, 그래픽, 또는 페이저를
위한 다수의 최상의 윈도우들을 가진 SDI 어플리케이션으로 사용할 것인지를 조절합니다. 명령어라인을 이용한 설정은 사용자의
<samp>Rconsole</samp> 파일에 있는 설정을 덮어쓰게 됩니다.
</p>
</dd>
<dt><samp>--debug</samp></dt>
<dd><p><code>Rgui</code>내에서 &ldquo;Break to debugger&rdquo;라는 메뉴 항목을 이용할 수 있게 해주고, 커맨드 라인이 프로세싱되는
동안 디버거에게 브레이크를 작동시켜줍니다. 
</p></dd>
</dl>

<p>Windows에서 <code>R CMD</code>를 이용할 때 당신이 소유한  <samp>.bat</samp>, <samp>.exe</samp>, <samp>.sh</samp>
또는 <samp>.pl</samp> 파일들 또한 지정할 수 있습니다. 이것은 적합한 인터프리터 (즉, <samp>.pl</samp>파일은 Perl을
이용합니다)와 <code>R_HOME</code>, <code>R_OSTYPE</code>, <code>PATH</code>, <code>BSTINPUTS</code>, 그리고
<code>TEXINPUTS</code>를 포함하여 올바르게 지정된 여러가지의 환경변수들과 함께 실행될 것입니다. 예를들면, 당신의 경로에
<samp>latex.exe</samp>파일을 이미 가지고 있다면 아래와 같이 방법으로 <code>TEXINPUTS</code>에 추가되어 있는 R의
<samp>share/texmf</samp> 매크로를 이용하여 <samp>mydoc.tex</samp>에 대해서 LaTeX를  실행시킬 수 있습니다. 
</p>
<div class="example">
<pre class="example">R CMD latex.exe mydoc
</pre></div>
<p>(안타깝게도, MiKTex LaTeX에서는 적용되지 않습니다. 그러나, <code>R CMD texify mydoc</code>은 작동할
것입니다.)
</p>
<hr>
<a name="Invoking-R-under-OS-X"></a>
<a name="Invoking-R-under-OS-X-1"></a>
<h3 class="appendixsec">B.3 Invoking R under OS X</h3>

<p>Mac OS X 상에서 R을 실행하는 방법에는 두가지가 있습니다. 첫 번째 서브섹션에서 설명된 방법처럼
<code>Terminal.app</code> 창을 이용하여 <code>R</code>을 작동하는 것입니다. 또 다른 방법은 당신의 시스템에 있는
<code>Applications</code> 폴더에 기본적으로 설치된 콘솔기반의 GUI (<code>R.app</code>)을 이용하는것입니다. 이것은
더블클릭이 가능한 Mac OS X 응용프로그램입니다.
</p>
<p>Mac OS X에 있는 스타트업 프로시져는 유닉스의 것과 유사합니다. &lsquo;home directory&rsquo; 는 R.framework 내부에
있지만, GUI내로부터 접근이 가능한 Preference 창에 있는 스타트업 디렉토이와 다르지 않다면 스타트업과 현재 작업디렉토리는
사용자의 홈디렉토리와 같이 지정됩니다.
</p>
<hr>
<a name="Scripting-with-R"></a>
<a name="Scripting-with-R-1"></a>
<h3 class="appendixsec">B.4 Scripting with R</h3>

<p>만약에 R 명령어들로 이루어진 <samp>foo.R</samp>라는 파일을 실행시키고자 한다면,  <code>R CMD BATCH
foo.R</code>를 사용하길 권장합니다. 만약 당신이 이를 일괄처리 (batch job) 작업으로서 또는 후순위 작업 (background
job, 백그라운드 작업)를 하고자 한다면, 당신의 운영체제에 맞는 기능을 사용하길 바랍니다. 예를들면, 유닉스와 같은 운영체제들은
쉘상에서 <code>R CMD BATCH foo.R&amp;</code>라고 입력하게 되면 후순위작업 (background job)이 실행되게
됩니다. 
</p>
<p>명령어 라인을 사용할때 추가적인 인자들을 이용하여 스크립트에 파미미터 (또는 입력해야 할 인자들)에 값을 넣어줄 수 있습니다. 예를들면
(어떤 쉘을 이용하는가에 따라 다르지만, 아래와 같이 큰 따옴표의 사용이 필요합니다).
</p>
<div class="example">
<pre class="example">R CMD BATCH &quot;--args arg1 arg2&quot; foo.R &amp;
</pre></div>

<p>위에서 사용된 명령어 라인은 아래와 같은 방법으로 다시 확인할 수 있는 문자형 벡터로서 스크립트에 인자들을 넘겨줄 수 있습니다. 
</p>
<div class="example">
<pre class="example">args &lt;- commandArgs(TRUE)
</pre></div>

<p>이렇게 하는 것은 사용자가 직접 아래와 같이 <code>Rscript</code>에 인자들을 전달할 수 있는 더 간단한 방법입니다. 
</p>
<div class="example">
<pre class="example">Rscript foo.R arg1 arg2
</pre></div>

<p>그리고 이렇게 하는 것은 (적어도 유닉스와 같은 환경 및 일부 Windows의 쉘상에서) 실행가능한 스크립트를 작성하는데 사용될 수
있습니다.  예를들면, 아래와 같습니다. 
</p>
<div class="example">
<pre class="example">#! /path/to/Rscript
args &lt;- commandArgs(TRUE)
...
q(status=&lt;exit status code&gt;)
</pre></div>

<p>만약에 <samp>runfoo</samp>라는 텍스트 파일에 입력하고, 이것을 <code>chmod 755 runfoo</code>라는 명령어를 이용하여
실행가능하게 만들어 준다면, 아래와 같이 실행도 가능합니다. 
</p>
<div class="example">
<pre class="example">runfoo arg1 arg2
</pre></div>

<p>더 많은 옵션들을 알아보고 싶으시다면 <code>help(&quot;Rscript&quot;)</code>를 살펴보시길 바랍니다. 이것은 R의 결과물을
<samp>stdout</samp>과 <samp>stderr</samp>에 작성합니다.  그리고 이것은 명령어를 실행시키는 쉘상에서 일반적인 방법으로 다른
방향으로 전환이 가능합니다. 
</p>
<p>만약 당신이 <code>Rscript</code>에 경로를 쉽게 변경하고자 하면, 이를 아래와 같이 경로를 적어두어야
합니다. (Windows를 제외한 경우 설치된 R의 일반적인 경우이지만  Mac OS X 사용자들은 아마도
<samp>/usr/local/bin</samp> 이라고 할 수도 있습니다).
</p>
<div class="example">
<pre class="example">#! /usr/bin/env Rscript
...
</pre></div>

<p>본(Bourne)과 bash(배쉬) 쉘상에서는 <code>#!</code> 메카니즘은 <code>#! /usr/bin/env Rscript
--vanilla</code>와 같은 추가적인 인자의 사용을 허용하지 않습니다.
</p>
<p>한 가지 고려해야 할 점은 <code>stdin()</code>이 무엇을 의미하는지 알아야 합니다. R 스크립트를 아래와 같이 작성하는 것은
매우 흔한일입니다.
</p>
<div class="example">
<pre class="example">chem &lt;- scan(n=24)
2.90 3.10 3.40 3.40 3.70 3.70 2.80 2.50 2.40 2.40 2.70 2.20
5.28 3.37 3.03 3.03 28.95 3.77 3.40 2.20 3.50 3.60 3.70 3.70
</pre></div>

<p>여기에서 <code>stdin()</code>이란 기존의 사용방법을 허용하는 스크립트 파일 자체를 의미합니다. 프로세스의 <samp>stdin</samp>을
참조하고 싶다면, <code>&quot;stdin&quot;</code>을 <code>file</code> 커넥션과 같이 사용하시면 됩니다. 즉, 
<code>scan(&quot;stdin&quot;, ...)</code>.
</p>
<p>또다른 방법으로 실행가능한 스크립트 파일들을 만드는 방법들은 (Fran&ccedil;ois Pinard에 의해 제안된) <em>이곳의
문서</em>와 같이 사용하는 것입니다. 
</p>
<div class="example">
<pre class="example">#!/bin/sh
[environment variables can be set here]
R --slave [other options] &lt;&lt;EOF

   R program goes here...

EOF
</pre></div>

<p>그러나, 여기에서 <code>stdin()</code>은 프로그램 소스를 가리키며 <code>&quot;stdin&quot;</code>은 사용가능하지 않을 것입니다. 
</p>
<p>매우 짧은 길이의 스크립트는 <samp>-e</samp> 플래그를 이용하여 <code>Rscript</code>에 보낼 수도 있습니다. 
</p>
<p>유닉스와 같은 환경에서 <samp>foo.R</samp>와 같은 입력파일명은 반드시 공간을 포함해서도 안되며, 쉘의 메타문자 역시 포함해서는
안됩니다. 
</p>

<hr>
<a name="The-command_002dline-editor-_0028_ba85_b839_c5b4_b77c_c778-_d3b8_c9d1_ae30_0029"></a>
<a name="The-command_002dline-editor-_0028myeongryeongeorain-pyeonjibgi_0029"></a>
<h2 class="appendix">Appendix C The command-line editor (명령어라인 편집기)</h2>

<a name="Preliminaries"></a>
<h3 class="appendixsection">C.1 Preliminaries</h3>

<p>UNIX 상에서 컴파일을 위하여 R의 환경설정을 할때 <acronym>GNU</acronym> <strong>readline</strong> 라이브러리가 사용가능
할 때, 이전 명령어들의 기억기능(recall), 편집(editing), 그리고 재입력(resubmission) 기능을 허용하는 내재된
커맨드기반의 에디터가 이용됩니다. 다른 버전의 <strong>readline</strong>이 존재 할 수 있고, 이들이 내재된 커맨드 기반의 명령어에
의해서 사용될 수도 있습니다.보통 Mac OS X에서 이러합니다
</p>
<p>스타트업 옵션 <samp>--no-readline</samp>을 이용하여 사용되지 않도록 할 수도 있습니다. (이렇게 하는 것은
<acronym>ESS</acronym><a name="DOCF27" href="#FOOT27"><sup>27</sup></a>를 사용할 때 유용합니다).
</p>
<p>Windows 버전에서 R은 다소 간단한 형식의 커맨드라인 편집기능을 가지고 있습니다. <acronym>GUI</acronym>에서
&lsquo;<samp>Help</samp>&rsquo; 메뉴에 있는 &lsquo;<samp>Console</samp>&rsquo;을 살펴보시고, <code>Rterm.exe</code>내에 있는 커맨드라인을 위한 파일
<samp>README.Rterm</samp>을 살펴보시길 바랍니다.
</p>
<p><strong>readline</strong>의 기능과 함께 R을 사용할 때, (아마도) 당신의 시스템에 있는 <code>man
readline</code> 또는 <code>info readline</code>에 기술되어 있는 함수들과 아래에 기술된 함수들을 이용할 수 있습니다.
</p>
<p>이들중의 많은 것들이 컨트롤 (Control)과 메타(Meta) 문자들을 사용합니다. <kbd>Control-m</kbd>과 같은 형식으로 컨트롤
문자들은 <tt class="key">CTRL</tt>키를 누른 상태에서 <tt class="key">m</tt>키를 누르는 것입니다.그리고 이것을 <kbd>C-m</kbd>이라고
표시합니다.<kbd>Meta-b</kbd>와 같이 메타문자들은 <tt class="key">META</tt><a name="DOCF28" href="#FOOT28"><sup>28</sup></a>를 누른 상태에서
<tt class="key">b</tt>를 누르는 것이며, 이는 <kbd>M-b</kbd>라고 씁니다.만약에 당신의 터미널이 활성화된 <tt class="key">META</tt>키를 가지고 있지
않다면, 당신은 <kbd>ESC</kbd>를 사용하여 메타문자들을 입력할 수 있습니다.그러므로, <kbd>M-b</kbd>를 입력하기 위해서는, 당신은
<tt class="key">ESC</tt><tt class="key">b</tt>라고 입력합니다.다음은 중요한 메타 문자들을 정리한 것입니다. 
</p>
<a name="Editing-actions"></a>
<h3 class="appendixsection">C.2 Editing actions</h3>

<p>R 프로그램은 당신이 입력한 명령어 라인들에 대한 기록을 보관합니다. 이때 잘못 입력한 명령어도 보관이 되며, 기록상에 보관된
명령어들은 다시 불러올 수 있고, 필요하다면 변경하여, 새로운 명령어처럼 다시 사용될 수 있습니다. 이맥스
스타일(Emacs-style)의 명령어라인 편집환경에서는 당신이 입력하는 것들이 편집하는 명령어 속에 삽입되거나, 커서의 오른쪽에 있는
문자들을 변경하하기도 합니다. <em>vi</em> 모드에서는 <tt class="key">ESC</tt>를 입력함으로서 문자가 입력되거나 삽입모드를 종료할 수
있습니다. (기본적으로는 이맥스 스타일이 사용되며, <em>vi</em> 모드에 대해서는 <strong>readline</strong> 문서를 확인하시길
바랍니다).
</p>
<p>어떤 상황이던지 간에 <tt class="key">RET</tt>키를 누르는 것은 명령어를 실행하도록 전달하는 것과 같습니다. 
</p>
<p>다른 편집 기능들은 아래의 표에 정리되어 있습니다.
</p>
<p>커맨드라인 에디터에 대한 요약 
</p>
<a name="keoseoyi-sanghaidongeul-tonghayeo-myeongryeongeoreul-doebureugi"></a>
<h4 class="subheading">커서의 상하이동을 통하여 명령어를 되부르기</h4>

<dl compact="compact">
<dt><kbd>C-p</kbd></dt>
<dd><p>이전에 사용한 명령어로 이동합니다 (히스토리 상에서 한 단계 뒤로 이동하는 것입니다).
</p></dd>
<dt><kbd>C-n</kbd></dt>
<dd><p>다음 명령어로 이동합니다 (히스토리상에서 한 단계 다음으로 이동하는 것입니다).
</p></dd>
<dt><kbd>C-r <var>text</var></kbd></dt>
<dd><p><var>text</var>를 포함하는 마지막 명령어를 찾습니다.
</p></dd>
</dl>

<p>대부분의 터미널에서 <kbd>C-p</kbd>와 <kbd>C-n</kbd>를 이용하는 대신에 당신은 위쪽 또는 아래쪽 방향의 화살표를 이용하여 이를 이용할
수 있습니다. 
</p>
<a name="keoseoreul-jwauro-idonghayeo-hal-su-issneun-myeongryeongeodeul"></a>
<h4 class="subheading">커서를 좌우로 이동하여 할 수 있는 명령어들</h4>

<dl compact="compact">
<dt><kbd>C-a</kbd></dt>
<dd><p>명령어의 가장 처음으로 이동합니다.
</p></dd>
<dt><kbd>C-e</kbd></dt>
<dd><p>라인의 끝으로 이동합니다. 
</p></dd>
<dt><kbd>M-b</kbd></dt>
<dd><p>한 단어 뒤로 이동합니다.
</p></dd>
<dt><kbd>M-f</kbd></dt>
<dd><p>한 단어 앞으로 이동합니다. 
</p></dd>
<dt><kbd>C-b</kbd></dt>
<dd><p>한 문자 뒤로 이동합니다.
</p></dd>
<dt><kbd>C-f</kbd></dt>
<dd><p>한 문자 앞으로 이동합니다. 
</p></dd>
</dl>

<p>대부분의 터미널에서는 당신은 <kbd>C-b</kbd>와 <kbd>C-f</kbd>를 이용하는 대신에 좌측 또는 우측 화살표를 이용할 수 있습니다. 
</p>
<a name="pyeonjib-hu-jaesilhaenghagi"></a>
<h4 class="subheading">편집 후 재실행하기</h4>

<dl compact="compact">
<dt><kbd><var>text</var></kbd></dt>
<dd><p>커서의 위치에 <var>text</var> 삽입합니다.
</p></dd>
<dt><kbd>C-f <var>text</var></kbd></dt>
<dd><p>커서의 위치 다음부분 부터 <var>text</var>를 추가합니다.
</p></dd>
<dt><kbd><span class="key">DEL</span></kbd></dt>
<dd><p>커서의 왼쪽에 위한 문자를 삭제합니다
</p></dd>
<dt><kbd>C-d</kbd></dt>
<dd><p>커서의 바로 아래 있는 문자를 삭제합니다. 
</p></dd>
<dt><kbd>M-d</kbd></dt>
<dd><p>커서의 아래에 있는 위치하는 문자 이후의 모든 것을 삭제하고 &ldquo;저장&rdquo; 합니다. 
</p></dd>
<dt><kbd>C-k</kbd></dt>
<dd><p>커서의 위치로부터 명령어의 끝 부분까지 삭제한 뒤, &ldquo;저장&rdquo; 합니다.
</p></dd>
<dt><kbd>C-y</kbd></dt>
<dd><p>마지막으로 저장된 텍스트를 이곳에 삽입니다. 
</p></dd>
<dt><kbd>C-t</kbd></dt>
<dd><p>다음 문자를 커서 아래에 있는 문자와 전치합니다.
</p></dd>
<dt><kbd>M-l</kbd></dt>
<dd><p>단어의 남겨진 부분들을 소문자로 변경합니다.
</p></dd>
<dt><kbd>M-c</kbd></dt>
<dd><p>단어의 남겨진 부분들을 대문자로 변경합니다. 
</p></dd>
<dt><kbd><span class="key">RET</span></kbd></dt>
<dd><p>R에 명령어를 다시 전달합니다.
</p></dd>
</dl>

<p>마지막 <tt class="key">RET</tt> 키는 명령어 라인의 편집 시퀀스를 종료하는 것입니다.
</p>
<p><strong>Readline</strong> 키바인딩 (key binding)은  <samp>~/.inputrc</samp> 파일을 <em>통해서</em> 일반적인
방법으로 조정될 수 있습니다.  R 2.12.0 부터는 이러한 개인설정 (customization)은 <code>R</code>에 따라
조건적일 수 있습니다. 
</p>
<div class="example">
<pre class="example">$if R
  &quot;\C-xd&quot;: &quot;q('no')\n&quot;
$endif
</pre></div>

<hr>
<a name="g_t_d568_c218-_bc0f-_bcc0_c218_c640-_ad00_b828_b41c-_c0c9_c778"></a>
<a name="hamsu-mic-byeonsuwa-gwanryeondoen-saegin"></a>
<h2 class="appendix">Appendix D 함수 및 변수와 관련된 색인</h2>

<table><tr><th valign="top">Jump to: &nbsp; </th><td><a class="summary-letter" href="#g_t_d568_c218-_bc0f-_bcc0_c218_c640-_ad00_b828_b41c-_c0c9_c778_vr_symbol-1"><b>!</b></a>
 &nbsp; 
<a class="summary-letter" href="#g_t_d568_c218-_bc0f-_bcc0_c218_c640-_ad00_b828_b41c-_c0c9_c778_vr_symbol-2"><b>%</b></a>
 &nbsp; 
<a class="summary-letter" href="#g_t_d568_c218-_bc0f-_bcc0_c218_c640-_ad00_b828_b41c-_c0c9_c778_vr_symbol-3"><b>&amp;</b></a>
 &nbsp; 
<a class="summary-letter" href="#g_t_d568_c218-_bc0f-_bcc0_c218_c640-_ad00_b828_b41c-_c0c9_c778_vr_symbol-4"><b>*</b></a>
 &nbsp; 
<a class="summary-letter" href="#g_t_d568_c218-_bc0f-_bcc0_c218_c640-_ad00_b828_b41c-_c0c9_c778_vr_symbol-5"><b>+</b></a>
 &nbsp; 
<a class="summary-letter" href="#g_t_d568_c218-_bc0f-_bcc0_c218_c640-_ad00_b828_b41c-_c0c9_c778_vr_symbol-6"><b>-</b></a>
 &nbsp; 
<a class="summary-letter" href="#g_t_d568_c218-_bc0f-_bcc0_c218_c640-_ad00_b828_b41c-_c0c9_c778_vr_symbol-7"><b>.</b></a>
 &nbsp; 
<a class="summary-letter" href="#g_t_d568_c218-_bc0f-_bcc0_c218_c640-_ad00_b828_b41c-_c0c9_c778_vr_symbol-8"><b>/</b></a>
 &nbsp; 
<a class="summary-letter" href="#g_t_d568_c218-_bc0f-_bcc0_c218_c640-_ad00_b828_b41c-_c0c9_c778_vr_symbol-9"><b>:</b></a>
 &nbsp; 
<a class="summary-letter" href="#g_t_d568_c218-_bc0f-_bcc0_c218_c640-_ad00_b828_b41c-_c0c9_c778_vr_symbol-10"><b>&lt;</b></a>
 &nbsp; 
<a class="summary-letter" href="#g_t_d568_c218-_bc0f-_bcc0_c218_c640-_ad00_b828_b41c-_c0c9_c778_vr_symbol-11"><b>=</b></a>
 &nbsp; 
<a class="summary-letter" href="#g_t_d568_c218-_bc0f-_bcc0_c218_c640-_ad00_b828_b41c-_c0c9_c778_vr_symbol-12"><b>&gt;</b></a>
 &nbsp; 
<a class="summary-letter" href="#g_t_d568_c218-_bc0f-_bcc0_c218_c640-_ad00_b828_b41c-_c0c9_c778_vr_symbol-13"><b>?</b></a>
 &nbsp; 
<a class="summary-letter" href="#g_t_d568_c218-_bc0f-_bcc0_c218_c640-_ad00_b828_b41c-_c0c9_c778_vr_symbol-14"><b>^</b></a>
 &nbsp; 
<a class="summary-letter" href="#g_t_d568_c218-_bc0f-_bcc0_c218_c640-_ad00_b828_b41c-_c0c9_c778_vr_symbol-15"><b>|</b></a>
 &nbsp; 
<a class="summary-letter" href="#g_t_d568_c218-_bc0f-_bcc0_c218_c640-_ad00_b828_b41c-_c0c9_c778_vr_symbol-16"><b>~</b></a>
 &nbsp; 
<br>
<a class="summary-letter" href="#g_t_d568_c218-_bc0f-_bcc0_c218_c640-_ad00_b828_b41c-_c0c9_c778_vr_letter-A"><b>A</b></a>
 &nbsp; 
<a class="summary-letter" href="#g_t_d568_c218-_bc0f-_bcc0_c218_c640-_ad00_b828_b41c-_c0c9_c778_vr_letter-B"><b>B</b></a>
 &nbsp; 
<a class="summary-letter" href="#g_t_d568_c218-_bc0f-_bcc0_c218_c640-_ad00_b828_b41c-_c0c9_c778_vr_letter-C"><b>C</b></a>
 &nbsp; 
<a class="summary-letter" href="#g_t_d568_c218-_bc0f-_bcc0_c218_c640-_ad00_b828_b41c-_c0c9_c778_vr_letter-D"><b>D</b></a>
 &nbsp; 
<a class="summary-letter" href="#g_t_d568_c218-_bc0f-_bcc0_c218_c640-_ad00_b828_b41c-_c0c9_c778_vr_letter-E"><b>E</b></a>
 &nbsp; 
<a class="summary-letter" href="#g_t_d568_c218-_bc0f-_bcc0_c218_c640-_ad00_b828_b41c-_c0c9_c778_vr_letter-F"><b>F</b></a>
 &nbsp; 
<a class="summary-letter" href="#g_t_d568_c218-_bc0f-_bcc0_c218_c640-_ad00_b828_b41c-_c0c9_c778_vr_letter-G"><b>G</b></a>
 &nbsp; 
<a class="summary-letter" href="#g_t_d568_c218-_bc0f-_bcc0_c218_c640-_ad00_b828_b41c-_c0c9_c778_vr_letter-H"><b>H</b></a>
 &nbsp; 
<a class="summary-letter" href="#g_t_d568_c218-_bc0f-_bcc0_c218_c640-_ad00_b828_b41c-_c0c9_c778_vr_letter-I"><b>I</b></a>
 &nbsp; 
<a class="summary-letter" href="#g_t_d568_c218-_bc0f-_bcc0_c218_c640-_ad00_b828_b41c-_c0c9_c778_vr_letter-J"><b>J</b></a>
 &nbsp; 
<a class="summary-letter" href="#g_t_d568_c218-_bc0f-_bcc0_c218_c640-_ad00_b828_b41c-_c0c9_c778_vr_letter-K"><b>K</b></a>
 &nbsp; 
<a class="summary-letter" href="#g_t_d568_c218-_bc0f-_bcc0_c218_c640-_ad00_b828_b41c-_c0c9_c778_vr_letter-L"><b>L</b></a>
 &nbsp; 
<a class="summary-letter" href="#g_t_d568_c218-_bc0f-_bcc0_c218_c640-_ad00_b828_b41c-_c0c9_c778_vr_letter-M"><b>M</b></a>
 &nbsp; 
<a class="summary-letter" href="#g_t_d568_c218-_bc0f-_bcc0_c218_c640-_ad00_b828_b41c-_c0c9_c778_vr_letter-N"><b>N</b></a>
 &nbsp; 
<a class="summary-letter" href="#g_t_d568_c218-_bc0f-_bcc0_c218_c640-_ad00_b828_b41c-_c0c9_c778_vr_letter-O"><b>O</b></a>
 &nbsp; 
<a class="summary-letter" href="#g_t_d568_c218-_bc0f-_bcc0_c218_c640-_ad00_b828_b41c-_c0c9_c778_vr_letter-P"><b>P</b></a>
 &nbsp; 
<a class="summary-letter" href="#g_t_d568_c218-_bc0f-_bcc0_c218_c640-_ad00_b828_b41c-_c0c9_c778_vr_letter-Q"><b>Q</b></a>
 &nbsp; 
<a class="summary-letter" href="#g_t_d568_c218-_bc0f-_bcc0_c218_c640-_ad00_b828_b41c-_c0c9_c778_vr_letter-R"><b>R</b></a>
 &nbsp; 
<a class="summary-letter" href="#g_t_d568_c218-_bc0f-_bcc0_c218_c640-_ad00_b828_b41c-_c0c9_c778_vr_letter-S"><b>S</b></a>
 &nbsp; 
<a class="summary-letter" href="#g_t_d568_c218-_bc0f-_bcc0_c218_c640-_ad00_b828_b41c-_c0c9_c778_vr_letter-T"><b>T</b></a>
 &nbsp; 
<a class="summary-letter" href="#g_t_d568_c218-_bc0f-_bcc0_c218_c640-_ad00_b828_b41c-_c0c9_c778_vr_letter-U"><b>U</b></a>
 &nbsp; 
<a class="summary-letter" href="#g_t_d568_c218-_bc0f-_bcc0_c218_c640-_ad00_b828_b41c-_c0c9_c778_vr_letter-V"><b>V</b></a>
 &nbsp; 
<a class="summary-letter" href="#g_t_d568_c218-_bc0f-_bcc0_c218_c640-_ad00_b828_b41c-_c0c9_c778_vr_letter-W"><b>W</b></a>
 &nbsp; 
<a class="summary-letter" href="#g_t_d568_c218-_bc0f-_bcc0_c218_c640-_ad00_b828_b41c-_c0c9_c778_vr_letter-X"><b>X</b></a>
 &nbsp; 
</td></tr></table>
<table class="index-vr" border="0">
<tr><td></td><th align="left">Index Entry</th><td>&nbsp;</td><th align="left"> Section</th></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="g_t_d568_c218-_bc0f-_bcc0_c218_c640-_ad00_b828_b41c-_c0c9_c778_vr_symbol-1">!</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-_0021"><code>!</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t_b17c_b9ac_d615-_bca1_d130">논리형 벡터</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_0021_003d"><code>!=</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t_b17c_b9ac_d615-_bca1_d130">논리형 벡터</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="g_t_d568_c218-_bc0f-_bcc0_c218_c640-_ad00_b828_b41c-_c0c9_c778_vr_symbol-2">%</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-_0025_002a_0025"><code>%*%</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Multiplication">Multiplication</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_0025o_0025"><code>%o%</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t_b450-_bc30_c5f4_c758-_c678_c801">두 배열의 외적</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="g_t_d568_c218-_bc0f-_bcc0_c218_c640-_ad00_b828_b41c-_c0c9_c778_vr_symbol-3">&amp;</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-_0026"><code>&amp;</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t_b17c_b9ac_d615-_bca1_d130">논리형 벡터</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_0026_0026"><code>&amp;&amp;</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Conditional-execution">Conditional execution</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="g_t_d568_c218-_bc0f-_bcc0_c218_c640-_ad00_b828_b41c-_c0c9_c778_vr_symbol-4">*</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002a"><code>*</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t_bca1_d130-_c5f0_c0b0">벡터 연산</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="g_t_d568_c218-_bc0f-_bcc0_c218_c640-_ad00_b828_b41c-_c0c9_c778_vr_symbol-5">+</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002b"><code>+</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t_bca1_d130-_c5f0_c0b0">벡터 연산</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="g_t_d568_c218-_bc0f-_bcc0_c218_c640-_ad00_b828_b41c-_c0c9_c778_vr_symbol-6">-</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002d"><code>-</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t_bca1_d130-_c5f0_c0b0">벡터 연산</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="g_t_d568_c218-_bc0f-_bcc0_c218_c640-_ad00_b828_b41c-_c0c9_c778_vr_symbol-7">.</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002e"><code>.</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Updating-fitted-models">Updating fitted models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002eFirst"><code>.First</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t_d658_acbd-_c124_c815_d558_ae30">환경 설정하기</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002eLast"><code>.Last</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t_d658_acbd-_c124_c815_d558_ae30">환경 설정하기</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="g_t_d568_c218-_bc0f-_bcc0_c218_c640-_ad00_b828_b41c-_c0c9_c778_vr_symbol-8">/</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002f"><code>/</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t_bca1_d130-_c5f0_c0b0">벡터 연산</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="g_t_d568_c218-_bc0f-_bcc0_c218_c640-_ad00_b828_b41c-_c0c9_c778_vr_symbol-9">:</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-_003a"><code>:</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Generating-regular-sequences-_0028_addc_ce59_c131_c744-_c9c0_b2cc-_c77c_b828_c758-_c22b_c790_b4e4_c744-_c0dd_c131_d558_ae30_0029">Generating regular sequences (규칙성을 지닌 일련의 숫자들을 생성하기)</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_003a_003a"><code>::</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t_b124_c784_c2a4_d398_c774_c2a4-_0028Namespaces_0029">네임스페이스 (Namespaces)</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_003a_003a_003a"><code>:::</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t_b124_c784_c2a4_d398_c774_c2a4-_0028Namespaces_0029">네임스페이스 (Namespaces)</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="g_t_d568_c218-_bc0f-_bcc0_c218_c640-_ad00_b828_b41c-_c0c9_c778_vr_symbol-10">&lt;</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-_003c"><code>&lt;</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t_b17c_b9ac_d615-_bca1_d130">논리형 벡터</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_003c_003c_002d"><code>&lt;&lt;-</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Scope-_0028_c2a4_cf54_d504_0029">Scope (스코프)</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_003c_003d"><code>&lt;=</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t_b17c_b9ac_d615-_bca1_d130">논리형 벡터</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="g_t_d568_c218-_bc0f-_bcc0_c218_c640-_ad00_b828_b41c-_c0c9_c778_vr_symbol-11">=</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-_003d_003d"><code>==</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t_b17c_b9ac_d615-_bca1_d130">논리형 벡터</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="g_t_d568_c218-_bc0f-_bcc0_c218_c640-_ad00_b828_b41c-_c0c9_c778_vr_symbol-12">&gt;</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-_003e"><code>&gt;</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t_b17c_b9ac_d615-_bca1_d130">논리형 벡터</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_003e_003d"><code>&gt;=</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t_b17c_b9ac_d615-_bca1_d130">논리형 벡터</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="g_t_d568_c218-_bc0f-_bcc0_c218_c640-_ad00_b828_b41c-_c0c9_c778_vr_symbol-13">?</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-_003f"><code>?</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t_b3c4_c6c0_b9d0-_ae30_b2a5-_c0ac_c6a9_d558_ae30">도움말 기능 사용하기</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_003f_003f"><code>??</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t_b3c4_c6c0_b9d0-_ae30_b2a5-_c0ac_c6a9_d558_ae30">도움말 기능 사용하기</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="g_t_d568_c218-_bc0f-_bcc0_c218_c640-_ad00_b828_b41c-_c0c9_c778_vr_symbol-14">^</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-_005e"><code>^</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t_bca1_d130-_c5f0_c0b0">벡터 연산</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="g_t_d568_c218-_bc0f-_bcc0_c218_c640-_ad00_b828_b41c-_c0c9_c778_vr_symbol-15">|</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-_007c"><code>|</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t_b17c_b9ac_d615-_bca1_d130">논리형 벡터</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_007c_007c"><code>||</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Conditional-execution">Conditional execution</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="g_t_d568_c218-_bc0f-_bcc0_c218_c640-_ad00_b828_b41c-_c0c9_c778_vr_symbol-16">~</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-_007e"><code>~</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t_c2dd_0028formulae_0029_c744-_d1b5_d55c-_d1b5_acc4_baa8_d615_c758-_c815_c758">식(formulae)을 통한 통계모형의 정의</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="g_t_d568_c218-_bc0f-_bcc0_c218_c640-_ad00_b828_b41c-_c0c9_c778_vr_letter-A">A</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-abline"><code>abline</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Low_002dlevel-plotting-commands">Low-level plotting commands</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ace"><code>ace</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Some-non_002dstandard-models">Some non-standard models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-add1"><code>add1</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Updating-fitted-models">Updating fitted models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-anova"><code>anova</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Generic-functions-for-extracting-model-information">Generic functions for extracting model information</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-anova-1"><code>anova</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#ANOVA-tables">ANOVA tables</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-aov"><code>aov</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Analysis-of-variance-and-model-comparison">Analysis of variance and model comparison</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-aperm"><code>aperm</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t_bc30_c5f4_c758-_c804_ce58_c5d0-_c0ac_c6a9_b418_b294-_c77c_bc18_d654_b41c-_bc29_bc95">배열의 전치에 사용되는 일반화된 방법</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-array"><code>array</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#array_0028_0029-_d568_c218">array() 함수</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-as_002edata_002eframe"><code>as.data.frame</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t_b370_c774_d130-_d504_b808_c784-_c0dd_c131_d558_ae30">데이터 프레임 생성하기</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-as_002evector"><code>as.vector</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t_bc30_c5f4_c5d0-_c0ac_c6a9_b418_b294-_acb0_d569_d568_c218-c_0028_0029">배열에 사용되는 결합함수 c()</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-attach"><code>attach</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#attach_0028_0029_c640-detach_0028_0029">attach()와 detach()</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-attr"><code>attr</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Getting-and-setting-attributes-_0028_c18d_c131_c744-_c124_c815_d558_ace0-_d655_c778_d558_ae30_0029">Getting and setting attributes (속성을 설정하고 확인하기)</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-attr-1"><code>attr</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Getting-and-setting-attributes-_0028_c18d_c131_c744-_c124_c815_d558_ace0-_d655_c778_d558_ae30_0029">Getting and setting attributes (속성을 설정하고 확인하기)</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-attributes"><code>attributes</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Getting-and-setting-attributes-_0028_c18d_c131_c744-_c124_c815_d558_ace0-_d655_c778_d558_ae30_0029">Getting and setting attributes (속성을 설정하고 확인하기)</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-attributes-1"><code>attributes</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Getting-and-setting-attributes-_0028_c18d_c131_c744-_c124_c815_d558_ace0-_d655_c778_d558_ae30_0029">Getting and setting attributes (속성을 설정하고 확인하기)</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-avas"><code>avas</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Some-non_002dstandard-models">Some non-standard models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-axis"><code>axis</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Low_002dlevel-plotting-commands">Low-level plotting commands</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="g_t_d568_c218-_bc0f-_bcc0_c218_c640-_ad00_b828_b41c-_c0c9_c778_vr_letter-B">B</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-boxplot"><code>boxplot</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t_c77c_d45c_bcf8_acfc-_c774_d45c_bcf8-_ac80_c815">일표본과 이표본 검정</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-break"><code>break</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Repetitive-execution">Repetitive execution</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-bruto"><code>bruto</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Some-non_002dstandard-models">Some non-standard models</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="g_t_d568_c218-_bc0f-_bcc0_c218_c640-_ad00_b828_b41c-_c0c9_c778_vr_letter-C">C</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-c"><code>c</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t_bca1_d130_c640-_d560_b2f9">벡터와 할당</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-c-1"><code>c</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t_bb38_c790_d615-_bca1_d130">문자형 벡터</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-c-2"><code>c</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t_bc30_c5f4_c5d0-_c0ac_c6a9_b418_b294-_acb0_d569_d568_c218-c_0028_0029">배열에 사용되는 결합함수 c()</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-c-3"><code>c</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Concatenating-lists-_0028_b9ac_c2a4_d2b8-_c5f0_acb0_d558_ae30_0029">Concatenating lists (리스트 연결하기)</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-C"><code>C</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Contrasts">Contrasts</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-cbind"><code>cbind</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Forming-partitioned-matrices">Forming partitioned matrices</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-coef"><code>coef</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Generic-functions-for-extracting-model-information">Generic functions for extracting model information</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-coefficients"><code>coefficients</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Generic-functions-for-extracting-model-information">Generic functions for extracting model information</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-contour"><code>contour</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Display-graphics">Display graphics</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-contrasts"><code>contrasts</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Contrasts">Contrasts</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-coplot"><code>coplot</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Displaying-multivariate-data">Displaying multivariate data</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-cos"><code>cos</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t_bca1_d130-_c5f0_c0b0">벡터 연산</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-crossprod"><code>crossprod</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Index-matrices-_0028_c778_b371_c2a4-_d589_b82c_0029">Index matrices (인덱스 행렬)</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-crossprod-1"><code>crossprod</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Multiplication">Multiplication</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-cut"><code>cut</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t_c694_c778_c744-_c774_c6a9_d558_c5ec-_b3c4_c218_bd84_d3ec_d45c-_c0dd_c131_d558_ae30">요인을 이용하여 도수분포표 생성하기</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="g_t_d568_c218-_bc0f-_bcc0_c218_c640-_ad00_b828_b41c-_c0c9_c778_vr_letter-D">D</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-data"><code>data</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t_b0b4_c7a5_b41c-_b370_c774_d130_c14b_c744-_c774_c6a9_d558_ae30">내장된 데이터셋을 이용하기</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-data_002eframe"><code>data.frame</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t_b370_c774_d130-_d504_b808_c784-_c0dd_c131_d558_ae30">데이터 프레임 생성하기</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-density"><code>density</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t_b370_c774_d130_c758-_bd84_d3ec-_c0b4_d3b4_bcf4_ae30">데이터의 분포 살펴보기</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-det"><code>det</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t_d2b9_c774_ac12-_bd84_d574-_bc0f-_d589_b82c_c2dd">특이값 분해 및 행렬식</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-detach"><code>detach</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#attach_0028_0029_c640-detach_0028_0029">attach()와 detach()</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-determinant"><code>determinant</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t_d2b9_c774_ac12-_bd84_d574-_bc0f-_d589_b82c_c2dd">특이값 분해 및 행렬식</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-dev_002elist"><code>dev.list</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t_b2e4_c218_c758-_adf8_b798_d53d-_b514_bc14_c774_c2a4-_0028graphic-devices_0029">다수의 그래픽 디바이스 (graphic devices)</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-dev_002enext"><code>dev.next</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t_b2e4_c218_c758-_adf8_b798_d53d-_b514_bc14_c774_c2a4-_0028graphic-devices_0029">다수의 그래픽 디바이스 (graphic devices)</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-dev_002eoff"><code>dev.off</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t_b2e4_c218_c758-_adf8_b798_d53d-_b514_bc14_c774_c2a4-_0028graphic-devices_0029">다수의 그래픽 디바이스 (graphic devices)</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-dev_002eprev"><code>dev.prev</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t_b2e4_c218_c758-_adf8_b798_d53d-_b514_bc14_c774_c2a4-_0028graphic-devices_0029">다수의 그래픽 디바이스 (graphic devices)</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-dev_002eset"><code>dev.set</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t_b2e4_c218_c758-_adf8_b798_d53d-_b514_bc14_c774_c2a4-_0028graphic-devices_0029">다수의 그래픽 디바이스 (graphic devices)</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-deviance"><code>deviance</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Generic-functions-for-extracting-model-information">Generic functions for extracting model information</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-diag"><code>diag</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Multiplication">Multiplication</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-dim"><code>dim</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t_bc30_c5f4">배열</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-dotchart"><code>dotchart</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Display-graphics">Display graphics</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-drop1"><code>drop1</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Updating-fitted-models">Updating fitted models</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="g_t_d568_c218-_bc0f-_bcc0_c218_c640-_ad00_b828_b41c-_c0c9_c778_vr_letter-E">E</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-ecdf"><code>ecdf</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t_b370_c774_d130_c758-_bd84_d3ec-_c0b4_d3b4_bcf4_ae30">데이터의 분포 살펴보기</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-edit"><code>edit</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t_b370_c774_d130_b97c-_d3b8_c9d1_d558_ae30">데이터를 편집하기</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-eigen"><code>eigen</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t_ace0_c720_ac12_acfc-_ace0_c720_bca1_d130">고유값과 고유벡터</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-else"><code>else</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Conditional-execution">Conditional execution</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Error"><code>Error</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Analysis-of-variance-and-model-comparison">Analysis of variance and model comparison</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-example"><code>example</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t_b3c4_c6c0_b9d0-_ae30_b2a5-_c0ac_c6a9_d558_ae30">도움말 기능 사용하기</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-exp"><code>exp</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t_bca1_d130-_c5f0_c0b0">벡터 연산</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="g_t_d568_c218-_bc0f-_bcc0_c218_c640-_ad00_b828_b41c-_c0c9_c778_vr_letter-F">F</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-F"><code>F</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t_b17c_b9ac_d615-_bca1_d130">논리형 벡터</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-factor"><code>factor</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Factors-_0028_c694_c778_0029">Factors (요인)</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-FALSE"><code>FALSE</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t_b17c_b9ac_d615-_bca1_d130">논리형 벡터</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-fivenum"><code>fivenum</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t_b370_c774_d130_c758-_bd84_d3ec-_c0b4_d3b4_bcf4_ae30">데이터의 분포 살펴보기</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-for"><code>for</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Repetitive-execution">Repetitive execution</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-formula"><code>formula</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Generic-functions-for-extracting-model-information">Generic functions for extracting model information</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-function"><code>function</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Writing-your-own-functions-_0028_c0ac_c6a9_c790-_c815_c758_d568_c218-_c791_c131_d558_ae30_0029">Writing your own functions (사용자 정의함수 작성하기)</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="g_t_d568_c218-_bc0f-_bcc0_c218_c640-_ad00_b828_b41c-_c0c9_c778_vr_letter-G">G</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-getAnywhere"><code>getAnywhere</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Object-orientation-_0028_ac1d_ccb4_c9c0_d5a5_c801-_bc29_bc95_0029">Object orientation (객체지향적 방법)</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-getS3method"><code>getS3method</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Object-orientation-_0028_ac1d_ccb4_c9c0_d5a5_c801-_bc29_bc95_0029">Object orientation (객체지향적 방법)</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-glm"><code>glm</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#The-glm_0028_0029-function">The glm() function</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="g_t_d568_c218-_bc0f-_bcc0_c218_c640-_ad00_b828_b41c-_c0c9_c778_vr_letter-H">H</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-help"><code>help</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t_b3c4_c6c0_b9d0-_ae30_b2a5-_c0ac_c6a9_d558_ae30">도움말 기능 사용하기</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-help-1"><code>help</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t_b3c4_c6c0_b9d0-_ae30_b2a5-_c0ac_c6a9_d558_ae30">도움말 기능 사용하기</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-help_002esearch"><code>help.search</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t_b3c4_c6c0_b9d0-_ae30_b2a5-_c0ac_c6a9_d558_ae30">도움말 기능 사용하기</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-help_002estart"><code>help.start</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t_b3c4_c6c0_b9d0-_ae30_b2a5-_c0ac_c6a9_d558_ae30">도움말 기능 사용하기</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-hist"><code>hist</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t_b370_c774_d130_c758-_bd84_d3ec-_c0b4_d3b4_bcf4_ae30">데이터의 분포 살펴보기</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-hist-1"><code>hist</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Display-graphics">Display graphics</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="g_t_d568_c218-_bc0f-_bcc0_c218_c640-_ad00_b828_b41c-_c0c9_c778_vr_letter-I">I</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-identify"><code>identify</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Interacting-with-graphics">Interacting with graphics</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-if"><code>if</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Conditional-execution">Conditional execution</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-if-1"><code>if</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Conditional-execution">Conditional execution</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ifelse"><code>ifelse</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Conditional-execution">Conditional execution</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-image"><code>image</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Display-graphics">Display graphics</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-is_002ena"><code>is.na</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t_acb0_ce21_ac12">결측값</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-is_002enan"><code>is.nan</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t_acb0_ce21_ac12">결측값</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="g_t_d568_c218-_bc0f-_bcc0_c218_c640-_ad00_b828_b41c-_c0c9_c778_vr_letter-J">J</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-jpeg"><code>jpeg</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Device-drivers">Device drivers</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="g_t_d568_c218-_bc0f-_bcc0_c218_c640-_ad00_b828_b41c-_c0c9_c778_vr_letter-K">K</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-ks_002etest"><code>ks.test</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t_b370_c774_d130_c758-_bd84_d3ec-_c0b4_d3b4_bcf4_ae30">데이터의 분포 살펴보기</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="g_t_d568_c218-_bc0f-_bcc0_c218_c640-_ad00_b828_b41c-_c0c9_c778_vr_letter-L">L</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-legend"><code>legend</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Low_002dlevel-plotting-commands">Low-level plotting commands</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-length"><code>length</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t_bca1_d130-_c5f0_c0b0">벡터 연산</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-length-1"><code>length</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#The-intrinsic-attributes-mode-and-length">The intrinsic attributes mode and length</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-levels"><code>levels</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Factors-_0028_c694_c778_0029">Factors (요인)</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-lines"><code>lines</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Low_002dlevel-plotting-commands">Low-level plotting commands</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-list"><code>list</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Lists-_0028_b9ac_c2a4_d2b8_0029">Lists (리스트)</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-lm"><code>lm</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Linear-models">Linear models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-lme"><code>lme</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Some-non_002dstandard-models">Some non-standard models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-locator"><code>locator</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Interacting-with-graphics">Interacting with graphics</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-loess"><code>loess</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Some-non_002dstandard-models">Some non-standard models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-loess-1"><code>loess</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Some-non_002dstandard-models">Some non-standard models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-log"><code>log</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t_bca1_d130-_c5f0_c0b0">벡터 연산</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-lqs"><code>lqs</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Some-non_002dstandard-models">Some non-standard models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-lsfit"><code>lsfit</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t_cd5c_c18c_c81c_acf1_bc95_acfc-QR-_bd84_d574_bc95">최소제곱법과 QR 분해법</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="g_t_d568_c218-_bc0f-_bcc0_c218_c640-_ad00_b828_b41c-_c0c9_c778_vr_letter-M">M</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-mars"><code>mars</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Some-non_002dstandard-models">Some non-standard models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-max"><code>max</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t_bca1_d130-_c5f0_c0b0">벡터 연산</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mean"><code>mean</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t_bca1_d130-_c5f0_c0b0">벡터 연산</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-methods"><code>methods</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Object-orientation-_0028_ac1d_ccb4_c9c0_d5a5_c801-_bc29_bc95_0029">Object orientation (객체지향적 방법)</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-min"><code>min</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t_bca1_d130-_c5f0_c0b0">벡터 연산</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-mode"><code>mode</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#The-intrinsic-attributes-mode-and-length">The intrinsic attributes mode and length</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="g_t_d568_c218-_bc0f-_bcc0_c218_c640-_ad00_b828_b41c-_c0c9_c778_vr_letter-N">N</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-NA"><code>NA</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t_acb0_ce21_ac12">결측값</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-NaN"><code>NaN</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t_acb0_ce21_ac12">결측값</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ncol"><code>ncol</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t_d589_b82c_c758-_ae30_b2a5_b4e4">행렬의 기능들</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-next"><code>next</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Repetitive-execution">Repetitive execution</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-nlm"><code>nlm</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Nonlinear-least-squares-and-maximum-likelihood-models">Nonlinear least squares and maximum likelihood models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-nlm-1"><code>nlm</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Least-squares">Least squares</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-nlm-2"><code>nlm</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Maximum-likelihood">Maximum likelihood</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-nlme"><code>nlme</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Some-non_002dstandard-models">Some non-standard models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-nlminb"><code>nlminb</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Nonlinear-least-squares-and-maximum-likelihood-models">Nonlinear least squares and maximum likelihood models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-nrow"><code>nrow</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t_d589_b82c_c758-_ae30_b2a5_b4e4">행렬의 기능들</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="g_t_d568_c218-_bc0f-_bcc0_c218_c640-_ad00_b828_b41c-_c0c9_c778_vr_letter-O">O</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-optim"><code>optim</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Nonlinear-least-squares-and-maximum-likelihood-models">Nonlinear least squares and maximum likelihood models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-order"><code>order</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t_bca1_d130-_c5f0_c0b0">벡터 연산</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ordered"><code>ordered</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t_c21c_c11c_d615-_c694_c778">순서형 요인</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ordered-1"><code>ordered</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t_c21c_c11c_d615-_c694_c778">순서형 요인</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-outer"><code>outer</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t_b450-_bc30_c5f4_c758-_c678_c801">두 배열의 외적</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="g_t_d568_c218-_bc0f-_bcc0_c218_c640-_ad00_b828_b41c-_c0c9_c778_vr_letter-P">P</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-pairs"><code>pairs</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Displaying-multivariate-data">Displaying multivariate data</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-par"><code>par</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#The-par_0028_0029-function">The par() function</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-paste"><code>paste</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t_bb38_c790_d615-_bca1_d130">문자형 벡터</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-pdf"><code>pdf</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Device-drivers">Device drivers</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-persp"><code>persp</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Display-graphics">Display graphics</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-plot"><code>plot</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Generic-functions-for-extracting-model-information">Generic functions for extracting model information</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-plot-1"><code>plot</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#The-plot_0028_0029-function">The plot() function</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-pmax"><code>pmax</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t_bca1_d130-_c5f0_c0b0">벡터 연산</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-pmin"><code>pmin</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t_bca1_d130-_c5f0_c0b0">벡터 연산</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-png"><code>png</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Device-drivers">Device drivers</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-points"><code>points</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Low_002dlevel-plotting-commands">Low-level plotting commands</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-polygon"><code>polygon</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Low_002dlevel-plotting-commands">Low-level plotting commands</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-postscript"><code>postscript</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Device-drivers">Device drivers</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-predict"><code>predict</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Generic-functions-for-extracting-model-information">Generic functions for extracting model information</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-print"><code>print</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Generic-functions-for-extracting-model-information">Generic functions for extracting model information</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-prod"><code>prod</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t_bca1_d130-_c5f0_c0b0">벡터 연산</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="g_t_d568_c218-_bc0f-_bcc0_c218_c640-_ad00_b828_b41c-_c0c9_c778_vr_letter-Q">Q</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-qqline"><code>qqline</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t_b370_c774_d130_c758-_bd84_d3ec-_c0b4_d3b4_bcf4_ae30">데이터의 분포 살펴보기</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-qqline-1"><code>qqline</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Display-graphics">Display graphics</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-qqnorm"><code>qqnorm</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t_b370_c774_d130_c758-_bd84_d3ec-_c0b4_d3b4_bcf4_ae30">데이터의 분포 살펴보기</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-qqnorm-1"><code>qqnorm</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Display-graphics">Display graphics</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-qqplot"><code>qqplot</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Display-graphics">Display graphics</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-qr"><code>qr</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t_cd5c_c18c_c81c_acf1_bc95_acfc-QR-_bd84_d574_bc95">최소제곱법과 QR 분해법</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-quartz"><code>quartz</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Device-drivers">Device drivers</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="g_t_d568_c218-_bc0f-_bcc0_c218_c640-_ad00_b828_b41c-_c0c9_c778_vr_letter-R">R</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-rangeneun-jueojin-begteo-xyi-modeun-guseongyoso-jung-coesogabsgwa-coedaegabseul-c_0028min_0028x_0029_002c-max_0028x_0029_0029yi-hyeongtaero-culryeoghamyeo_002c-ireum-geudaero-begteo-byeonsuyi-beomwireul-guhal-ddae-sayong-habnida_002e"><code><code>range</code>는 주어진 벡터 <code>x</code>의 모든 구성요소 중 최소값과 최대값을 <code>c(min(x), max(x))</code>의 형태로 출력하며, 이름 그대로 벡터 변수의 범위를 구할 때 사용 합니다.</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t_bca1_d130-_c5f0_c0b0">벡터 연산</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-rbind"><code>rbind</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Forming-partitioned-matrices">Forming partitioned matrices</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-read_002etable"><code>read.table</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#The-read_002etable_0028_0029-function">The read.table() function</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-rep"><code>rep</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Generating-regular-sequences-_0028_addc_ce59_c131_c744-_c9c0_b2cc-_c77c_b828_c758-_c22b_c790_b4e4_c744-_c0dd_c131_d558_ae30_0029">Generating regular sequences (규칙성을 지닌 일련의 숫자들을 생성하기)</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-repeat"><code>repeat</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Repetitive-execution">Repetitive execution</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-resid"><code>resid</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Generic-functions-for-extracting-model-information">Generic functions for extracting model information</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-residuals"><code>residuals</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Generic-functions-for-extracting-model-information">Generic functions for extracting model information</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-rlm"><code>rlm</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Some-non_002dstandard-models">Some non-standard models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-rm"><code>rm</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t_c601_ad6c_c801-_b370_c774_d130-_c0dd_c131-_bc0f-_ac1d_ccb4_c758-_c81c_ac70">영구적 데이터 생성 및 객체의 제거</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="g_t_d568_c218-_bc0f-_bcc0_c218_c640-_ad00_b828_b41c-_c0c9_c778_vr_letter-S">S</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-scan"><code>scan</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#The-scan_0028_0029-function">The scan() function</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-sd"><code>sd</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#The-function-tapply_0028_0029-and-ragged-arrays">The function tapply() and ragged arrays</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-search"><code>search</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t_d0d0_c0c9_acbd_b85c_b97c-_ad00_b9ac_d558_ae30">탐색경로를 관리하기</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-seq"><code>seq</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Generating-regular-sequences-_0028_addc_ce59_c131_c744-_c9c0_b2cc-_c77c_b828_c758-_c22b_c790_b4e4_c744-_c0dd_c131_d558_ae30_0029">Generating regular sequences (규칙성을 지닌 일련의 숫자들을 생성하기)</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-shapiro_002etest"><code>shapiro.test</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t_b370_c774_d130_c758-_bd84_d3ec-_c0b4_d3b4_bcf4_ae30">데이터의 분포 살펴보기</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-sin"><code>sin</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t_bca1_d130-_c5f0_c0b0">벡터 연산</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-sink"><code>sink</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t_d30c_c77c_c5d0-_c791_c131_b41c-_ba85_b839_c5b4_b97c-_c2e4_d589_d558_ac70_b098-_cd9c_b825_bc29_d5a5_c744-_d30c_c77c_b85c-_bcc0_acbd_d558_ae30">파일에 작성된 명령어를 실행하거나 출력방향을 파일로 변경하기</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-solve"><code>solve</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t_c120_d615_bc29_c815_c2dd_acfc-_c5ed_d589_b82c">선형방정식과 역행렬</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-sort"><code>sort</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t_bca1_d130-_c5f0_c0b0">벡터 연산</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-source"><code>source</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t_d30c_c77c_c5d0-_c791_c131_b41c-_ba85_b839_c5b4_b97c-_c2e4_d589_d558_ac70_b098-_cd9c_b825_bc29_d5a5_c744-_d30c_c77c_b85c-_bcc0_acbd_d558_ae30">파일에 작성된 명령어를 실행하거나 출력방향을 파일로 변경하기</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-split"><code>split</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Repetitive-execution">Repetitive execution</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-sqrt"><code>sqrt</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t_bca1_d130-_c5f0_c0b0">벡터 연산</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-stem"><code>stem</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t_b370_c774_d130_c758-_bd84_d3ec-_c0b4_d3b4_bcf4_ae30">데이터의 분포 살펴보기</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-step"><code>step</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Generic-functions-for-extracting-model-information">Generic functions for extracting model information</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-step-1"><code>step</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Updating-fitted-models">Updating fitted models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-sum"><code>sum</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t_bca1_d130-_c5f0_c0b0">벡터 연산</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-summary"><code>summary</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t_b370_c774_d130_c758-_bd84_d3ec-_c0b4_d3b4_bcf4_ae30">데이터의 분포 살펴보기</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-summary-1"><code>summary</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Generic-functions-for-extracting-model-information">Generic functions for extracting model information</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-svd"><code>svd</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t_d2b9_c774_ac12-_bd84_d574-_bc0f-_d589_b82c_c2dd">특이값 분해 및 행렬식</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="g_t_d568_c218-_bc0f-_bcc0_c218_c640-_ad00_b828_b41c-_c0c9_c778_vr_letter-T">T</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-T"><code>T</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t_b17c_b9ac_d615-_bca1_d130">논리형 벡터</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-t"><code>t</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t_bc30_c5f4_c758-_c804_ce58_c5d0-_c0ac_c6a9_b418_b294-_c77c_bc18_d654_b41c-_bc29_bc95">배열의 전치에 사용되는 일반화된 방법</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-t_002etest"><code>t.test</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t_c77c_d45c_bcf8_acfc-_c774_d45c_bcf8-_ac80_c815">일표본과 이표본 검정</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-table"><code>table</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Index-matrices-_0028_c778_b371_c2a4-_d589_b82c_0029">Index matrices (인덱스 행렬)</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-table-1"><code>table</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t_c694_c778_c744-_c774_c6a9_d558_c5ec-_b3c4_c218_bd84_d3ec_d45c-_c0dd_c131_d558_ae30">요인을 이용하여 도수분포표 생성하기</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-tan"><code>tan</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t_bca1_d130-_c5f0_c0b0">벡터 연산</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-tapply"><code>tapply</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#The-function-tapply_0028_0029-and-ragged-arrays">The function tapply() and ragged arrays</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-text"><code>text</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Low_002dlevel-plotting-commands">Low-level plotting commands</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-title"><code>title</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Low_002dlevel-plotting-commands">Low-level plotting commands</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-tree"><code>tree</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Some-non_002dstandard-models">Some non-standard models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-TRUE"><code>TRUE</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t_b17c_b9ac_d615-_bca1_d130">논리형 벡터</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="g_t_d568_c218-_bc0f-_bcc0_c218_c640-_ad00_b828_b41c-_c0c9_c778_vr_letter-U">U</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-unclass"><code>unclass</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t_ac1d_ccb4_c758-_d074_b798_c2a4">객체의 클래스</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-update"><code>update</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Updating-fitted-models">Updating fitted models</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="g_t_d568_c218-_bc0f-_bcc0_c218_c640-_ad00_b828_b41c-_c0c9_c778_vr_letter-V">V</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-var"><code>var</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t_bca1_d130-_c5f0_c0b0">벡터 연산</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-var-1"><code>var</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#The-function-tapply_0028_0029-and-ragged-arrays">The function tapply() and ragged arrays</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-var_002etest"><code>var.test</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t_c77c_d45c_bcf8_acfc-_c774_d45c_bcf8-_ac80_c815">일표본과 이표본 검정</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-vcov"><code>vcov</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Generic-functions-for-extracting-model-information">Generic functions for extracting model information</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-vector"><code>vector</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t_bca1_d130_c640-_d560_b2f9">벡터와 할당</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="g_t_d568_c218-_bc0f-_bcc0_c218_c640-_ad00_b828_b41c-_c0c9_c778_vr_letter-W">W</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-while"><code>while</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Repetitive-execution">Repetitive execution</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-wilcox_002etest"><code>wilcox.test</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t_c77c_d45c_bcf8_acfc-_c774_d45c_bcf8-_ac80_c815">일표본과 이표본 검정</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-windows"><code>windows</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Device-drivers">Device drivers</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="g_t_d568_c218-_bc0f-_bcc0_c218_c640-_ad00_b828_b41c-_c0c9_c778_vr_letter-X">X</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-X11"><code>X11</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Device-drivers">Device drivers</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
</table>
<table><tr><th valign="top">Jump to: &nbsp; </th><td><a class="summary-letter" href="#g_t_d568_c218-_bc0f-_bcc0_c218_c640-_ad00_b828_b41c-_c0c9_c778_vr_symbol-1"><b>!</b></a>
 &nbsp; 
<a class="summary-letter" href="#g_t_d568_c218-_bc0f-_bcc0_c218_c640-_ad00_b828_b41c-_c0c9_c778_vr_symbol-2"><b>%</b></a>
 &nbsp; 
<a class="summary-letter" href="#g_t_d568_c218-_bc0f-_bcc0_c218_c640-_ad00_b828_b41c-_c0c9_c778_vr_symbol-3"><b>&amp;</b></a>
 &nbsp; 
<a class="summary-letter" href="#g_t_d568_c218-_bc0f-_bcc0_c218_c640-_ad00_b828_b41c-_c0c9_c778_vr_symbol-4"><b>*</b></a>
 &nbsp; 
<a class="summary-letter" href="#g_t_d568_c218-_bc0f-_bcc0_c218_c640-_ad00_b828_b41c-_c0c9_c778_vr_symbol-5"><b>+</b></a>
 &nbsp; 
<a class="summary-letter" href="#g_t_d568_c218-_bc0f-_bcc0_c218_c640-_ad00_b828_b41c-_c0c9_c778_vr_symbol-6"><b>-</b></a>
 &nbsp; 
<a class="summary-letter" href="#g_t_d568_c218-_bc0f-_bcc0_c218_c640-_ad00_b828_b41c-_c0c9_c778_vr_symbol-7"><b>.</b></a>
 &nbsp; 
<a class="summary-letter" href="#g_t_d568_c218-_bc0f-_bcc0_c218_c640-_ad00_b828_b41c-_c0c9_c778_vr_symbol-8"><b>/</b></a>
 &nbsp; 
<a class="summary-letter" href="#g_t_d568_c218-_bc0f-_bcc0_c218_c640-_ad00_b828_b41c-_c0c9_c778_vr_symbol-9"><b>:</b></a>
 &nbsp; 
<a class="summary-letter" href="#g_t_d568_c218-_bc0f-_bcc0_c218_c640-_ad00_b828_b41c-_c0c9_c778_vr_symbol-10"><b>&lt;</b></a>
 &nbsp; 
<a class="summary-letter" href="#g_t_d568_c218-_bc0f-_bcc0_c218_c640-_ad00_b828_b41c-_c0c9_c778_vr_symbol-11"><b>=</b></a>
 &nbsp; 
<a class="summary-letter" href="#g_t_d568_c218-_bc0f-_bcc0_c218_c640-_ad00_b828_b41c-_c0c9_c778_vr_symbol-12"><b>&gt;</b></a>
 &nbsp; 
<a class="summary-letter" href="#g_t_d568_c218-_bc0f-_bcc0_c218_c640-_ad00_b828_b41c-_c0c9_c778_vr_symbol-13"><b>?</b></a>
 &nbsp; 
<a class="summary-letter" href="#g_t_d568_c218-_bc0f-_bcc0_c218_c640-_ad00_b828_b41c-_c0c9_c778_vr_symbol-14"><b>^</b></a>
 &nbsp; 
<a class="summary-letter" href="#g_t_d568_c218-_bc0f-_bcc0_c218_c640-_ad00_b828_b41c-_c0c9_c778_vr_symbol-15"><b>|</b></a>
 &nbsp; 
<a class="summary-letter" href="#g_t_d568_c218-_bc0f-_bcc0_c218_c640-_ad00_b828_b41c-_c0c9_c778_vr_symbol-16"><b>~</b></a>
 &nbsp; 
<br>
<a class="summary-letter" href="#g_t_d568_c218-_bc0f-_bcc0_c218_c640-_ad00_b828_b41c-_c0c9_c778_vr_letter-A"><b>A</b></a>
 &nbsp; 
<a class="summary-letter" href="#g_t_d568_c218-_bc0f-_bcc0_c218_c640-_ad00_b828_b41c-_c0c9_c778_vr_letter-B"><b>B</b></a>
 &nbsp; 
<a class="summary-letter" href="#g_t_d568_c218-_bc0f-_bcc0_c218_c640-_ad00_b828_b41c-_c0c9_c778_vr_letter-C"><b>C</b></a>
 &nbsp; 
<a class="summary-letter" href="#g_t_d568_c218-_bc0f-_bcc0_c218_c640-_ad00_b828_b41c-_c0c9_c778_vr_letter-D"><b>D</b></a>
 &nbsp; 
<a class="summary-letter" href="#g_t_d568_c218-_bc0f-_bcc0_c218_c640-_ad00_b828_b41c-_c0c9_c778_vr_letter-E"><b>E</b></a>
 &nbsp; 
<a class="summary-letter" href="#g_t_d568_c218-_bc0f-_bcc0_c218_c640-_ad00_b828_b41c-_c0c9_c778_vr_letter-F"><b>F</b></a>
 &nbsp; 
<a class="summary-letter" href="#g_t_d568_c218-_bc0f-_bcc0_c218_c640-_ad00_b828_b41c-_c0c9_c778_vr_letter-G"><b>G</b></a>
 &nbsp; 
<a class="summary-letter" href="#g_t_d568_c218-_bc0f-_bcc0_c218_c640-_ad00_b828_b41c-_c0c9_c778_vr_letter-H"><b>H</b></a>
 &nbsp; 
<a class="summary-letter" href="#g_t_d568_c218-_bc0f-_bcc0_c218_c640-_ad00_b828_b41c-_c0c9_c778_vr_letter-I"><b>I</b></a>
 &nbsp; 
<a class="summary-letter" href="#g_t_d568_c218-_bc0f-_bcc0_c218_c640-_ad00_b828_b41c-_c0c9_c778_vr_letter-J"><b>J</b></a>
 &nbsp; 
<a class="summary-letter" href="#g_t_d568_c218-_bc0f-_bcc0_c218_c640-_ad00_b828_b41c-_c0c9_c778_vr_letter-K"><b>K</b></a>
 &nbsp; 
<a class="summary-letter" href="#g_t_d568_c218-_bc0f-_bcc0_c218_c640-_ad00_b828_b41c-_c0c9_c778_vr_letter-L"><b>L</b></a>
 &nbsp; 
<a class="summary-letter" href="#g_t_d568_c218-_bc0f-_bcc0_c218_c640-_ad00_b828_b41c-_c0c9_c778_vr_letter-M"><b>M</b></a>
 &nbsp; 
<a class="summary-letter" href="#g_t_d568_c218-_bc0f-_bcc0_c218_c640-_ad00_b828_b41c-_c0c9_c778_vr_letter-N"><b>N</b></a>
 &nbsp; 
<a class="summary-letter" href="#g_t_d568_c218-_bc0f-_bcc0_c218_c640-_ad00_b828_b41c-_c0c9_c778_vr_letter-O"><b>O</b></a>
 &nbsp; 
<a class="summary-letter" href="#g_t_d568_c218-_bc0f-_bcc0_c218_c640-_ad00_b828_b41c-_c0c9_c778_vr_letter-P"><b>P</b></a>
 &nbsp; 
<a class="summary-letter" href="#g_t_d568_c218-_bc0f-_bcc0_c218_c640-_ad00_b828_b41c-_c0c9_c778_vr_letter-Q"><b>Q</b></a>
 &nbsp; 
<a class="summary-letter" href="#g_t_d568_c218-_bc0f-_bcc0_c218_c640-_ad00_b828_b41c-_c0c9_c778_vr_letter-R"><b>R</b></a>
 &nbsp; 
<a class="summary-letter" href="#g_t_d568_c218-_bc0f-_bcc0_c218_c640-_ad00_b828_b41c-_c0c9_c778_vr_letter-S"><b>S</b></a>
 &nbsp; 
<a class="summary-letter" href="#g_t_d568_c218-_bc0f-_bcc0_c218_c640-_ad00_b828_b41c-_c0c9_c778_vr_letter-T"><b>T</b></a>
 &nbsp; 
<a class="summary-letter" href="#g_t_d568_c218-_bc0f-_bcc0_c218_c640-_ad00_b828_b41c-_c0c9_c778_vr_letter-U"><b>U</b></a>
 &nbsp; 
<a class="summary-letter" href="#g_t_d568_c218-_bc0f-_bcc0_c218_c640-_ad00_b828_b41c-_c0c9_c778_vr_letter-V"><b>V</b></a>
 &nbsp; 
<a class="summary-letter" href="#g_t_d568_c218-_bc0f-_bcc0_c218_c640-_ad00_b828_b41c-_c0c9_c778_vr_letter-W"><b>W</b></a>
 &nbsp; 
<a class="summary-letter" href="#g_t_d568_c218-_bc0f-_bcc0_c218_c640-_ad00_b828_b41c-_c0c9_c778_vr_letter-X"><b>X</b></a>
 &nbsp; 
</td></tr></table>

<hr>
<a name="g_t_ac1c_b150_acfc-_ad00_b828_b41c-_c0c9_c778"></a>
<a name="gaenyeomgwa-gwanryeondoen-saegin"></a>
<h2 class="appendix">Appendix E 개념과 관련된 색인</h2>

<table><tr><th valign="top">Jump to: &nbsp; </th><td><a class="summary-letter" href="#g_t_ac1c_b150_acfc-_ad00_b828_b41c-_c0c9_c778_cp_letter-A"><b>A</b></a>
 &nbsp; 
<a class="summary-letter" href="#g_t_ac1c_b150_acfc-_ad00_b828_b41c-_c0c9_c778_cp_letter-B"><b>B</b></a>
 &nbsp; 
<a class="summary-letter" href="#g_t_ac1c_b150_acfc-_ad00_b828_b41c-_c0c9_c778_cp_letter-C"><b>C</b></a>
 &nbsp; 
<a class="summary-letter" href="#g_t_ac1c_b150_acfc-_ad00_b828_b41c-_c0c9_c778_cp_letter-D"><b>D</b></a>
 &nbsp; 
<a class="summary-letter" href="#g_t_ac1c_b150_acfc-_ad00_b828_b41c-_c0c9_c778_cp_letter-E"><b>E</b></a>
 &nbsp; 
<a class="summary-letter" href="#g_t_ac1c_b150_acfc-_ad00_b828_b41c-_c0c9_c778_cp_letter-F"><b>F</b></a>
 &nbsp; 
<a class="summary-letter" href="#g_t_ac1c_b150_acfc-_ad00_b828_b41c-_c0c9_c778_cp_letter-G"><b>G</b></a>
 &nbsp; 
<a class="summary-letter" href="#g_t_ac1c_b150_acfc-_ad00_b828_b41c-_c0c9_c778_cp_letter-I"><b>I</b></a>
 &nbsp; 
<a class="summary-letter" href="#g_t_ac1c_b150_acfc-_ad00_b828_b41c-_c0c9_c778_cp_letter-K"><b>K</b></a>
 &nbsp; 
<a class="summary-letter" href="#g_t_ac1c_b150_acfc-_ad00_b828_b41c-_c0c9_c778_cp_letter-L"><b>L</b></a>
 &nbsp; 
<a class="summary-letter" href="#g_t_ac1c_b150_acfc-_ad00_b828_b41c-_c0c9_c778_cp_letter-M"><b>M</b></a>
 &nbsp; 
<a class="summary-letter" href="#g_t_ac1c_b150_acfc-_ad00_b828_b41c-_c0c9_c778_cp_letter-N"><b>N</b></a>
 &nbsp; 
<a class="summary-letter" href="#g_t_ac1c_b150_acfc-_ad00_b828_b41c-_c0c9_c778_cp_letter-O"><b>O</b></a>
 &nbsp; 
<a class="summary-letter" href="#g_t_ac1c_b150_acfc-_ad00_b828_b41c-_c0c9_c778_cp_letter-P"><b>P</b></a>
 &nbsp; 
<a class="summary-letter" href="#g_t_ac1c_b150_acfc-_ad00_b828_b41c-_c0c9_c778_cp_letter-Q"><b>Q</b></a>
 &nbsp; 
<a class="summary-letter" href="#g_t_ac1c_b150_acfc-_ad00_b828_b41c-_c0c9_c778_cp_letter-R"><b>R</b></a>
 &nbsp; 
<a class="summary-letter" href="#g_t_ac1c_b150_acfc-_ad00_b828_b41c-_c0c9_c778_cp_letter-S"><b>S</b></a>
 &nbsp; 
<a class="summary-letter" href="#g_t_ac1c_b150_acfc-_ad00_b828_b41c-_c0c9_c778_cp_letter-T"><b>T</b></a>
 &nbsp; 
<a class="summary-letter" href="#g_t_ac1c_b150_acfc-_ad00_b828_b41c-_c0c9_c778_cp_letter-U"><b>U</b></a>
 &nbsp; 
<a class="summary-letter" href="#g_t_ac1c_b150_acfc-_ad00_b828_b41c-_c0c9_c778_cp_letter-V"><b>V</b></a>
 &nbsp; 
<a class="summary-letter" href="#g_t_ac1c_b150_acfc-_ad00_b828_b41c-_c0c9_c778_cp_letter-W"><b>W</b></a>
 &nbsp; 
<a class="summary-letter" href="#g_t_ac1c_b150_acfc-_ad00_b828_b41c-_c0c9_c778_cp_letter-결"><b>결</b></a>
 &nbsp; 
<a class="summary-letter" href="#g_t_ac1c_b150_acfc-_ad00_b828_b41c-_c0c9_c778_cp_letter-고"><b>고</b></a>
 &nbsp; 
<a class="summary-letter" href="#g_t_ac1c_b150_acfc-_ad00_b828_b41c-_c0c9_c778_cp_letter-그"><b>그</b></a>
 &nbsp; 
<a class="summary-letter" href="#g_t_ac1c_b150_acfc-_ad00_b828_b41c-_c0c9_c778_cp_letter-내"><b>내</b></a>
 &nbsp; 
<a class="summary-letter" href="#g_t_ac1c_b150_acfc-_ad00_b828_b41c-_c0c9_c778_cp_letter-네"><b>네</b></a>
 &nbsp; 
<a class="summary-letter" href="#g_t_ac1c_b150_acfc-_ad00_b828_b41c-_c0c9_c778_cp_letter-문"><b>문</b></a>
 &nbsp; 
<a class="summary-letter" href="#g_t_ac1c_b150_acfc-_ad00_b828_b41c-_c0c9_c778_cp_letter-배"><b>배</b></a>
 &nbsp; 
<a class="summary-letter" href="#g_t_ac1c_b150_acfc-_ad00_b828_b41c-_c0c9_c778_cp_letter-순"><b>순</b></a>
 &nbsp; 
<a class="summary-letter" href="#g_t_ac1c_b150_acfc-_ad00_b828_b41c-_c0c9_c778_cp_letter-외"><b>외</b></a>
 &nbsp; 
<a class="summary-letter" href="#g_t_ac1c_b150_acfc-_ad00_b828_b41c-_c0c9_c778_cp_letter-일"><b>일</b></a>
 &nbsp; 
<a class="summary-letter" href="#g_t_ac1c_b150_acfc-_ad00_b828_b41c-_c0c9_c778_cp_letter-제"><b>제</b></a>
 &nbsp; 
<a class="summary-letter" href="#g_t_ac1c_b150_acfc-_ad00_b828_b41c-_c0c9_c778_cp_letter-행"><b>행</b></a>
 &nbsp; 
<a class="summary-letter" href="#g_t_ac1c_b150_acfc-_ad00_b828_b41c-_c0c9_c778_cp_letter-확"><b>확</b></a>
 &nbsp; 
<a class="summary-letter" href="#g_t_ac1c_b150_acfc-_ad00_b828_b41c-_c0c9_c778_cp_letter-환"><b>환</b></a>
 &nbsp; 
</td></tr></table>
<table class="index-cp" border="0">
<tr><td></td><th align="left">Index Entry</th><td>&nbsp;</td><th align="left"> Section</th></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="g_t_ac1c_b150_acfc-_ad00_b828_b41c-_c0c9_c778_cp_letter-A">A</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-Additive-models">Additive models</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Some-non_002dstandard-models">Some non-standard models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Analysis-of-variance">Analysis of variance</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Analysis-of-variance-and-model-comparison">Analysis of variance and model comparison</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Arithmetic-functions-and-operators">Arithmetic functions and operators</a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t_bca1_d130-_c5f0_c0b0">벡터 연산</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Assignment">Assignment</a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t_bca1_d130_c640-_d560_b2f9">벡터와 할당</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Attributes">Attributes</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Objects">Objects</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="g_t_ac1c_b150_acfc-_ad00_b828_b41c-_c0c9_c778_cp_letter-B">B</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-Binary-operators">Binary operators</a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t_c0c8_b85c_c6b4-_c774_d56d_c5f0_c0b0_c790_b97c-_c815_c758_d558_ae30">새로운 이항연산자를 정의하기</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Box-plots">Box plots</a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t_c77c_d45c_bcf8_acfc-_c774_d45c_bcf8-_ac80_c815">일표본과 이표본 검정</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="g_t_ac1c_b150_acfc-_ad00_b828_b41c-_c0c9_c778_cp_letter-C">C</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-Classes">Classes</a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t_ac1d_ccb4_c758-_d074_b798_c2a4">객체의 클래스</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Classes-1">Classes</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Object-orientation-_0028_ac1d_ccb4_c9c0_d5a5_c801-_bc29_bc95_0029">Object orientation (객체지향적 방법)</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Concatenating-lists-_0028riseuteu-yeongyeolhagi_0029">Concatenating lists (리스트 연결하기)</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Concatenating-lists-_0028_b9ac_c2a4_d2b8-_c5f0_acb0_d558_ae30_0029">Concatenating lists (리스트 연결하기)</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Contrasts">Contrasts</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Contrasts">Contrasts</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-CRAN">CRAN</a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t_c0ac_c6a9_c790_002d_ae30_c5ec-_d328_d0a4_c9c0_0028Contributed-packages_0029_c640-CRAN">사용자-기여 패키지(Contributed packages)와 <acronym>CRAN</acronym></a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="g_t_ac1c_b150_acfc-_ad00_b828_b41c-_c0c9_c778_cp_letter-D">D</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-Data-frames-_0028deiteo-peureim_0029">Data frames (데이터 프레임)</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Data-frames-_0028_b370_c774_d130-_d504_b808_c784_0029">Data frames (데이터 프레임)</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Default-values">Default values</a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t_c778_c790_ba85_acfc-_ae30_bcf8_ac12">인자명과 기본값</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Density-estimation">Density estimation</a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t_b370_c774_d130_c758-_bd84_d3ec-_c0b4_d3b4_bcf4_ae30">데이터의 분포 살펴보기</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Determinants">Determinants</a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t_d2b9_c774_ac12-_bd84_d574-_bc0f-_d589_b82c_c2dd">특이값 분해 및 행렬식</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Dynamic-graphics">Dynamic graphics</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Dynamic-graphics">Dynamic graphics</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="g_t_ac1c_b150_acfc-_ad00_b828_b41c-_c0c9_c778_cp_letter-E">E</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-Empirical-CDFs">Empirical CDFs</a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t_b370_c774_d130_c758-_bd84_d3ec-_c0b4_d3b4_bcf4_ae30">데이터의 분포 살펴보기</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="g_t_ac1c_b150_acfc-_ad00_b828_b41c-_c0c9_c778_cp_letter-F">F</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-Factors-_0028yoin_0029">Factors (요인)</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Factors-_0028_c694_c778_0029">Factors (요인)</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Factors-_0028yoin_0029-1">Factors (요인)</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Contrasts">Contrasts</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Families">Families</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Families">Families</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Formulae">Formulae</a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t_c2dd_0028formulae_0029_c744-_d1b5_d55c-_d1b5_acc4_baa8_d615_c758-_c815_c758">식(formulae)을 통한 통계모형의 정의</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="g_t_ac1c_b150_acfc-_ad00_b828_b41c-_c0c9_c778_cp_letter-G">G</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-Generalized-linear-models">Generalized linear models</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Generalized-linear-models">Generalized linear models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Generic-functions">Generic functions</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Object-orientation-_0028_ac1d_ccb4_c9c0_d5a5_c801-_bc29_bc95_0029">Object orientation (객체지향적 방법)</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Graphics-parameters">Graphics parameters</a>:</td><td>&nbsp;</td><td valign="top"><a href="#The-par_0028_0029-function">The par() function</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="g_t_ac1c_b150_acfc-_ad00_b828_b41c-_c0c9_c778_cp_letter-I">I</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-Indexing-of-and-by-arrays">Indexing of and by arrays</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Array-indexing">Array indexing</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Indexing-vectors">Indexing vectors</a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t_c778_b371_c2a4-_bca1_d130">인덱스 벡터</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="g_t_ac1c_b150_acfc-_ad00_b828_b41c-_c0c9_c778_cp_letter-K">K</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-Kolmogorov_002dSmirnov-test">Kolmogorov-Smirnov test</a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t_b370_c774_d130_c758-_bd84_d3ec-_c0b4_d3b4_bcf4_ae30">데이터의 분포 살펴보기</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="g_t_ac1c_b150_acfc-_ad00_b828_b41c-_c0c9_c778_cp_letter-L">L</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-Least-squares-fitting">Least squares fitting</a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t_cd5c_c18c_c81c_acf1_bc95_acfc-QR-_bd84_d574_bc95">최소제곱법과 QR 분해법</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Linear-equations">Linear equations</a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t_c120_d615_bc29_c815_c2dd_acfc-_c5ed_d589_b82c">선형방정식과 역행렬</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Linear-models">Linear models</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Linear-models">Linear models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Lists-_0028riseuteu_0029">Lists (리스트)</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Lists-_0028_b9ac_c2a4_d2b8_0029">Lists (리스트)</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Local-approximating-regressions">Local approximating regressions</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Some-non_002dstandard-models">Some non-standard models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Loops-and-conditional-execution-_0028banbog-mic-jogeonbu-silhaeng_0029">Loops and conditional execution (반복 및 조건부 실행)</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Loops-and-conditional-execution-_0028_bc18_bcf5-_bc0f-_c870_ac74_bd80-_c2e4_d589_0029">Loops and conditional execution (반복 및 조건부 실행)</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="g_t_ac1c_b150_acfc-_ad00_b828_b41c-_c0c9_c778_cp_letter-M">M</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-Matrices">Matrices</a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t_bc30_c5f4">배열</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Maximum-likelihood">Maximum likelihood</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Maximum-likelihood">Maximum likelihood</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Mixed-models">Mixed models</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Some-non_002dstandard-models">Some non-standard models</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="g_t_ac1c_b150_acfc-_ad00_b828_b41c-_c0c9_c778_cp_letter-N">N</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-Named-arguments">Named arguments</a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t_c778_c790_ba85_acfc-_ae30_bcf8_ac12">인자명과 기본값</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Nonlinear-least-squares">Nonlinear least squares</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Nonlinear-least-squares-and-maximum-likelihood-models">Nonlinear least squares and maximum likelihood models</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="g_t_ac1c_b150_acfc-_ad00_b828_b41c-_c0c9_c778_cp_letter-O">O</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-Object-orientation-_0028gaegcejihyangjeog-bangbeob_0029">Object orientation (객체지향적 방법)</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Object-orientation-_0028_ac1d_ccb4_c9c0_d5a5_c801-_bc29_bc95_0029">Object orientation (객체지향적 방법)</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Objects">Objects</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Objects">Objects</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="g_t_ac1c_b150_acfc-_ad00_b828_b41c-_c0c9_c778_cp_letter-P">P</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-Packages-_0028paekiji_0029">Packages (패키지)</a>:</td><td>&nbsp;</td><td valign="top"><a href="#R_acfc-_d1b5_acc4">R과 통계</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Packages-_0028paekiji_0029-1">Packages (패키지)</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Packages-_0028_d328_d0a4_c9c0_0029">Packages (패키지)</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="g_t_ac1c_b150_acfc-_ad00_b828_b41c-_c0c9_c778_cp_letter-Q">Q</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-QR-decomposition">QR decomposition</a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t_cd5c_c18c_c81c_acf1_bc95_acfc-QR-_bd84_d574_bc95">최소제곱법과 QR 분해법</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Quantile_002dquantile-plots">Quantile-quantile plots</a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t_b370_c774_d130_c758-_bd84_d3ec-_c0b4_d3b4_bcf4_ae30">데이터의 분포 살펴보기</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="g_t_ac1c_b150_acfc-_ad00_b828_b41c-_c0c9_c778_cp_letter-R">R</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-Reading-data-from-files-_0028pailrobuteo-deiteo-ilgeoogi_0029">Reading data from files (파일로부터 데이터 읽어오기)</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Reading-data-from-files-_0028_d30c_c77c_b85c_bd80_d130-_b370_c774_d130-_c77d_c5b4_c624_ae30_0029">Reading data from files (파일로부터 데이터 읽어오기)</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Recycling-rule">Recycling rule</a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t_bca1_d130-_c5f0_c0b0">벡터 연산</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Recycling-rule-1">Recycling rule</a>:</td><td>&nbsp;</td><td valign="top"><a href="#The-recycling-rule">The recycling rule</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Regular-sequences">Regular sequences</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Generating-regular-sequences-_0028_addc_ce59_c131_c744-_c9c0_b2cc-_c77c_b828_c758-_c22b_c790_b4e4_c744-_c0dd_c131_d558_ae30_0029">Generating regular sequences (규칙성을 지닌 일련의 숫자들을 생성하기)</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Removing-objects">Removing objects</a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t_c601_ad6c_c801-_b370_c774_d130-_c0dd_c131-_bc0f-_ac1d_ccb4_c758-_c81c_ac70">영구적 데이터 생성 및 객체의 제거</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Robust-regression">Robust regression</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Some-non_002dstandard-models">Some non-standard models</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="g_t_ac1c_b150_acfc-_ad00_b828_b41c-_c0c9_c778_cp_letter-S">S</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-Scope-_0028seukopeu_0029">Scope (스코프)</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Scope-_0028_c2a4_cf54_d504_0029">Scope (스코프)</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Search-path">Search path</a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t_d0d0_c0c9_acbd_b85c_b97c-_ad00_b9ac_d558_ae30">탐색경로를 관리하기</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Shapiro_002dWilk-test">Shapiro-Wilk test</a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t_b370_c774_d130_c758-_bd84_d3ec-_c0b4_d3b4_bcf4_ae30">데이터의 분포 살펴보기</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Singular-value-decomposition">Singular value decomposition</a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t_d2b9_c774_ac12-_bd84_d574-_bc0f-_d589_b82c_c2dd">특이값 분해 및 행렬식</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Statistical-models">Statistical models</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Statistical-models-in-R-_0028R_c5d0_c11c-_c0ac_c6a9_b418_b294-_d1b5_acc4_baa8_d615_b4e4_0029">Statistical models in R (R에서 사용되는 통계모형들)</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Student_0027s-t-test">Student&rsquo;s <em>t</em> test</a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t_c77c_d45c_bcf8_acfc-_c774_d45c_bcf8-_ac80_c815">일표본과 이표본 검정</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="g_t_ac1c_b150_acfc-_ad00_b828_b41c-_c0c9_c778_cp_letter-T">T</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-Tabulation">Tabulation</a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t_c694_c778_c744-_c774_c6a9_d558_c5ec-_b3c4_c218_bd84_d3ec_d45c-_c0dd_c131_d558_ae30">요인을 이용하여 도수분포표 생성하기</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Tree_002dbased-models">Tree-based models</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Some-non_002dstandard-models">Some non-standard models</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="g_t_ac1c_b150_acfc-_ad00_b828_b41c-_c0c9_c778_cp_letter-U">U</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-Updating-fitted-models">Updating fitted models</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Updating-fitted-models">Updating fitted models</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="g_t_ac1c_b150_acfc-_ad00_b828_b41c-_c0c9_c778_cp_letter-V">V</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-Vectors">Vectors</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Simple-manipulations-numbers-and-vectors">Simple manipulations numbers and vectors</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="g_t_ac1c_b150_acfc-_ad00_b828_b41c-_c0c9_c778_cp_letter-W">W</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-Wilcoxon-test">Wilcoxon test</a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t_c77c_d45c_bcf8_acfc-_c774_d45c_bcf8-_ac80_c815">일표본과 이표본 검정</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Workspace">Workspace</a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t_c601_ad6c_c801-_b370_c774_d130-_c0dd_c131-_bc0f-_ac1d_ccb4_c758-_c81c_ac70">영구적 데이터 생성 및 객체의 제거</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Writing-functions">Writing functions</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Writing-your-own-functions-_0028_c0ac_c6a9_c790-_c815_c758_d568_c218-_c791_c131_d558_ae30_0029">Writing your own functions (사용자 정의함수 작성하기)</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="g_t_ac1c_b150_acfc-_ad00_b828_b41c-_c0c9_c778_cp_letter-결">결</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-gyeolceuggabs">결측값</a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t_acb0_ce21_ac12">결측값</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="g_t_ac1c_b150_acfc-_ad00_b828_b41c-_c0c9_c778_cp_letter-고">고</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-goyugabsgwa-goyubegteo">고유값과 고유벡터</a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t_ace0_c720_ac12_acfc-_ace0_c720_bca1_d130">고유값과 고유벡터</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="g_t_ac1c_b150_acfc-_ad00_b828_b41c-_c0c9_c778_cp_letter-그">그</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-geuraepig-dibaiseu-deuraibeo-_0028graphic-device-driver_0029">그래픽 디바이스 드라이버 (graphic device driver)</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Device-drivers">Device drivers</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-geurubhwadoen-pyohyeon">그룹화된 표현</a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t_adf8_b8f9_d654_b41c-_d45c_d604">그룹화된 표현</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="g_t_ac1c_b150_acfc-_ad00_b828_b41c-_c0c9_c778_cp_letter-내">내</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-naejangdoen-deiteoseseul-iyonghagi">내장된 데이터셋을 이용하기</a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t_b0b4_c7a5_b41c-_b370_c774_d130_c14b_c744-_c774_c6a9_d558_ae30">내장된 데이터셋을 이용하기</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="g_t_ac1c_b150_acfc-_ad00_b828_b41c-_c0c9_c778_cp_letter-네">네</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-neimseupeiseu-_0028Namespaces_0029">네임스페이스 (Namespaces)</a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t_b124_c784_c2a4_d398_c774_c2a4-_0028Namespaces_0029">네임스페이스 (Namespaces)</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="g_t_ac1c_b150_acfc-_ad00_b828_b41c-_c0c9_c778_cp_letter-문">문</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-munjahyeong-begteo">문자형 벡터</a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t_bb38_c790_d615-_bca1_d130">문자형 벡터</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="g_t_ac1c_b150_acfc-_ad00_b828_b41c-_c0c9_c778_cp_letter-배">배</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-baeyeol">배열</a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t_bc30_c5f4">배열</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-baeyeolyi-oejeog_0028outer-products_0029">배열의 외적(outer products)</a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t_b450-_bc30_c5f4_c758-_c678_c801">두 배열의 외적</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-baeyeolyi-jeoncie-sayongdoeneun-ilbanhwadoen-bangbeob">배열의 전치에 사용되는 일반화된 방법</a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t_bc30_c5f4_c758-_c804_ce58_c5d0-_c0ac_c6a9_b418_b294-_c77c_bc18_d654_b41c-_bc29_bc95">배열의 전치에 사용되는 일반화된 방법</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="g_t_ac1c_b150_acfc-_ad00_b828_b41c-_c0c9_c778_cp_letter-순">순</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-sunseohyeong-yoin">순서형 요인</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Factors-_0028_c694_c778_0029">Factors (요인)</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-sunseohyeong-yoin-1">순서형 요인</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Contrasts">Contrasts</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="g_t_ac1c_b150_acfc-_ad00_b828_b41c-_c0c9_c778_cp_letter-외">외</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-oebupaile-jeojangdoen-myeongryeong-silhaeng-mic-oebupailro-gyeolgwa-jeojanghagi">외부파일에 저장된 명령 실행 및 외부파일로 결과 저장하기</a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t_d30c_c77c_c5d0-_c791_c131_b41c-_ba85_b839_c5b4_b97c-_c2e4_d589_d558_ac70_b098-_cd9c_b825_bc29_d5a5_c744-_d30c_c77c_b85c-_bcc0_acbd_d558_ae30">파일에 작성된 명령어를 실행하거나 출력방향을 파일로 변경하기</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="g_t_ac1c_b150_acfc-_ad00_b828_b41c-_c0c9_c778_cp_letter-일">일</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-ilpyobongwa-ipyobon-geomjeong">일표본과 이표본 검정</a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t_c77c_d45c_bcf8_acfc-_c774_d45c_bcf8-_ac80_c815">일표본과 이표본 검정</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="g_t_ac1c_b150_acfc-_ad00_b828_b41c-_c0c9_c778_cp_letter-제">제</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-jeeomun">제어문</a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t_c81c_c5b4_bb38">제어문</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="g_t_ac1c_b150_acfc-_ad00_b828_b41c-_c0c9_c778_cp_letter-행">행</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-haengryeolyi-gobsem">행렬의 곱셈</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Multiplication">Multiplication</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="g_t_ac1c_b150_acfc-_ad00_b828_b41c-_c0c9_c778_cp_letter-확">확</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-hwagryulbunpohamsu">확률분포함수</a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t_d655_b960_bd84_d3ec_d568_c218">확률분포함수</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="g_t_ac1c_b150_acfc-_ad00_b828_b41c-_c0c9_c778_cp_letter-환">환</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-hwangyeong-seoljeonghagi">환경 설정하기</a>:</td><td>&nbsp;</td><td valign="top"><a href="#g_t_d658_acbd-_c124_c815_d558_ae30">환경 설정하기</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
</table>
<table><tr><th valign="top">Jump to: &nbsp; </th><td><a class="summary-letter" href="#g_t_ac1c_b150_acfc-_ad00_b828_b41c-_c0c9_c778_cp_letter-A"><b>A</b></a>
 &nbsp; 
<a class="summary-letter" href="#g_t_ac1c_b150_acfc-_ad00_b828_b41c-_c0c9_c778_cp_letter-B"><b>B</b></a>
 &nbsp; 
<a class="summary-letter" href="#g_t_ac1c_b150_acfc-_ad00_b828_b41c-_c0c9_c778_cp_letter-C"><b>C</b></a>
 &nbsp; 
<a class="summary-letter" href="#g_t_ac1c_b150_acfc-_ad00_b828_b41c-_c0c9_c778_cp_letter-D"><b>D</b></a>
 &nbsp; 
<a class="summary-letter" href="#g_t_ac1c_b150_acfc-_ad00_b828_b41c-_c0c9_c778_cp_letter-E"><b>E</b></a>
 &nbsp; 
<a class="summary-letter" href="#g_t_ac1c_b150_acfc-_ad00_b828_b41c-_c0c9_c778_cp_letter-F"><b>F</b></a>
 &nbsp; 
<a class="summary-letter" href="#g_t_ac1c_b150_acfc-_ad00_b828_b41c-_c0c9_c778_cp_letter-G"><b>G</b></a>
 &nbsp; 
<a class="summary-letter" href="#g_t_ac1c_b150_acfc-_ad00_b828_b41c-_c0c9_c778_cp_letter-I"><b>I</b></a>
 &nbsp; 
<a class="summary-letter" href="#g_t_ac1c_b150_acfc-_ad00_b828_b41c-_c0c9_c778_cp_letter-K"><b>K</b></a>
 &nbsp; 
<a class="summary-letter" href="#g_t_ac1c_b150_acfc-_ad00_b828_b41c-_c0c9_c778_cp_letter-L"><b>L</b></a>
 &nbsp; 
<a class="summary-letter" href="#g_t_ac1c_b150_acfc-_ad00_b828_b41c-_c0c9_c778_cp_letter-M"><b>M</b></a>
 &nbsp; 
<a class="summary-letter" href="#g_t_ac1c_b150_acfc-_ad00_b828_b41c-_c0c9_c778_cp_letter-N"><b>N</b></a>
 &nbsp; 
<a class="summary-letter" href="#g_t_ac1c_b150_acfc-_ad00_b828_b41c-_c0c9_c778_cp_letter-O"><b>O</b></a>
 &nbsp; 
<a class="summary-letter" href="#g_t_ac1c_b150_acfc-_ad00_b828_b41c-_c0c9_c778_cp_letter-P"><b>P</b></a>
 &nbsp; 
<a class="summary-letter" href="#g_t_ac1c_b150_acfc-_ad00_b828_b41c-_c0c9_c778_cp_letter-Q"><b>Q</b></a>
 &nbsp; 
<a class="summary-letter" href="#g_t_ac1c_b150_acfc-_ad00_b828_b41c-_c0c9_c778_cp_letter-R"><b>R</b></a>
 &nbsp; 
<a class="summary-letter" href="#g_t_ac1c_b150_acfc-_ad00_b828_b41c-_c0c9_c778_cp_letter-S"><b>S</b></a>
 &nbsp; 
<a class="summary-letter" href="#g_t_ac1c_b150_acfc-_ad00_b828_b41c-_c0c9_c778_cp_letter-T"><b>T</b></a>
 &nbsp; 
<a class="summary-letter" href="#g_t_ac1c_b150_acfc-_ad00_b828_b41c-_c0c9_c778_cp_letter-U"><b>U</b></a>
 &nbsp; 
<a class="summary-letter" href="#g_t_ac1c_b150_acfc-_ad00_b828_b41c-_c0c9_c778_cp_letter-V"><b>V</b></a>
 &nbsp; 
<a class="summary-letter" href="#g_t_ac1c_b150_acfc-_ad00_b828_b41c-_c0c9_c778_cp_letter-W"><b>W</b></a>
 &nbsp; 
<a class="summary-letter" href="#g_t_ac1c_b150_acfc-_ad00_b828_b41c-_c0c9_c778_cp_letter-결"><b>결</b></a>
 &nbsp; 
<a class="summary-letter" href="#g_t_ac1c_b150_acfc-_ad00_b828_b41c-_c0c9_c778_cp_letter-고"><b>고</b></a>
 &nbsp; 
<a class="summary-letter" href="#g_t_ac1c_b150_acfc-_ad00_b828_b41c-_c0c9_c778_cp_letter-그"><b>그</b></a>
 &nbsp; 
<a class="summary-letter" href="#g_t_ac1c_b150_acfc-_ad00_b828_b41c-_c0c9_c778_cp_letter-내"><b>내</b></a>
 &nbsp; 
<a class="summary-letter" href="#g_t_ac1c_b150_acfc-_ad00_b828_b41c-_c0c9_c778_cp_letter-네"><b>네</b></a>
 &nbsp; 
<a class="summary-letter" href="#g_t_ac1c_b150_acfc-_ad00_b828_b41c-_c0c9_c778_cp_letter-문"><b>문</b></a>
 &nbsp; 
<a class="summary-letter" href="#g_t_ac1c_b150_acfc-_ad00_b828_b41c-_c0c9_c778_cp_letter-배"><b>배</b></a>
 &nbsp; 
<a class="summary-letter" href="#g_t_ac1c_b150_acfc-_ad00_b828_b41c-_c0c9_c778_cp_letter-순"><b>순</b></a>
 &nbsp; 
<a class="summary-letter" href="#g_t_ac1c_b150_acfc-_ad00_b828_b41c-_c0c9_c778_cp_letter-외"><b>외</b></a>
 &nbsp; 
<a class="summary-letter" href="#g_t_ac1c_b150_acfc-_ad00_b828_b41c-_c0c9_c778_cp_letter-일"><b>일</b></a>
 &nbsp; 
<a class="summary-letter" href="#g_t_ac1c_b150_acfc-_ad00_b828_b41c-_c0c9_c778_cp_letter-제"><b>제</b></a>
 &nbsp; 
<a class="summary-letter" href="#g_t_ac1c_b150_acfc-_ad00_b828_b41c-_c0c9_c778_cp_letter-행"><b>행</b></a>
 &nbsp; 
<a class="summary-letter" href="#g_t_ac1c_b150_acfc-_ad00_b828_b41c-_c0c9_c778_cp_letter-확"><b>확</b></a>
 &nbsp; 
<a class="summary-letter" href="#g_t_ac1c_b150_acfc-_ad00_b828_b41c-_c0c9_c778_cp_letter-환"><b>환</b></a>
 &nbsp; 
</td></tr></table>

<hr>
<a name="References-_0028_cc38_ace0_bb38_d5cc_0029"></a>
<a name="References-_0028camgomunheon_0029"></a>
<h2 class="appendix">Appendix F References (참고문헌)</h2>

<p>D. M. Bates and D. G. Watts (1988), <em>Nonlinear Regression
Analysis and Its Applications.</em> John Wiley &amp; Sons, New York.
</p>
<p>Richard A. Becker, John M. Chambers and Allan R. Wilks (1988),
<em>The New S Language.</em> Chapman &amp; Hall, New York.  This book is often
called the &ldquo;<em>Blue Book</em>&rdquo;.
</p>
<p>John M. Chambers and Trevor J. Hastie eds. (1992), <em>Statistical
Models in S.</em> Chapman &amp; Hall, New York.  This is also called the
&ldquo;<em>White Book</em>&rdquo;.
</p>
<p>John M. Chambers (1998)  <em>Programming with Data</em>. Springer, New
York.  This is also called the &ldquo;<em>Green Book</em>&rdquo;.
</p>
<p>A. C. Davison and D. V. Hinkley (1997), <em>Bootstrap Methods and
Their Applications</em>, Cambridge University Press.
</p>
<p>Annette J. Dobson (1990), <em>An Introduction to Generalized Linear
Models</em>, Chapman and Hall, London.
</p>
<p>Peter McCullagh and John A. Nelder (1989), <em>Generalized Linear
Models.</em> Second edition, Chapman and Hall, London.
</p>
<p>John A.&nbsp;Rice (1995), <em>Mathematical Statistics and Data Analysis.</em>
Second edition.  Duxbury Press, Belmont, CA.
</p>
<p>S. D. Silvey (1970), <em>Statistical Inference.</em> Penguin, London.
</p>
<div class="footnote">
<hr>
<h4 class="footnotes-heading">Footnotes</h4>

<h3><a name="FOOT1" href="#DOCF1">(1)</a></h3>
<p>ACM Software Systems award, 1998:
<a href="http://awards.acm.org/award_winners/chambers_6640862.cfm">http://awards.acm.org/award_winners/chambers_6640862.cfm</a>.</p>
<h3><a name="FOOT2" href="#DOCF2">(2)</a></h3>
<p>R 패키지들에서 사용되는 R 코드의 경우를 포함하여 오로지 A&ndash;Za&ndash;z0&ndash;9만이 사용되어야
합니다.</p>
<h3><a name="FOOT3" href="#DOCF3">(3)</a></h3>
<p>문자열 내부 또는
함수의 정의에서 사용되는 인자들을 나열하는 부분은 <strong>제외</strong></p>
<h3><a name="FOOT4" href="#DOCF4">(4)</a></h3>
<p>일부 콘솔의 경우 더 이상 입력할 수 없도록 하거나, 경고메시지 없이
입력범위를 초과한 부분을 잘라내기도 합니다.  어떤 콘솔의 경우에는 초과된 부분을 다음행의 새로운 시작으로 사용하기도 합니다.</p>
<h3><a name="FOOT5" href="#DOCF5">(5)</a></h3>
<p>여기에서 사용된 것과 같이 &ldquo;dot&rdquo;으로 시작하는 이름을 가진 파일은 UNIX 환경에서
파일들의 목록을 출력시에 보여지지 않게(<em>invisible</em>) 됩니다. and in default GUI file
listings on OS X and Windows. </p>
<h3><a name="FOOT6" href="#DOCF6">(6)</a></h3>
<p><code>list</code> 처럼 벡터형의 인자가 아닌 데이터에 대해 <code>c()</code> 함수를 사용하면, 그
결과가 다소 다르게 나타납니다. 자세한 것은 See <a href="#Concatenating-lists-_0028_b9ac_c2a4_d2b8-_c5f0_acb0_d558_ae30_0029">Concatenating lists (리스트 연결하기)</a>.</p>
<h3><a name="FOOT7" href="#DOCF7">(7)</a></h3>
<p>실제로 이 표현식 실행 후, 아직 다음 명령문을 실행하지 않았다면
<code>.Last.value</code> 함수를 사용하여 결과물을 한 번 더 확인하는 것은 가능합니다. </p>
<h3><a name="FOOT8" href="#DOCF8">(8)</a></h3>
<p><code>paste(...,collapse=<var>ss</var>)</code>라고 하게되면 인자들 사이에 <var>ss</var>를
넣어 하나의 문자열을 만듭니다. 문자열을 다루는 방법에 대해 더 많이 알고 싶으시다면 <code>sub</code>와
<code>substring</code>를 살펴보시길 바랍니다.</p>
<h3><a name="FOOT9" href="#DOCF9">(9)</a></h3>
<p><em>numeric</em>(수치형) 모드라는 것은
사실 <em>integer</em>(정수형)과 <em>double</em> precision (배정밀도)라는 두가지의 다른 모드가 합쳐진
것입니다</p>
<h3><a name="FOOT10" href="#DOCF10">(10)</a></h3>
<p>그러나,
<code>length(<var>object</var>)</code>가 항상 본질적이고 유용한 정보를 제공하는 것은 아닙니다.
<code><var>object</var></code>가 함수인 경우가 여기에 해당합니다.</p>
<h3><a name="FOOT11" href="#DOCF11">(11)</a></h3>
<p>일반적으로, 숫자에서 문자로 강제형변환 한 뒤 다시 숫자로
변경할때에는, 문자형을 표현할 때의 round off errors(반올림 오차) 때문에, 원래의 숫자와 완전히 같은 값이 되지는
않습니다.</p>
<h3><a name="FOOT12" href="#DOCF12">(12)</a></h3>
<p>&lsquo;formal&rsquo; 또는 &lsquo;S4&rsquo; 와 같은 다른 종류의 클래스에 기반한 스타일은 패키지 <code>methods</code>를 통해
사용 가능합니다.</p>
<h3><a name="FOOT13" href="#DOCF13">(13)</a></h3>
<p>&lsquo;<samp><code>tapply(incomes, state)</code></samp>&rsquo;의
경우와 같이 <code>tapply()</code>의 두번째 인자가 꼭 요인(factor)일 필요는 없습니다. 이 함수는 필요한 경우에는
<code>as.factor()</code>를 사용한 것처럼 두번째 인자를 강제형변환 <em>coerced</em> 한 후, 연산을 수행하기
때문입니다.</p>
<h3><a name="FOOT14" href="#DOCF14">(14)</a></h3>
<p><code>x %*% x</code>는 올바른 식이라고 보기 어려운데, 이는 사용자가 수행하고자 하는 연산이 x&rsquo;x 인지
x x&rsquo;인지 분명하지 않기 때문입니다. 여기에서 x는 열벡터 입니다.이 경우, 더 작은 크기의 행렬을
선호하는 특성 때문에 스칼라 값(즉, 한개의 숫자)인  x&rsquo;x을 결과로 출력합니다.x x&rsquo;의 행렬연산을 수행하고 싶다면
<code>cbind(x) %*% x</code> 또는 <code>x %*% rbind(x)</code>을 사용해야 하는데, <code>rbind()</code> 이나
<code>cbind()</code>을 사용한 결과가 항상 행렬이기 때문입니다.하지만, 아무래도 x&rsquo;x이나 x x&rsquo;을 계산하는 가장 좋은
방법은 각각의 경우 함수 <code>crossprod(x)</code>와 <code>x %o% x</code>를 사용하는 것입니다.</p>
<h3><a name="FOOT15" href="#DOCF15">(15)</a></h3>
<p>좀 더 좋은 방법은 행렬의 제곱근(matrix square root)인 B를
찾는 것입니다. 여기서 행렬의 제곱근 B는 A = BB&rsquo;으로 정의되며, A의 콜레스키
분해(Cholesky decomposition)나 아이겐 분해(eigen decomposition)를 이용하면 By = x의 해의 제곱길이 (squared length)를 찾는 과정을 통해 이차 행렬식을 풀게 됩니다.</p>
<h3><a name="FOOT16" href="#DOCF16">(16)</a></h3>
<p>문자형 벡터의 경우,
<code>data.frame()</code>함수의 <code>stringsAsFactors</code> 인자를 사용하여 요인으로 강제변환하는 것도
가능합니다</p>
<h3><a name="FOOT17" href="#DOCF17">(17)</a></h3>
<p>두번째로 출력된 <code>autoload</code>에 대해서는 온라인 도움말을 살펴보시길 바랍니다</p>
<h3><a name="FOOT18" href="#DOCF18">(18)</a></h3>
<p>유닉스
운영체제에서 Sed 또는 Awk와 같은 유틸리티들</p>
<h3><a name="FOOT19" href="#DOCF19">(19)</a></h3>
<p>또는 <a href="http://CRAN.R-project.org/package=lattice"><strong>lattice</strong></a>에 있는 <code>xyplot</code>함수를
이용할 수 있습니다.</p>
<h3><a name="FOOT20" href="#DOCF20">(20)</a></h3>
<p><a href="#Statistical-models-in-R-_0028R_c5d0_c11c-_c0ac_c6a9_b418_b294-_d1b5_acc4_baa8_d615_b4e4_0029">Statistical models in R (R에서 사용되는 통계모형들)</a>에 설명된 다른 방법들을
살펴보시길 바랍니다</p>
<h3><a name="FOOT21" href="#DOCF21">(21)</a></h3>
<p>어떤한 의미로는 이것은 <small>S-PLUS</small>의
기능을 흉내낸 것처럼 보일 수도 있습니다. 그 이유는 <small>S-PLUS</small>의 연산이 항상 전역변수를 생성하고 이에 값을 할당하기 때문입니다</p>
<h3><a name="FOOT22" href="#DOCF22">(22)</a></h3>
<p>UNIX에서는 숨겨진 파일입니다.</p>
<h3><a name="FOOT23" href="#DOCF23">(23)</a></h3>
<p>마찬가지로, ANCOVA를 표기할 때도
classification을 따로 명시하지는 않지만, 이 방법의 역시 보통 연속형 변수인 공변량(covariate)이 포함된다는 것
외에는 ANOVA와 유사한 분석을 수행하므로 이렇게 표현한 것 같습니다.</p>
<h3><a name="FOOT24" href="#DOCF24">(24)</a></h3>
<p>물론 이 중 일부 그래픽
파라미터들은 현재 디바이스의 크기 처럼, 오직 정보 확인의 목적만을 가진 것들도 있습니다.</p>
<h3><a name="FOOT25" href="#DOCF25">(25)</a></h3>
<p>프로세스당 3Gb를 지원하는 Windows에서는
2.5Gb이며, 이는 <samp>rw-FAQ</samp> Q2.9를 살펴보세요; 일부 64 비트의 Windows는 3.5Gb입니다</p>
<h3><a name="FOOT26" href="#DOCF26">(26)</a></h3>
<p>R
2.13.0부터</p>
<h3><a name="FOOT27" href="#DOCF27">(27)</a></h3>
<p>&lsquo;Emacs Speaks Statistics&rsquo;패키지를 말하며, <acronym>URL</acronym>
<a href="http://ESS.R-project.org">http://ESS.R-project.org</a>를 살펴보시길 바랍니다</p>
<h3><a name="FOOT28" href="#DOCF28">(28)</a></h3>
<p>PC 키보드에서는 이것은 일반적으로 Alt
키이거나 가끔 &lsquo;Windows&rsquo;키이기도 합니다. Mac 키보드에서는 일반적으로 사용가능한 메타키가 없습니다</p>
</div>
<hr>



</body>
</html>
